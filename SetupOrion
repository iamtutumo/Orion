#!/bin/bash 
########################################## ######## 

version() { 
echo -e "\e[97mCommunity: https://chat.whatsapp.com/Ky7uW2hUIf7DfPbIDugKS5 \e[97mSetup Version \e[32mv.2.4.1\e[0m " 
} 

############################################## #### 

## Setup colors 

yellow="\e[33m" 
green="\e[32m" 
white="\e[97m" 
beige="\e[93m" 
red="\e[91m" 
reset ="\e[0m" 

######################################### ######### 

## Data location for upcoming installations 
home_directory="$HOME" 
#file="/root/dados_vps/dados_vps" 
file="${home_directory}/dados_vps/dados_vps" 

dados() { 
    server_name =$(grep "Server Name:" "$file" | awk -F': ' '{print $2}') 
    internal_network_name=$(grep "Internal network:" "$file" | awk -F': ' '{ print $2}') 
} 

########################################## ######## 

## Setup License 

installer_rights() { 
    echo -e "$yellow============= =================================================== =====================\e[0m" 
    echo -e "$yellow= =\e[0m" 
    echo -e "$yellow= $white This self -installer was developed to assist in the installation of the main applications $amarelo =\e[0m" 
    echo -e "$amarelo= $branco available on the open source market. I already give all the credits to the developers of each $amarelo =\e[0m" 
    echo -e "$amarelo= $branco application available here. This Setup is licensed under the MIT License (MIT). You can use,$amarelo =\e[0m" 
    echo -e "$amarelo= $branco copy, modify, integrate, publish, distribute and/or sell copies of the final products, $amarelo =\e[0m" 
    echo - and "$amarelo= $branco but you must always declare that OrionDesign (contato@oriondesign.art.br) is the original author $amarelo =\e[0m" 
    echo -e "$amarelo= $branco of these codes and assign a link to https://oriondesign.art.br/setup $yellow =\e[0m" 
    echo -e "$yellow= =\e[0m" 
    echo -e "$yellow==================== =================================================== ==============================\e[0m" 
    echo "" 
    echo "" 
    read -p "By typing Y you accept and agree with the instructions given above (Y/N): " choice 
    if [ "$choice" = "Y" ] || [ "$choice" = "y" ]; then 
        return 
    else
        echo "Too bad you don't agree, so I'll be closing the installer. Until later." 
        sleep 2 
        clear 
        exit 1 
    fi 
} 

## Setup credit 

creditos_msg() { 
    echo "" 
    echo "" 
    echo -e "$amarelo==================================== =================================================== ===========================\e[0m" 
    echo -e "$yellow= $yellow=\e[0m" 
    echo -e "$amarelo= $branco Would you like to contribute to continue the development of this project? $amarelo=\e[0m" 
    echo -e "$amarelo= $branco You can make a donation via PIX: $amarelo=\e[ 0m" 
    echo -e "$amarelo= $amarelo=\e[0m" 
    echo -e "$amarelo= pix@oriondesign.art.br $amarelo=\e[0m" 
    echo -e "$amarelo= $amarelo=\ e[0m" 
    echo -e "$amarelo= $branco If you need help/mentoring or want to leave feedback $amarelo=\e[0m" 
    echo -e "$amarelo= $branco Our community:$amarelo https:// discord.gg/ZvtmFtMt82 $yellow=\e[0m" 
    echo -e "$yellow= $yellow=\e[0m" 
    echo -e "$yellow= $white or via WhatsApp (SetupOrion community) $yellow=\e[ 0m" 
    echo -e "$yellow= $yellow https://chat.whatsapp.com/LvqP8e7lNPn9Y3QMbbnhfB $yellow=\e[0m" 
    echo -e "$yellow= $yellow=\e[0m" 
    echo -e "$yellow================= =================================================== ===============================\e[0m" 
    echo "" 
    echo "" 
} 


####### ########################################### 

## General messages 

# # Message asking to fill in the information 

fill_as_info() { 
    echo -e "$amarelo================================ =================================================== =================\e[0m"  
    echo -e "$yellow= $white Fill in the information requested below $yellow=\e[0m"
    echo -e "$yellow= $yellow=\e[0m" 
    echo -e "$yellow============================ =================================================== ====================\e[0m" 
    echo "" 
    echo "" 
} 

## Message asking to check if the information is correct 

conferring_as_info() { 
    echo -e "$yellow=========================================================== =================================================== ==\e[0m" 
    echo -e "$yellow= $yellow=\e[0m" 
    echo -e "$yellow= $white Check that the data below is correct $yellow=\e[0m" 
    echo -e " $yellow= $yellow=\e[0m" 
    echo -e "$yellow================================= =================================================== ================\e[0m" 
    echo "" 
    echo "" 
} 

## Save the data message 

guarde_os_dados_msg() { 
    echo -e "$amarelo====== =================================================== =========================================================\e[0m" 
    echo - e "$yellow= $yellow=\e[0m" 
    echo -e "$yellow= $white Please save all the data below to avoid future inconveniences.$yellow=\e[0m" 
    echo -e "$yellow= $yellow=\e[0m" 
    echo -e "$yellow===================== =================================================== ============================\e[0m" 
    echo "" 
    echo "" 
} 

## Message from Installing 

installing_msg() { 
  echo "" 
  echo -e "$yellow============================================ =================================================== =======\e[0m" 
  echo -e "$yellow= =\e[0m" 
  echo -e "$yellow= $white ██╗███╗ ██╗██████ █╗████████╗ █████╗ ██╗ █████╗ ███╗ ╗ ██████╗ $yellow = \e[0m" 
  echo -e "$yellow= $white ██║████╗ ██║██╔════╝╚══██╔══╝██╔══█ █╗ ██║ ██╔══██╗████╗ ██║██╔══██╗██╔═══██╗ $yellow =\e[0m" 
  echo -e "$yellow = white ███║██╔██ ╗ ██║██║ ██║██║ ██║ $yellow =\e[0m" 
  echo -e "$yellow = white ══██║██║╚ ██╗██║██║ ██║██║ ██║ $yellow =\e[0m" 
  echo -e "$yellow= $white ██║██║ ╚████║█ ██ ████║ ██║ ██║ ██║███████╗██║ ██║██║ ╚████║██ ████╔╝╚████ ██╔╝ $yellow =\e[0m"
  echo -e "$yellow= $white ╚═╝╚═╝ ╚═══╝╚══════╝ ╚═╝ ╚═╝ ╚═╝╚══════ ╝╚═╝ ╚═ ╝╚═╝ ╚═══╝╚═════╝ ╚═════╝ $yellow =\e[0m" 
  echo -e "$yellow= =\e[0m" 
  echo -e "$yellow =================================================== =================================================\ e[0m" 
  echo "" 
  echo "" 
} 

## Error message 

error_msg() { 
   echo -e "$amarelo====================================== =================================================== ========================\e[0m" 
   echo -e "$yellow= =\e[0m" 
   echo -e "$yellow= $ white███████╗██████╗ ██████╗ ██████╗ $yellow=\e[0m" 
   echo -e "$yellow= $white██╔ ════╝******************* ╗ yellow = \ and [0m " 
   echo -e" $ yellow = $ white day laffles ██╗ ██████╔╝██████╔╝██║ ██║ $yellow=\e[0m" 
   echo -e "$yellow= $white██╔══╝ █ ╔══██╗██╔══██╗██║ ██║ $yellow=\e[0m" 
   echo -e "$yellow= $white███████╗██║ █ █ ║██║ ██║╚██████╔╝ $yellow=\e[0m" 
   echo -e "$yellow= $white╚══════╝╚═╝ ╚═╝╚═ ╝ ╚═╝ ╚═════╝ $yellow=\e[0m" 
   echo -e "$yellow= =\e[0m" 
   echo -e "$yellow============= =================================================== =====================================\e[0m" 
} 

## Installed Message 

installed_msg() { 
    clear 
    echo "" 
    echo -e "$yellow======================================= =================================================== =================
    ​ 
    ​██╗ █████╗ ██╗ █████╗ ██████╗ ██████╗ ██╗\e[0m" 
    echo -e "$ white ╚██╗ ██║████╗ ██║██╔════╝╚══██╔══╝██╔══██╗██║ █╔══██╗██╔ ══██╗██╔═══██╗ ██╔╝\e[0m" 
    echo -e "$white ╚═╝ ╚═╝╚═╝ ╚═══╝╚══════╝ ╚═╝ ╚═╝ ╚═╝╚═══ ═══╝╚═╝╚═╝╚═════╝ ╚═════╝ ╚═╝\e[0m" 
    echo "" 
    echo -e "$white ╚██╗ ██║██╔██╗ ██║███████╗ ██║███████║███
    echo -e "$white ██╔╝ ██║██║ ╚████║███████║ ██║ ██║ ██║███ ████╗██║ ██║██████╔╝╚██████╔╝ ╚██╗\e[0m" 
    echo -e "$yellow=============== =================================================== ==================================\e[0m" 
    echo "" 
    echo "" 
} 

## Testing Message 

test_name() { 
  clear 
  echo "" 
  echo -e "$white ████████╗███████╗███████╗████████╗ ██ ███╗ ███╗ ██╗██████╗ ██████╗ \e[0m" 
  echo -e "$white ╚══██╔══╝█ █╔══ ══╝██╔════╝╚══██╔══╝██╔══██╗████╗ ██║██╔═ ═██╗██╔═══ ██╗\e[0m" 
  echo -e "$white ██║ █████╗ ███████╗ ██║ ███████║██╔ ██╗ ██ ║██║ ██║██║ ██║\e[0m" 
  echo -e "$white ██║ ██╔══╝ ╚════██║ ██║ █╔══█ █║██║╚██╗██║██║ ██║██║ ██║\e[0m" 
  echo -e "$white ██║ ███████╗ ████ ███║ ██║ ██║ ██║██║ e[0m" 
  echo -e "$blank ╚═╝ ╚══════╝╚══════╝ ╚═╝ ╚═╝ ╚═╝╚═╝ ╚═══╝╚══ ═══╝ ╚═════╝ \e[0m" 
  echo "" 
  echo "" 
} 

#################################### ############## 

## Titles 

## Installer name 

installer_name() { 
    clear 
    echo "" 
    echo -e "$branco ███████╗███████ ╗████████╗██╗ ██╗██████╗ ██████╗ ██████╗ ██ ╗ ██████╗ ███ ╗ ██╗\e[0m" 
    echo -e "$white ██╔════╝██╔════╝╚══██╔══╝██║ ██║ ██╔═ ═██╗ ██╔═══██╗██╔══██╗██║██╔═══██╗████╗ ║\e[0m" 
    echo -e " white █████╔╝██║ ██║ ██║██╔██╗ ██║\e[0m" 
    echo -e "$white ╚════██║██╔══╝ ██║ ██ ║ ██║█ █╔═══╝ ██║ ██║██╔══██╗██║██║ ██║██║╚██╗██║\e [0m" 
    echo -e "$blank ███████║███████╗ ██║ ╚██████╔╝██║ ╚██████╔ ╝██║ ██║██║╚ ██████╔╝██║ ╚████║\e[0m" 
    echo -e "$white ╚══════╝╚══════╝ ╚═ ╝ ╚══ ═══╝ ╚═╝ ╚═════╝ ╚═╝ ╚═╝╚═╝ ╚═════╝ ╚═╝ e[0m" 
    echo -e "$white \ e[0m" 
    echo -e "$white ██╗ ██╗ ██████╗ \e[0m" 
    echo -e "$white █████╗ ██║ ██║ ████ █╔╝ █████╗ \e[0m" 
    echo -e "$white ╚════╝ ╚██╗ ██╔╝ ██╔═══╝ ╚═══ ═╝ \e[ 0m" 





  echo -e "$blank██║ ██╔══╝ ╚════██║ ██║ ██╔══╽ [0m" 
  echo -e "$white ██║ ███████╗█████ ██║ ██ ║ ███████╗ ██████╔╝███████╗\e[0m" 
  echo -e "$blank╚═╝ ╚══════╝╚══════╝ ╚═╝ ╚══════╝ ╚═════╝ ╚═ ═════╝\e[0m" 
  echo -e "$blank \e[0m" 
  echo -e "$white ███████╗███╗ ███╗ █████╗ ██╗██╗ \e[0m" echo 
  -e " $white ██╔════╝████╗ ████║██╔══██╗██║██║ \e[0m" 
  echo -e "$white ██ ███ ╗ ██╔████╔██║███████║██║██║ \e[0m" 
  echo -e "$white ██╔══╝ ██║ ╚██╔ ╝██║██╔══██║██║██║ \e[0m" 
  echo -e "$white ███████╗██║ ╚═╝ ██║ ██║ █ █║██║███████╗ \e[0m" 
  echo -e "$white ╚══════╝╚═╝ ╚═╝╚═╝ ╚═╝╚═ ╝╚══ ════╝ \e[0m" 
  echo "" 
  echo ""                                                           
} 

## Title Traefik and Portainer [1] 

name_traefik_e_portainer() { 
    clear 
    echo "" 
    echo -e "$white ████████╗█ █████╗ █████╗ ███████╗███████╗██╗██╗ ██╗ ██ █████╗ \e[0m" 
    echo -e "$white ╚══██╔══╝██╔══██╗██╔══██╗██╔════╝██╔═ ═══╝██║ ██║ ██╔╝ ██╔════╝ \e[0m" 
    echo -e "$white ██║ ██████╔╝███████║█ ████ ╗ █████╗ ██║█████╔╝ █████╗ \e[0m" 
    echo -e "$white ██║ ██╔══██╗ ██╔══ ██║██╔══╝ ██╔══╝ ██║██╔═██╗ ██╔══╝ \e[0m" 
    echo -e "$white ██║ ██║ ██ ║██║ ██║███████╗██║ ██║██║ ██╗ ███████╗ \e[0m" 
    echo -e "$white ╚═╝ ╚ ═╝ ╚═╝╚═╝ ╚═╝╚══════╝╚═╝ ╚═╝╚═╝ ╚═╝ ╚══════╝ \e[0m" 
    echo -e "$blank \e[0m" 
    echo -e "$white ██████╗ ██████╗ ██████╗ ████████╗ ╗ ██╗ ███╗ ██╗███████╗██████╗ \e[0m" 
    echo -e "$white ██╔══██╗██╔══ ═██╗ ██╔══██╗╚══██╔══╝██╔══██╗██║████╗ ██║██╔═ ═══╝██╔══█ █╗ \e[0m" 
    echo -e "$white ██████╔╝██║ ██║██████╔╝ ██║ ███████║ ██║█ █╔██╗ ██║█████╗ ██████╔╝ \e[0m" 
    echo -e "$white ██║ ╚██████╔╝█ █║ ██ 
    -e "$white ╚═╝ ╚═════╝ ╚═╝ ╚═╝ ╚═╝ ╚═╝ ╚═╝╚═╝╚═╝ ╚═══╝╚════ ══╝╚═╝ ╚═╝ \e[ 0m" 
    echo "" 
    echo "" 
} 

## Chatwoot Title [2] 

chatwoot_name(){ 
    clear 
    echo"" 
    echo -e "$white ██████╗██╗ ██╗ █████╗ ████████╗██╗ ██╗ ████╗ █ █████╗ ████████╗\e[0m"
    echo -e "$white ██╔════╝██║ ██║██╔══██╗╚══██╔══╝██║ ██║ ██╔═══█ █╗██╔═══██╗╚══██╔══╝\e[0m"██╔╝██╔══██╗██╔════╝██╔══██╗██╔═══██╗╚══ ██╔══╝\e[0m " 
    echo -e "$white ██║ ╚████╔╝ ██████╔╝█████╗ ██████╔╝██║ █ █║ ██║ \e [0m"██║██╔═══██╗██╔═══██╗╚══██╔══╝\e[0m" 
    echo -e "$white ██║ ██ ████ █║███████║ ██║ ██║ █╗ ██║██║ ██║██║ ██║ ██║ "
    echo -e "$white ██║ ██╔══██║██╔══██║ ██║ ██║███╗██║██║ ║██║ ██║ ██║ \e[0m" 
    echo -e "$white ╚██████╗██║ ██║██║ ██║ ██║ ╚███╔███ ╔╝╚██ ████╔╝╚██████╔╝ ██║ \e[0m" 
    echo -e "$white ╚═════╝╚═╝ ╚═╝╚═╝ ═╝ ╚═ ╝ ╚══╝╚══╝ ╚═════╝ ╚═════╝ ╚═╝ \e[0m" 
    echo "" 
    echo "" 
} 

## Title Evolution [3] 

name_evolution() { 
    clear 
    echo "" 
    echo -e "$white ███████╗██╗ ██╗ ██████╗ ██╗ ██╗ ██╗█████ ███╗██ ╗ ██████╗ ███╗ ██╗ █████╗ ██████╗ ██╗\e[0m" 
    echo -e "$white ██╔ ════╝ ██║ ██║██╔═══██╗██║ ██║ ██║╚══██╔══╝██║██╔ ═══██╗████╗ ██║ ██╔══██╗██╔══██╗██║\e[0m" 
    echo -e "$white █████╗ ██║ █║ ██ ║██║ ██║ ██║ ██║ ██║██║ ██║██╔██╗ ██║ ███████ ║██████╔╝██║ \e[0m" 
    echo -e "$white ██╔══╝ ╚██╗ ██╔╝██║ ██║██║ ██║ ██║ ██║ ║██║ █ █║██║╚██╗██║ ██╔══██║██╔═══╝ ██║\e[0m" 
    echo -e "$white █████ ██╗ ╚ ████╔╝ ╚██████╔╝███████╗╚██████╔╝ ██║ ██║╚ ██████╔╝██║ ╚████║ ██║ ██║██║ ██║\e[0m" 
    echo -e "$white ╚══════╝ ╚═══╝ ╚══ ═══╝ ╚ ══════╝ ╚═════╝ ╚═╝ ╚═╝ ╚═════╝ ╚═╝ ╚═══╝ ╚═╝ ╚═╝╚═╝ ╚═╝\e[ 0m" 
    echo "" 
    echo ""                                                                                         
} 

## Title Mini [4] 

mininame() { 
    clear 
    echo "" 
    echo -e "$white ███╗ ███╗██╗███╗ ██╗██ ╗ ██████╗ \e[0m" 
    echo -e "$white ████╗ ████║██║████╗ ██║██║██╔ ═══█ █╗\e[0m" 
    echo -e "$white ██╔████╔██║██║██╔██╗ ██║██║██║ ██║\e[0 m" 
    echo -e "$ 
    white ██║ ╚═╝ ██║██║██║ ╚████║██║╚██████╔╝\e[0m" 
    echo -e "$white ╚═ ╝ ╚═╝ ██
    ​                                   
​

​

​
    ​
    ​ 
    ​██████╗██╗ ██╗██████╗ ███████╗██████╗ ████ ██╗ ████████ ╗\e[0m" 
    echo -e "$white ╚══██╔══╝╚██╗ ██╔╝██╔══██╗██╔════╝█ █╔══ ██╗██╔═══██╗╚══██╔══╝\e[0m" 
    echo -e "$white ██║ ╚██╔╝ ██╔═══ ╝ ██╔ ══╝██╔══██╗██║ ██║ ██║ \e[0m" 
    echo -e "$white ██║ ██║ ██║ ███████╗ █████ █╔╝╚██████╔╝ ██║ \e[0m"
    echo " " 
    echo 
    " "                                                     
} 

## Title N8N [6] 

name_n8n() { 
    clear 
    echo "" 
    echo -e "$white ███╗ ██╗ █████╗ ███╗ ██╗\e[0m" 
    echo - " 
    ╚█ ████╔╝██╔██╗ ██║\e[0m" 
    echo -e "$white ██║╚██╗██║██╔══██╗██ ║╚██ ╗██║\e[0m" 
    echo -e "$white ██║ ╚████║╚█████╔╝██║ ╚████║\e[0m" 
    echo -e " $white ╚═╝ ╚═══╝ ╚════╝ ╚═╝ ╚═══╝\e[0m" 
    echo "" 
    echo ""                      
} 

## Flowise title [7] 

flowise_name() { 
    clear 
    echo " " 
    echo -e "$white ███████╗██╗ ██████╗ ██╗ ██╗██╗███████╗██ █████╗ \e[0m" 
    echo -e "$white ██╔════╝██║ ██╔═══██╗██║ ██║██║██╔═══ ═╝██ ╔════╝\e[0m" 
    echo -e "$white █████╗ ██║ ██║ ██║██║ █╗ ██║██║██ █████ ╗█████╗ \e[0m" 
    echo -e "$white ██╔══╝ ██║ ██║ ██║██║███╗██║██║ ╚═══ ═██║██╔══╝ \e[0m" 
    echo -e "$white ██║ ███████╗╚██████╔╝╚███╔ ███╔ ╝██║███████║███████╗\e[0m" 
    echo -e "$white ╚═╝ ╚══════╝ ╚═══ ══╝ ╚ ══╝╚══╝ ╚═╝╚══════╝╚══════╝\e[0m" 
    echo "" 
    echo "" 
} 

## PgAdmin Title [8] 

pgAdmin_name_4() { 
    clear 
    echo "" 
    echo -e "$white ██████╗ ██████╗ █████╗ ██████╗ ███╗ ███╗ ██╗███ ╗ ██╗ ██╗ ██╗\e[0m" 
    echo -e "$white ██████╔╝██║ ███╗███████║█ █║ ██║ ██╔████╔██║██║██╔██╗ ██║ ███████║\e[0m" 
    echo -e "$white ██╔═ ══╝ █ █║ ██║██╔══██║██║ ██║ ╚════██ ║\e[0m" 
    echo -e "$white ██║ ╚██████╔╝██║ ██║██████╔╝██║ ╚═╝ █ █║██║ ██║ ╚████║ ██║\e[0m" 
    echo -e "$white ╚═╝ ╚═════╝ ╚═╝ ╚═╝╚═════ ╝ ╚═╝ ╚ ═╝╚═╝╚═╝ ╚═══╝ ╚═╝\e[0m" 
    echo "" 
    echo ""                                                                   
} 

## TitleNocobase [9] 

nocobase_name() { 
    clear  
    echo ""
    echo -e "$white ███╗ ██╗ ██████╗ ██████╗ ██████╗ ██╗ █████╗ ███████╗███████╗\e[0m" 
    echo -e "$white ████╗ ██║██╔═══██╗██╔══ ══╝█ \ e[0m" 
    echo -e "$ white ██╔██╗ ██║██║ ██║██║ ███ ║███████╗█ ████╗ \e[0m" 
    echo -e "$white ██║╚██╗██║██║ ██║██║ ██║ ██║██╔══ ██╗█ █╔══██║╚════██║██╔══╝ \e[0m" 
    echo -e "$white ██║ ╚████║╚████ ██╔╝ ╚██████╗╚██████╔╝██████╔╝██║ ██║███████║█ ██████╗\e[ 0m" 
    echo -e "$white ╚═╝ ╚═══╝ ╚═════╝ ╚═════╝ ╚═════╝ ╚═════ ╝ ╚═╝ ╚═╝ ╚══════╝╚══════╝\e[0m" 
    echo "" 
    echo ""                                                                  
} 

## Botpress Title [10] 

botpress_name() { 
    clear 
    echo "" 
    echo -e "$white █ █████╗ ██████╗ ████████╗██████╗ ██████╗ ███ ████╗██████ █╗███████╗\e[0m" 
    echo -e "$white ██╔ $ white 
    ██ ████╔╝██║ ██║ ██║ ██████╔╝██████╔╝█████╗ ██ █████╗█████ ██╗\e[0m" 
    echo -e "$white ██╔══██╗██║ ██║ ██║ ██╔═══╝ ██╔══██ ╗██╔═ ═╝ ╚════██║╚════██║\e[0m" 
    echo -e "$white ██████╔╝╚██████╔╝ ██║ █ █║ ██║ ██║███████╗███████║███████║\e[0m" 
    echo -e "$white ╚══ ═══╝ ╚═════╝ ╚═╝ ╚═╝ ╚═╝ ╚═╝╚══════╝╚══════╝╚═══ ═══╝\e[0m" 
    echo " " 
    echo ""                                                           
} 

## Title Wordpress [11] 

wordpress_name() { 
    clear 
    echo "" 
    echo -e "$white ██╗ ██╗ ██████╗ ██████╗ ████ ██╗ ██████╗ ██████╗ ███████╗███████╗██████ █╗\e[0m" 
    echo -e " white ╗██╔══██╗█ █╔════╝██╔════╝██╔════╝\e[0m" 
    echo -e "$white ██║███╗██║██║ ██║ ██╔══██╗██║ ██║██╔═══╝ ██╔══██╗██╔══╝ ╚═══ ═██║╚════██ ║\e[0m" 
    echo -e "$white ╚███╔███╔╝╚██████╔╝██║ ██║██████╔╝█ █║ ██ ║ ██║███████╗███████║███████║\e[0m" 
    echo -e "$blank ╚══╝╚══ ╝ ╚══ ═══╝ ╚═╝ ╚═╝╚═════╝ ╚═╝ ╚═╝ ╚═╝╚══════╝╚════ ══╝╚══════╝ \e[0m" 
    echo "" 
    echo "" 
} 

## Title Baserow [12] 

baserow_name() { 
    clear 
    echo "" 
    echo -e"$white ██████╗ █████╗ ███████╗███████╗██████╗ ██ ████╗ ██╗ █ █╗\e[0m" 
    echo -e "$white ╔══ ██╗██╔═══██╗██║ ██║\e[0m" 
    echo -e "$blank██████╔╝███████║███████╗█████╗ ██████╔╝██ ║ ██║██║ █╗ █ █║\e[0m" 
    echo -e "$white ██╔══██╗██╔══██║╚════██║██╔══╝ ██╔ ══██ ╗██║ ██║██║███╗██║\e[0m"
    echo -e "$white ██████╔╝██║ ██║███████║███████╗██║ ██║╚ ██████╔ ╝╚███╔███╔╝\e[0m" 
    echo -e "$white ╚═════╝ ╚═╝ ╚═╝╚══════╝╚══ ════ ╝╚═╝ ╚═╝ ╚═════╝ ╚══╝╚══╝ \e[0m" 
    echo "" 
    echo ""                                                           
} 

## Title MongoDB [13] 

mongodb_name() { 
  clear 
  echo "" 
  echo -e "white ██████╗ ██ ████╗ \e[0m" 
  echo -e "$white ████╗ ████║██╔═══██╗████╗ ██║██╔ ════ ╝ ██╔═══██╗ ██╔══██╗██╔══██╗\e[0m" 
  echo -e "$white ██╔████╔█ █║██ ║ ██║██╔██╗ ██║██║ ███╗██║ ██║ ██║ ██║██████ ╔╝\e[0m" 
  echo -e "$ white ██║╚██╔╝██║██║ ██║██║╚██╗██║███║ ██║ ██║██╔═ ═██╗\e[0m" 
  echo -e "$white ██║ ╚═╝ ██║╚██████╔╝██║ ╚████║╚███ ███╔ ╝╚██████╔╝ ██████╔╝██████╔╝\e[0m" 
  echo -e "$white ╚═╝ ╚═╝ ╚══ ═══╝ ╚═╝ ╚═══╝ ╚═════╝ ╚═════╝ \e[0m" 
  echo "" 
  echo ""                                                                
} 

## Title RabbitMQ [14] 

name_rabbitmq() { 
  clear 
  echo "" 
  echo -e "$white ██████╗ █████╗ ██████╗ ██████╗ ╗█ ███████╗ ███╗ ███╗ ██████╗ \e[0m" 
  echo -e "$white ██╔══██╗██╔═ ═██╗ ██╔══██╗██╔══██╗██║╚══██╔══╝ ████╗ ████║██ ╔═══██╗\e[ 0m" 
  echo -e "$white ██████╔╝███████║██████╔╝██████╔╝██║ █ █║ ██╔█ ███╔██║██║ ██║\e[0m" 
  echo -e "$white ██╔══██╗██╔══██║██╔══█ █╗██ ╔══██╗██║ ██║ ██║╚██╔╝██║██║▄▄ ██║\e[0m" 
  echo -e "$white ╚═╝ ╚═╝╚═ ╝ ╚═╝╚═════╝ ╚═════╝ ╚═╝ ╚═╝ ╚═╝ ╚═╝ ╚══▀▀═╝ \e[0 m" 
  echo "" 
  echo ""                                                                  
} 


uptimekuma_name () { 
  clear 
  echo "" 
  echo -e "$white ██╗ ██╗██████╗ ████████╗██╗███╗ ██ ███╗ ██╗ ██╗██╗ ██╗███╗ ███╗ █████╗ \e[0m" 
  echo -e "$white ██║ █║██╔ ══██╗╚══██╔══╝██║████╗ ████║██╔════╝ ██║ █ █╔╝██║ ██║██ ██╗ ████║██╔══██╗\e[0m" 
  echo -e "$white ██║ ██║██████╔╝ ██║ █ █║██╔ ████╔██║█████╗ █████╔╝ ██║ ██║██╔████╔██║█ ██████║\e[0m "
} 
  echo -e"white ╔═██╗ ██║ █ █║██║╚██╔╝██║██╔══██║\e[0m"
  echo -e "$white ╚██████╔╝██║ ██║ ██║██║ ╚═╝ ██║███████╗ █ █║ ██╗╚██ ████╔╝██║ ╚═╝ ██║██║ ██║\e[0m" 
  echo -e "$white ╚═════╝ ╚═╝ ╚═╝ ╚═╝╚═ ╝ ╚═╝╚══════╝ ╚═╝ ╚═╝ ╚═════╝ ╚═╝ ╚═╝╚═╝ ╚═╝\e[0 m" 
  echo "" 
  echo "" 

## Calcom Title [16] 

calcom_name() { 
  clear 
  echo "" 
  echo -e "$white ██████╗ █████╗ ██╗ ██████╗ ██████╗ █ ██╗ ███╗\e[0m" 
  echo -e "$white ██╔════╝██╔══██╗██║ ██╔════╝█ █╔══ ═██╗████╗ ████║\e[0m" 
  echo -e "$white ██║ ███████║██║ ██║ ██║ ██║██ ╔████╔██║\e[0m" 
  echo -e "$white ██║ ██╔══██║██║ ██║ ██║ ██║██ ║╚██╔ ╝██║\e[0m" 
  echo -e "$white ╚██████╗██║ ██║███████╗██╗╚█████ █╗╚█ █████╔╝██║ ╚═╝ ██║\e[0m" 
  echo -e "$white ╚═════╝╚═╝ ╚═╝╚═════ ═╝╚═ ╝ ╚═════╝ ╚═════╝ ╚═╝ ╚═╝\e[0m" 
  echo "" 
  echo "" 
} 

## Mautic Title [17] 

mautic_name(){ 
    clear 
    echo "" 
    echo - and "$white ███╗ ███╗ █████╗ ██╗ ██╗████████╗██╗ █████ █╗\e[0m" 
    echo - and "$white ████╗ ████║██╔══██╗██║ ██║╚══██╔══╝██║██ ╔════╝\e [0m" 
    echo -e "$white ██╔████╔██║███████║██║ ██║ ██║ ██║██║ \e[0m" 
    echo - and "$white 
    co █ █║ ╚═╝ ██║██║ ██║╚██████╔╝ ██║ ███████╗\e[0m" 
    echo -e "$white ╚═ ╝ ╚═╝╚═╝ ╚═╝ ╚═════╝ ╚═╝ ╚═════╝ \ and [0m " 
    echo" " 
    echo" "                                               
} 

## Title appsmith [18] 

    echo -e "$white ██╔══██╗██╔══██╗██╔══██╗██╔════╝████╗ █ ███║██║ ╚══██╔══╝██║ ██║\e[0m" 
    echo -e "$white ███████║██████╔╝████ ██╔╝ ███████╗██╔████╔██║██║ ██║ ███████║\e[0m" 
    echo -e "$white ██ ╔══█ █║██╔═══╝ ██╔═══╝ ╚════██║██║╚██╔╝██║██║ █ █║ ██╔══██║\ e[0m" 
    echo -e "$white ██║ ██║██║ ██║ ███████║██║ ╚═╝ ██║██║ ██ ║ ██║ ██ ║\e[0m" 
    echo -e "$white ╚═╝ ╚═╝╚═╝ ╚═╝ ╚══════╝╚═╝ ╚═╝╚═╝ ╚═╝ ═╝ ╚═╝ \e[0m" 
    echo "" 
    echo"" 
} 

## Qdrant Title [19] 

qdrant_name() { 
    clear 
    echo ""
    echo -e "$white ██████╗ ██████╗ ██████╗ █████╗ ███╗ ██╗██ ██████╗\ e[0m"  
    echo -e "$white ██╔═══██╗█ █╔══ ██╗██╔══██╗██╔══██╗████╗██║╚══██╔══╝\e[0m" 
    echo -e "$white ██║ ██║██║ ██║██████╔╝███ ████ ║██╔██╗ ██║ ██║ \e[0m"
    echo -e "$white ██║▄▄ ██║██║ ██║██╔══██╗██╔══██║██║╚██ ╗██║ ██║ \e[0m" 
    echo -e "$white ╚██████╔╝██████╔╝██║ ██║██║ ██║██║ ╚███ █║ ██║ \e[0m" 
    echo -e "$white ╚══▀▀═╝ ╚═════╝ ╚═╝ ╚═╝╚═╝ ╚═╝╚═╝ ╚═══╝ ╚═╝ \e[0m" 
    echo "" 
    echo "" 
} 

## Title WoofedCRM [20] 

woofedcrm_name() { 
    clear 
    echo "" 
    echo -e "$white ██╗ ██╗ ██████╗ █ █████╗ ███████╗███████╗██████╗ ██████╗████ ██╗ ███╗ ███ ╗\e[0m" 
    echo -e "$white ██║ ██║██╔═══██╗██╔═══██╗██╔════╝██ ╔═══ ═╝██╔══██╗ ██╔════╝██╔══██╗████╗ ████║\e[0m" 
    echo -e "$bran co ██║ █╗ ██║██║ ██║██║ ██║█████╗ █████╗ ██║ ██║ ██║ ██████╔╝██╔█ ███╔██║\e[0m" 
    echo -e "$white ██╔═ ═╝ ██║ ██║ ██║ ██╔══██╗██║╚██╔╝██║\e[0m" 
    echo -e "$blank ╚███ ╔███╔ ╝╚██████╔╝╚██████╔╝██║ ███████╗██████╔╝ ╚█ █████╗██║ █ █║██║ ╚═╝ ██║\e[0m" 
    echo -e "$white ╚══╝╚══╝ ╚═════╝ ╚═════╝ ╚ ═╝ ╚══ ════╝╚═════╝ ╚═════╝╚═╝ ╚═╝╚═╝ ╚═╝\e[0m" 
    echo "" 
    echo "" 
} 

## Title Formbricks [21 ] 

name_formbricks() { 
    clear 
    echo "" 
    echo -e "$white ███████╗ ██████╗ ██████╗ ███╗ ███╗███ ███ ╗ ██████╗ ██╗ ██████╗██╗ ██╗███████╗\e[0m" 
    echo -e "$white ██ ███╗ █ █║ ██║██████╔╝██╔████╔██║██████╔╝██████╔ ╝██║██║ ████ █╔╝ ███████╗\e[0m" 
    echo -e "$white ██╔══╝ ██║ ██║██╔══██╗██║╚ ██╔╝ ██║██╔══██╗██╔══██╗██║██║ ██╔═██╗ ╚════██║ \e[0m" 
    echo -e "$ white ██║ ╚██████╔╝██║ ██║██║ ╚═╝ ██║██████╔╝██║ ██║██║╚████ ██╗██║ ██╗███████║\e[0m" 
    echo -e "$white ╚═╝ ╚═════╝ ╚═╝ ╚═╝╚ ═╝ ╚═╝ ╚═════╝ ╚═╝ ╚═╝╚═╝ ╚═════╝╚═╝ ╚═╝╚══════╝\e[0m" 
    echo "" 
    echo "" 
} 

nocodb_name () { 
    clear 
    echo "" 
    echo -e "$white ███╗ ██╗ ██████╗ ██████╗ ██████╗ ██████ ╗ ██ ████╗ \e[0m" 
    echo -e "$white ████╗ ██║██╔═══██╗██╔════╝██╔══ ═██╗ ██╔══██╗██╔══██╗\e[0m" 
    echo -e "$white ██╔██╗ ██║██║ ██║██║ █║ ██ ║██║ ██║██████╔╝\e[0m" 
    echo -e"$white ██║╚██╗██║██║ ██║██║ ██║ ██║██║ ╗\e[0m" 
    echo -e "$white ██║ ╚████║╚██████╔╝╚██████╗╚██████╔╝███ ███╔╝████ ██╔╝\e[0m" 
    echo -e"$white ╚═╝ ╚═══╝ ╚═════╝ ╚═════╝ ╚═════╝ ╚═════╝ ╚ ═════╝ \e[0m " 
    echo "" 
    echo ""                                                  
} 
langfuse_name() { 
    clear 
    echo "" 
    echo -e "$white ██╗ █████╗ ███╗ ██╗ ██████╗ ██████ █╗██╗ ██╗███████╗███████╗\e[0m" 
    echo -e "$white ██║ ██╔══██╗ ████ ╗ ██║██╔════╝ ██╔════╝██║ ██║██╔════╝██╔══ ══╝\e[0m" 
    echo -e "$white ██║ ███████║██╔██╗ ██║██║ ███╗█████╗ ██║ █ █║███████╗ █████╗ \e[0m" 
    echo -e "$white ██║ ██╔══██║██║╚██╗██║██║ ██║██ ╔══╝ ██║ ██║╚════██║██╔══╝ \e[0m" 
    echo -e "$white ███████╗██║ ██║█ █║ ╚█ ███║╚██████╔╝██║ ╚██████╔╝███████║███████ ╗\e[0m" 
    echo -e " $white ╚══════╝╚═╝ ╚═╝╚═╝ ╚═══╝ ╚═════╝ ╚═╝ ╝ ╚══════╝╚ ══════╝\e[0m" 
    echo "" 
    echo "" 
} 

metabase_name() { 
    clear 
    echo "" 
    echo -e "$white ███╗ ███╗███████╗█ ███████╗ █████╗ ██████╗ █████╗ ███████╗████ ███╗\e[0m" 
    echo - and "$white ████╗ ████║██╔════╝╚══██╔══╝██╔══██╗██╔ ══██╗██╔ ══██╗██╔════╝██╔════╝\e[0m" 
    echo -e "$white ██╔████╔██║████ █╗ █ █ ║ e[0m" 
    echo -e "$ white ██║ ╚═╝ ██║███████╗ ██║ ██║ ██║██████╔╝██║ █ █║███████║█ ██████╗\e[0m" 
    echo -e "$white ╚═╝ ╚═╝╚══════╝ ╚═╝ ╚═╝ ╚═╝╚═══ ══╝ ╚═ ████
    ​
    ​
​   

​
    ​
    ​ 
    ​██╗ ██████╗ ██████╗ ██████╗ \e[0m" 
    echo -e "$white ██╔═══██╗██ ╔══█ █╗██╔═══██╗██╔═══██╗\e[0m" 
    echo -e "$white ██║ ██║██║ ██║██║ ██║█ █║ ██║\e[0m" 
    echo -e "$white ██║ ██║██║ ██║██║ ██║██║ ██║\e[0m" 
    echo -e "$ White 
    ╚══ ═══╝ ╚═════╝ ╚═════╝ ╚═════╝ \e[0m" 
    echo "" 
    echo "" 
} 

unoapi_name() { 
    clear 
    echo "" 
    echo -e "$ white ██╗ ██╗███╗ ██╗ ██████╗ █████╗ ██████╗██╗\e[0m" 
    echo -e "$white ██║ ██║████╗ ██║██╔═══██╗ ██╔══██╗█ █╔══ ██╗██║\e[0m" 
    echo -e "$white ██║ ██║██╔██╗ ██║██║ ██║ ███████ ║████ ██╔╝██║\e[0m" 
    echo -e"white █║\e[0m" 
    echo - and "$white ╚██████╔╝██║ ╚████║╚██████╔╝ ██║ ██║██║ █ █║\e[0m" 
    echo -e "$white ╚═════╝ ╚═╝ ╚═══╝ ╚═════╝ ╚═╝ ╚═╝╚═╝ ╚═╝\e[0m" 
    echo "" 
    echo "" 
} 

name_n8n_quepasa(){ 
    clear 
    echo "" 
    echo -e "$white ███╗ ██╗ █████╗ ███╗ ██╗ ███╗ ██╗ ██ ████ ╗ ██████╗ ███████╗███████╗\e[0m" 
    echo -e "$white ████╗ ██║██╔ ══██ ╗████╗ ██║ ████╗ ██║██╔═══██╗██╔══██╗██╔══ ══╝██╔════╝ \e[0m" 
    echo -e "$white ██╔██╗ ██║╚█████╔╝██╔██╗ ██║ ██╔██╗ ██║ █ █║██║ ██║█████╗ ███████╗\e[0m" 
    echo -e "$white ██║╚██╗██║██╔ ══██ ╗██║╚██╗██║ ██║╚██╗██║██║ ██║██║ ██║██╔══╝ ╚════██║\e[ 0m" 
    echo -e "$white ██║ ╚████║╚█████╔╝██║ ╚████║ ██║ ╚████║ ╚██████ ╔╝██████╔╝███████╗███████║\e[0m" 
    echo -e "$white ╚═╝ ╚═══╝ ╚ ════ ╝ ╚═╝ ╚═══╝ ╚═╝ ╚═══╝ ╚═════╝ ╚═════╝ ╚══════ ╝╚══════╝\e[ 0m" 
    echo -e "$white ██████╗ ██████╗ ██████╗ ██╗ ██╗███████╗ ██████╗ █████╗ ███████╗ █████╗ \e[0m"                 
    echo -e "$white ██╔══██╗██╔═══█ █╗ ██ ╔═══██╗██║ ██║██╔════╝██╔══██╗██╔══██╗██╔ ════╝██╔══ ██╗\e[0m"                 
    echo -e "$white ██████╔╝╚██████╔╝ ╚██████╔╝╚█████ █╔╝█ ██████╗██║ ██║ ██║███████║██║ ██║\e[0m"                 
    echo -e "$blank ╚════ ═╝ ╚═ ════╝ ╚══▀▀═╝ ╚═════╝ ╚══════╝╚═╝ ╚═╝ ╚═╝╚══ ════╝╚═╝ ╚═╝ \e[0m"                                                                                                                            
    echo "" 
    echo "" 
} 

quepas_name() { 
    clear 
    echo "" 
    echo -e "$branco ██████╗ ██╗ ██╗███████╗███ ███╗ █████╗ ███████╗ █████╗ \e[0m" 
    echo -e "$white ██╔═══██╗██ ║ ██║ \ e[0m" 
    echo -e "$ blank ██╗███████ ║\e[0m" 
    echo -e "$white ██║▄▄ ██║██║ ██║██╔══╝ ██╔═══╝ ██╔══█ █║╚══ ══██║██╔══██║\e[0m" 
    echo -e "$white ██╗ ██║ ██║ ██║███████║██║ ██║\e[0m" 
    echo -e "$white ╚══▀▀═╝ ╚═══ ══╝ ╚═ ═════╝╚═╝ ╚═╝ ╚═╝╚══════╝╚═╝ ╚═╝\e[0m" 
    echo "" 
    echo "" 
} 

dify_name() { 
    clear 
    echo ""
    echo -e 
    "$white co █" 
    ken ken █ards ║els ╚ards <ai=39> echo -e "$white ██╔══██╗██║██╔══██╗██╔════╝██╔════╝╚ ══██ ╔══╝██║ ██║██╔════╝\e[0m" 
echo -e "$white ██║ ██║██║██████╔╝ ████ █╗ ██║ ██║ ██║ ██║███████╗\e[0m"
    ██║ ██║██║██╔══╝ ╚██╔╝ ██╔══██║██║\e[0m"$ white lada
    Echo -e "$ white lada lada Áarda × ken ***** ard \ sla║ \ and [0m" 
    echo -e "$ white ╚═══ ╚═══ ══╝ ╚═╝╚═╝ ╚═╝╚═╝╚═╝ ╚═╝╚═╝\e[0m" 
    echo "" 
    echo "" 
} 

## Title Ollama 

ollama_name() { 
    clear 
    echo "" 
    echo - and "$white co 
    ██ ╔═══██╗██║ ██║ ██╔══██╗████╗ ████║██╔══██╗\e [0m" 
    echo -e "$blank ██║ ██║██║ ██║ [0m" 
    echo -e "$blank ██║ ██║██║ ██║ ██╔══██║██║╚██╔╝██║██╔══██║\e [0m" 


    echo -e "$blank █████╗ ███████╗███████╗██╗███╗ ██╗███████╗ \e[0m" 
    echo -e "$ white ██╔══██╗██╔════╝██╔════╝██║████╗ ══╝\e[0m" 
    echo -e "$white ███████║█████╗ █████╗ ██║██╔██╗ ██║█████ ╗ \e[0m" 
    echo - and "$white ██╔══██║██╔══╝ ██╔══╝ ██║██║╚██╗██║██╔══ ╝ \e[0m" 
    echo - and "$white 
    ═╝ ╚═╝╚═╝ ╚═╝ ╚═╝╚═╝ ╚═══╝╚══════╝\e[0m" 
    echo "" 
    echo "" 
} 

docuse_name(){ 
    clear 
    echo "" 
    echo - and "$white ██████╗ ██████╗ ██████╗██╗ ████╗ ███ ██╗ ██╗ \e[0m" 
    echo -e "$white ██╔══██╗██╔═══██╗██╔════╝██║ █ █║██ ╔════╝██╔════╝██╔══██╗██║ \e[0m" 
    echo -e "$white ██║ ██║██║ █ █║██ ║ ██║ ██║███████╗█████╗ ███████║██║ \e[0m" 
    echo -e "$white ██║ ██║█ █║ ██║██║ ██║ ██║╚════██║██╔══█ e[0m" 
    echo -e "$blank ██████╔╝╚██████╔╝╚██████╗╚██████╔╝██████ █║███████╗ ██║ ██║███████╗\e[0m" 
    echo -e "$white ╚═════╝ ╚═════╝ ╚═════╝ ╚═══ ══╝ ╚══════╝╚══════╝╚═╝ ╚═╝╚══════╝ \ and [0m " 
    echo" " 
    echo" " 
} 

name_directus () { 
Clear 
echo "" 
echo -e "$white ██████╗ ██╗██████╗ ███████╗ ██████╗████ ████╗ ██╗ ██╗███████╗\e[0m" 
echo -e "$white ██╔══██╗██║██╔══██╗██ ╔═══ ═╝██╔════╝╚══██╔══╝██║██║██╔════╝\e[0m" 
echo -e "$white ██║ ██║██║██╔══██╗██╔══╝ █ █║ ██ ║ ██║ ██║╚════██║\e[0m" 
echo -e "$white ██████╔╝██║██║ ██║███ ████ ╗╚██████╗ ██║ ╚██████╔╝███████║\e[0m"
echo -e "$white ╚═════╝ ╚═╝╚═╝ ╚═╝╚══════╝ ╚═════╝ ╚═╝ ╚═ ════╝ ╚══ ════╝\e[0m" 
echo "" 
echo "" 
} 

vault_name() { 
    clear 
    echo "" 
    echo -e "$white ██║ ██║██╔══██╗██║ ██ ║██║ ╚══██╔══╝██║ ██╗██╔════ ╝████╗ ██║\e[0m" 
    echo -e "$white ██║ ██║███████║██║ ██║██║ ██ ║ ██║ █ ╗ ██║███████║██████╔╝██║ ██║█████╗ ██╔██╗ █ █║\e[0m" 
    echo -e " $white ╚██╗ ██╔╝██╔══██║██║ ██║██║ ██║ ██║███╗██║ ██╔══██║██ ╔══██╗██║ ██║██╔══╝ ██║╚██╗██║\e[0m" 
    echo -e "$white ╚████╔╝ ██║ █ █║╚██████╔╝███████╗██║ ╚███╔███╔╝██║ ║ ██║██████ ╔╝███████╗██║ ╚████║\e[0m" 
    echo -e "$white ╚═══╝ ╚═╝ ╚═╝ ╚═══ ══╝ ╚═ ═════╝╚═╝ ╚══╝╚══╝ ╚═╝ ╚═╝╚═╝ ╚═╝╚═════╝ ╚══ ════╝╚═╝ ╚══ ═╝\e[0m" 
    echo "" 
    echo "" 
} 

monitor_name() { 
    clear 
    echo "" 
    echo -e "$white ██████╗ ██████╗ █████╗ ██ █████╗ █████╗ ███╗ ██╗ █████╗ \e[0m" 
    echo -e "$white ██╔════╝ █ █╔══█ █╗██╔══██╗██╔════╝██╔══██╗████╗ ██║██╔══█ █╗\e[0m" 
    echo -e "$white ██║ ███╗██████╔╝███████║█████╗ ███████║█ █╔██╗ ██║█ ██████║\e[0m" 
    echo -e "$white ██║ ██║██╔══██╗██╔══██║██╔══╝ ██╔═ 
    █ █║██ ║ ██║██║ ██║ ██║██║ ╚████║██║ ██║\e[0m" 
    echo -e "$blank ╚═════ ╝ ╚═╝ ╚ ═╝╚═╝ ╚═╝╚═╝ ╚═╝ ╚═╝╚═╝ ╚═╝ \ and [0m " 
    echo" " 
    echo" " 
} 

name_nextcloud () { 
    Clear 
    Echo" " 
    echo -e "$white ███╗ ██╗███████╗██╗ ██╗████████╗ ██╗ ███ ███╗ ██╗ ██╗██████╗ \e[0m" 
    echo -e "$white ████╗ ██║██╔════╝╚█ █╗██ ╔╝╚══██╔══╝██╔════╝██║ ██╔═══██╗██║ ██║██╔ ══██╗\e[0m" 
    echo -e "$white ██╔██╗ ██║█████╗ ╚███╔╝ ██║ ██║ ██║ ██║ ██║ ██║██ ║ ██║\e[0m" 
    echo -e "$white ██║╚██╗██║██╔══╝ ██╔██╗ ██║ ██║ ██ ║ ██║ █ █║██║ ██║██║ ██║\e[0m" 
    echo -e "$white ██║ ╚████║███████╗██╔╝ ██╗ █ █║ ╚██████╗███████╗╚██████╔╝╚██████╔╝███ ███╔╝\e[0m" 
    echo -e "$white ╚═╝ ╚═══╝╚══════╝╚═╝ ╚═╝ ╚═╝ ╚═════╝╚════ ══╝ ╚════ ═╝ ╚═════╝ ╚═════╝ \e[0m" 
    echo "" 
    echo "" <ai=38> } 
exit_name() { 
    clear 
    echo -e "$white ███████╗ █████╗ ██╗███╗ ██╗██████╗ █ ██ ███╗ ██████╗ ██████╗ \e[0m"
 
    echo "" 
    echo -e "$white ██╔════╝██╔══██╗██║████╗ ██║ ██╔═ ═██╗██╔═══██╗ ██╔══██╗██╔═══██╗\e[0m" 
    echo -e "$white █████ ██╗█ ██████║██║██╔██╗ ██║██║ ██║██║ ██║ ██║ ║ ██║\e[0m" 
    echo - and "$white ╚════██║██╔══██║██║██║╚██╗██║██║ ██║██║ ██║ ██║ ██ ║██║ ██║\e[0m" 
    echo -e "$white ╚══════╝╚═╝ ╚═╝╚═╝╚═╝ ╚═══╝╚══ ═══╝ ╚═════╝ ╚═════╝ ╚═════╝ \e[0m" 
    echo -e "$white ███████╗██████ █╗██ ██████╗██╗ ██╗██████╗ \e[0m" 
    echo -e "$white ██╔════╝██╔════ ╝╚══ ██╔══╝██║ ██║██╔══██╗ \e[0m" 
    echo -e "$white ███████╗█████╗ █ █║ ██ ║ ██║██████╔╝ \e[0m" 
    echo -e "$white ╚════██║██╔══╝ ██║ ██║ ██ ║██╔═ ══╝ \e[0m"        
    echo -e "$white ███████║███████╗ ██║ ╚██████╔╝██║ m" 
    echo -e "$white ╚══════╝╚══════╝ ╚═╝ ╚═════╝ ╚═╝ \e[0m" 
    echo "" 
    echo "" 
} 



# == =================================================== ========================================================== 
## Title Remove Stack [] 

remove_stack_name() { 
    clear 
    echo -e "$yellow================================================ =================================================== ==============\e[0m" 
    echo "" 
    echo "" 
    echo -e "$white ██████╗ ███████╗███╗ ███╗ ██████╗ ██╗ ██╗███████╗██████╗ \e[0m" 
    echo -e "$white ██╔ ══██ ╗██╔════╝████╗ ████║██╔═══██╗██║ ██║██╔═══ ═╝██╔══██╗ \e[0m" 
    echo -e "$white ██████╔╝█████╗ ██╔████╔██║██║ ██║██║ █ █║██ ███╗ ██████╔╝\e[0m" 
    echo -e "$white ██╔══██╗██╔══╝ ██║╚██╔╝█ █║██ ║ ██║╚██╗ ██╔╝██╔══╝ ██╔══██╗\e[0m" 
    echo -e "$white ██║ ██║██ █████ ╗██║ ╚═╝ ██║╚██████╔╝ ╚████╔╝ ███████╗██║ ║\e[0m" 
    echo -e "$ white ╚═╝ ╚═╝╚══════╝╚═╝ ╚═╝ ╚═════╝ ╚═══╝ ╚═════ ═╝╚═╝ ╚═╝\e[ 0m" 
    echo -e "$white \e[0m" 
    echo -e "$white ███████╗████████╗ █████╗ ██████╗█ █╗ ██╗\e[0m" 
    echo -e "$white ██╔════╝╚══██╔══╝██╔══██╗██╔════╝██║ ██╔ ╝ \e[0m"
    echo -e "$white ███████╗ ██║ ███████║██║ █████╔╝ \e[0m"${white}Formbricks${reset}" 
    echo -e "${yellow}[ 1 ]${reset} - ${white}Traefik & Portainer ${green}| ${reset} ${yellow}[ 22 ]${reset} - ${white}NocoDB${reset}"\e[0m" 
    echo -e "$white ╚════██║ ██║ ██╔══██║██║ ██╔═██╗ \e[0m"
    echo -e "$white ███████║ ██║ ██║ ██║╚██████╗██║ ██╗ \e[0m" 
    echo -e "$white ╚ ═ ═════╝ ╚═╝ ╚═╝ ╚═╝ ╚═════╝╚═╝ ╚═╝ \e[0m" 
    echo "" 
    echo -e "$yellow======== =================================================== ==========================================\e[0m" 


    echo -e " $white ╚═╝ ╚═╝ ╚═╝ ╚═════╝ ╚═════╝╚═╝ ╚═╝╚═╝ ╚═╝ ╚═ ═════╝ ╚════ ═╝ ╚═════╝ ╚═════╝ ╚══════╝\e[0m" 
    echo -e "$white ██████╗ ███ ███╗ █ █████╗██╗ ██╗ █████╗ ████████╗██╗ ██╗ ██████ ╗ ██████╗ ███ █████╗ \e[0m" 
    echo -e "$white ██╔══██╗██╔═══██╗ ██╔════╝██║ █ █║██ ╔══██╗╚══██╔══╝██║ ██║██╔═══██╗██╔═══██╗╚ ══██╔══╝ \e [0m" 
    echo -e "$white ██║ ██║██║ ██║ ██║ ███████║███████║ ██║ █║ █╗ ██ ║██║ ██║██║ ██║ ██║ \e[0m" 
    echo -e "$white ██║ ██║██║ ██║ ██║ ██ ╔══██║ ██╔══██║ ██║ ██║███╗██║██║ ██║███║ ██║ \e[0m" 
    echo "$white ███ ███╔╝╚██████╔╝ ╚██████╗██║ ██║██║ ██║ ██║ ██╔███╔╝╚██ ████╔╝╚██████╔╝ ██║ \e[0m" 
    echo -e "$white ╚═════╝ ╚═════╝ ╚══ ═══╝ ╚═╝ ╚═╝╚═╝ ╚═╝ ╚═╝ ╚══╝╚══╝ ╚═════╝ ╚═════╝ ╚ ═╝ \e[0m" 
    echo "" 
    echo " " 
} 

finished_name() { 
    clear 
    echo "" 
    echo -e "$white ███████╗██╗███╗ ██╗ █████╗ ██╗ ██╗██ ██ ███╗ █████╗ ██████╗ ██████╗ \e[0m" 
    echo -e "$white ██╔════╝██║ ████ ╗ ██║██╔══██╗██║ █╗██╔═══██ ╗\e[0m" 
    echo -e "$white █████╗ ██║██╔██╗ ██║███████║██║ ██║ █ ██╔╝ █ ██████║██║ ██║██║ ██║\e[0m" 
    echo -e "$white ██╔══╝ ██║██║╚██╗ ██║█ █╔══██║██║ ██║ ███╔╝ ██╔══██║██║ ██║██║ 0m" 
    echo -e "$white █ █║ ██║██║ ╚████║██║ ██║███████╗██║███████╗ ██║ ██║█████ █╔╝╚██████╔╝\e[0m" 
    echo -e "$white ╚═╝ ╚═╝╚═╝ ╚═══╝╚═╝ ╚═╝╚══ ════ ╝╚═╝╚══════╝╚═╝ ╚═╝╚═════╝ ╚═════╝ \e[0m" 
    echo "" 
    echo "" 
} 

###### ############################################## 

Options menu 

menu_installer(){ 
    echo "" 
    echo -e "${yellow}[ 0 ]${reset} - ${white}Test SMTP ${green}| ${reset} ${yellow}[ 21 ]${reset} - ${white}Formbricks${reset}"
    echo -e "${yellow}[ 2 ]${reset} - ${white}Chatwoot ${green}| ${reset} ${yellow}[ 23 ]${reset} - ${white}Langfuse${reset }" 
    echo -e "${white} '-->${yellow}[ 2.1 ]${reset} - ${white}Chatwoot (ARM) ${green}| ${reset} ${yellow}[ 24 ] ${reset} - ${white}Metabase${reset}" 
    echo -e "${white} '-->${yellow}[ 3.1 ]${reset} - ${white}Evolution API (ARM) ${ green}| ${reset} ${yellow}[ 26 ]${reset} - ${white}Chatwoot Nestor (ft. Francis)${reset}" 
    echo -e "${yellow}[ 4 ]${reset} - ${white}MinIO ${green}| ${reset} ${yellow}[ 27 ]${reset} - ${white}Uno API${reset}" 
    echo -e "${yellow}[ 5 ]$ {reset} - ${white}Typebot ${green}| ${reset} ${yellow}[ 28 ]${reset} - ${white}N8N + Nodes Quepasa${reset}" 
    echo -e "${yellow }[ 6 ]${reset} - ${white}N8N ${green}| ${reset} ${yellow}[ 29 ]${reset} - ${white}Quepasa API${reset}" 
    echo -e " ${yellow}[ 7 ]${reset} - ${white}Flowise ${green}| ${reset} ${yellow}[ 30 ]${reset} - ${white}Docuseal${reset}" 
    echo - and "${yellow}[ 8 ]${reset} - ${white}PgAdmin 4 ${green}| ${reset} ${yellow}[ 31 ]${reset} - ${white}Grafana + Prometheus + cAdvisor${reset}" 
    echo -e "${yellow}[ 9 ]${reset} - ${white} Nocobase ${green}| ${reset} ${yellow}[ 32 ]${reset} - ${white}Dify AI${reset}" 
    echo -e "${yellow}[ 10 ]${reset} - ${white}Botpress ${ green}| ${reset} ${yellow}[ 33 ]${reset} - ${white}Ollama${reset}" 
    echo -e "${yellow}[ 11 ]${reset} - ${white}Wordpress ${green }| ${reset} ${yellow}[ 34 ]${reset} - ${white}Affine${reset}" 
    echo -e "${yellow}[ 12 ]${reset} - ${white}Baserow ${green }| ${reset} ${yellow}[ 35 ]${reset} - ${white}Directus${reset}" 
    echo -e "${yellow}[ 13 ]${reset} - ${white}MongoDB ${green }| ${reset} ${yellow}[ 36 ]${reset} - ${white}VaultWarden${reset}" 
    echo -e "${yellow}[ 14 ]${reset} - ${white}RabbitMQ ${green }| ${reset} ${yellow}[ 37 ]${reset} - ${white}NextCloud${reset}" 
    echo -e "${yellow}[ 15 ]${reset} - ${white}Uptime Kuma ${ green}| ${reset} ${yellow}[ 38 ]${reset} - ${white}Strapi ${yellow}[IMPLEMENTING]${reset}" 
    echo -e "${yellow}[ 16 ]${reset} - $ {white}Cal.with ${green}| ${reset} ${yellow}[ 39 ]${reset} - ${white}REMOVE STACK${reset}" 
    echo -e "${yellow}[ 17 ]${reset} - $ {white}Mautic ${green}| ${reset} ${yellow}[ 40 ]${reset} - ${white}Exit installer${reset}" 
    echo -e "${yellow}[ 18 ]${reset} - ${white}Appsmith $ {green}| ${reset}" # ${yellow}[ 31 ]${reset} - ${white}Still Empty${reset}" 
    echo -e "${yellow}[ 19 ]${reset} - ${white}Qdrant ${green}| ${reset}" # ${yellow}[ 32 ]${reset} - ${ white}Still Empty${reset}" 
    echo -e "${yellow}[ 20 ]${reset} - ${white}Woofed CRM ${green}| ${reset}" # ${yellow}[ 33 ]${reset} - ${white}Still Empty${reset}" 
    echo"" 
} 

################# ################################## 

## Checkers 


## Check if there is Docker, Portainer and Traefik on the VPS 
verify_docker_e_portainer_traefik() { 
    ## Check if Docker is installed 
    if ! command -v docker &> /dev/null; then 
        clear 
        error_msg 
        echo -e "Oops, it looks like you didn't install the option \e[32m[1] Traefik e Portainer${reset} ${white}from our installer.${reset}" 
        echo "Install before trying to install this application." 

        echo "" 
        echo "Returning to the menu in 5 seconds." 
        sleep 5 

        menu_name 
        installer_menu 

        return 1 
    fi 

    ## Check if Portainer is installed 
    if ! docker ps -a --format "{{.Names}}" | grep -q "portainer"; then 
        clear 
        error_msg 
        echo -e "Oops, it looks like you didn't install the option \e[32m[1] Traefik e Portainer${reset} ${white}from our installer.${reset}" 
        echo "Install before trying to install this application." 

        echo "" 
        echo "Returning to the menu in 5 seconds." 
        sleep 5 

        menu_name 
        installer_menu 

        return 1 
    fi 

    ## Check if Traefik is installed 
    if ! docker ps -a --format "{{.Names}}" | grep -q "traefik"; then 
        clear 
        error_msg 
        echo -e "Oops, it looks like you didn't install the option \e[32m[1] Traefik e Portainer${reset} ${white}from our installer.${reset}" 
        echo "Install before trying to install this application." 

        echo "" 
        echo "Returning to the menu in 5 seconds." 
        sleep 5 

        menu_name 
        installer_menu 

        return 1 
    fi 

    return 0 
} 

## Checks if Minio exists 
check_before_if_has_minio() { 

    ## Checks if Portainer is installed 
    if ! docker ps -a --format "{{.Names}}" | grep -q "minio"; then 
        clear 
        echo -e "Oops, it looks like you didn't install the option \e[32m[ 4 ] - MinIO${reset} ${white} from our installer .${reset}" 
        echo "Install before trying to install this application." 

        echo "" 
        echo "Returning to menu in 5 seconds." 
        sleep 5 

        menu_name 
        installer_menu 

        return 1 
    fi 

    return 0 















        echo -e "Oops, it looks like you didn't install the option \e[32m[ 2 ] - Chatwoot${reset} or \e[32m[ 26 ] - Chatwoot Nestor ( ft. Francis) ${white}from our installer.${reset}" 
        echo "Install before trying to install this application." 

        echo "" 
        echo "Returning to menu in 5 seconds." 
        sleep 5 

        menu_name 
        installer_menu 

        return 1 
    fi 

    return 0 

## Checks if Minio and Qdrant exists 
check_before_if_has_minio_e_qdrant() { 
    ## Checks if Minio is installed 
    if ! docker ps -a --format "{{.Names}}" | grep -q "minio"; then 
        clear 
        error_msg 
        echo -e "Oops, it looks like you didn't install the option \e[32m[ 4 ] - MinIO${reset} ${branco}do nos Instalador.${reset}" 
        echo "Install before trying to install this application." 

        echo "" 
        echo "Returning to menu in 5 seconds." 
        sleep 5 

        menu_name 
        installer_menu 

        return 1 
    fi 

    ## Checks if rabbitmq is installed 
    if ! docker ps -a --format "{{.Names}}" | grep -q "qdrant"; then 
        clear 
        error_msg 
        echo -e "Oops, it looks like you didn't install the option \e[32m[ 19 ] - Qdrant${reset} ${white}from our installer.${reset}" 
        echo "Install before trying to install this application." 

        echo "" 
        echo "Returning to menu in 5 seconds." 
        sleep 5 

        menu_name 
        installer_menu 

        return 1 
    fi 

    return 0 
} 

## Check Postgres Container 

check_container_postgres() { 
    if docker ps -q --filter "name=postgres_postgres" | grep -q .; then 
        return 0 
    else 
        return 1 
    fi 
} 

## Check Mysql Container 

check_container_mysql() { 


    if docker ps -q --filter "name=mysql" | grep -q.; then 
        return 0 
    else 
        return 1 
    fi 
}
 
## Check Redis Container 

verify_container_redis() { 
    if docker ps -q --filter "name=redis" | grep -q.; then 
        return 0 
    else 
        return 1 
    fi 
} 

## Check Minio Container 

check_container_minio() { 





        sleep 5 
    done 
} 

## Check if Traefik is online 

wait_30_sec() { 
    sleep 30 
} 

wait_traefik() { 
    echo "This process may take a while if after 5 minutes cancel... why did it go bad..." 
    while true; do 
    # Check if the trarik service is active 
    if docker service ls --filter "name=traefik" | grep "1/1"; then 
        sleep 10 
        break 
    fi 

    sleep 5 
done 
} 

wait_portainer() { 
    echo "This process may take a while, if it takes more than 5 minutes, cancel it... why did it go bad..." 
while true; do 
    # Check if the portainer service is active 
    if docker service ls --filter "name=portainer" | grep "1/1"; then 
        sleep 10 
        break 
    fi 

    sleep 5 
done 
} 

wait_chatroot() { 
    echo "This process may take a while, if it takes more than 5 minutes, cancel it... why did it go bad..." 
while true; do 
    # Check if the chatwoot service is active 
    if docker service ls --format '{{.Name}} {{.Replicas}}' | awk '$1 ~ /chatwoot_chatroot/ && $2 == "1/1"'; then 
        sleep 10 
        break 
    fi 

    sleep 5 
done 
} 

wait_chatroot_arm() { 
    echo "This process may take a while, if it takes more than 5 minutes, cancel it... why did it go bad..." 
while true; do 
    # Check if the chatwoot service is active 
    if docker service ls --filter "name=chatwoot_arm" | grep "1/1"; then 
        sleep 10 
        break 
    fi 

    sleep 5 
done 
} 

wait_chatroot_uno() { 
    echo "This process may take a while, if it takes more than 5 minutes, cancel it... why did it go bad..." 
while true; do 
    # Check if the chatwoot service is active 
    if docker service ls --filter "name=chatwoot_uno" | grep "1/1"; then 
        sleep 10 
        break 
    fi 

    sleep 5 
done 
} 

wait_chatwoot_nestor() { 
    echo "This process It may take a while, if it takes more than 5 minutes, cancel... because it went bad..." 
while true; do 
    # Check if the chatwoot service is active
    if docker service ls --filter "name=chatroot_nestor" | grep "1/1"; then 
        sleep 10 
        break 
    fi 

    sleep 5 
done 
} 


wait_evolution() { 
    echo "This process may take a while, if it takes more than 5 minutes, cancel it... because it went bad..." 
while true; do 
    # Check if the chatwoot service is active if 
    docker service ls --filter "name=evolution" | grep "1/1"; then 
        sleep 10 
        break 
    fi 

    sleep 5 
done 
} 

wait_typebot() { 
    echo "This process may take a while, if it takes more than 5 minutes, cancel it... why did it go bad..." 
while true; do 
    # Check if the chatwoot service is active 
    if docker service ls --filter "name=typebot" | grep "1/1"; then 
        sleep 10 
        break 
    fi 

    sleep 5 
done 
} 

wait_minio() { 
    echo "This process may take a while, if it takes more than 5 minutes, cancel it... why did it go bad..." 
while true; do 
    # Check if the chatwoot service is active 
    if docker service ls --filter "name=minio" | grep "1/1"; then 
        sleep 10 
        break 
    fi 

    sleep 5 
done 
} 

wait_n8n() { 
    echo "This process may take a while, if it takes more than 5 minutes, cancel it... because it went bad..." 
while true; do 
    # Check if the chatwoot service is active 
    if docker service ls --filter "name=n8n" | grep "1/1"; then 
        sleep 10 
        break 
    fi 

    sleep 5 
done 
} 

wait_n8n_quepasa() { 
    echo "This process may take a while, if it takes more than 5 minutes, cancel... why did it go bad..." 
while true; do 
    # Check if the chatwoot service is active 
    if docker service ls --filter "name=n8n_quepasa" | grep "1/1"; then 
        sleep 10 
        break 
    fi 

    sleep 5 
done 
} 

wait_flowise() { 
    echo "This process may take a while, if it takes more than 5 minutes, cancel it... because it went bad..." 
while true; do 
    # Check if the chatwoot service is active 
    if docker service ls --filter "name=flowise" | grep "1/1"; then 
        sleep 10 
        break 
    fi 

    sleep 5 
done 
}
 
wait_pgadmin_4() {
    echo "This process may take a while, if it takes more than 10 minutes, cancel... because it went bad..." 
while true; do 
    # Check if the chatwoot service is active 
    if docker service ls --filter "name=pgadmin" | grep "1/1"; then 
        sleep 10 
        break 
    fi 

    sleep 5 










} 

wait_rabbitmq() { 
    echo "This process may take a while, if it takes more than 5 minutes, cancel it... why did it go bad..." 
while true; do 
    # Check if the chatwoot service is active 
    if docker service ls --filter "name=rabbit" | grep "1/1"; then 
        sleep 10 
        break 
    fi 

    sleep 5 
done 
} 

wait_uptimekuma() { 
    echo "This process may take a while, if it takes more than 5 minutes, cancel it... why did it go bad..." 
while true; do 
    # Check if the chatwoot service is active 
    if docker service ls --filter "name=uptime" | grep "1/1"; then 
        sleep 10 
        break 
    fi 

    sleep 5 
done 
} 

wait_calcom() { 
    echo "This process may take a while, if it takes more than 10 minutes, cancel it... because it went bad..." 
while true; do 
    # Check if the chatwoot service is active 
    if docker service ls --filter "name=calcom" | grep "1/1"; then 
        sleep 10 
        break 
    fi 

    sleep 5 
done 
} 

wait_mautic() { 
    echo "This process may take a while, if it takes more than 5 minutes, cancel it... why did it go bad..." 
while true; do 
    # Check if the chatwoot service is active 
    if docker service ls --filter "name=mautic" | grep "1/1"; then 
        sleep 10 
        break 
    fi 

    sleep 5 
done 
} 

wait_appsmith() { 
    echo "This process may take a while, if it takes more than 5 minutes, cancel it... why did it go bad..." 
while true; do 
    # Check if the chatwoot service is active 
    if docker service ls --filter "name=appsmith" | grep "1/1"; then 
        sleep 10 
        break 
    fi 

    sleep 5 
done 
} 

wait_qdrant() { 
    echo "This process may take a while, if it takes more than 5 minutes, cancel it... because it went bad..." 
while true; do 
    # Check if the chatwoot service is active 
    if docker service ls --filter "name=qdrant" | grep "1/1"; then 
        sleep 10 
        break
    fi 

    sleep 5 
done 
} 

wait_woofedcrm() { 
    echo "This process may take a while, if it takes more than 5 minutes, cancel it... why did it go bad..." 
while true; do 
    # Check if the chatwoot service is active 
    if docker service ls --filter "name=woofedcrm_woofedcrm" | grep "1/1"; then 
        sleep 10 
        break 
    fi 

    sleep 5 
done 
} 

wait_formbricks() { 
    echo "This process may take a while, if it takes more than 5 minutes, cancel it... why did it go bad..." 
while true; do 
    # Check if the chatwoot service is active 
    if docker service ls --filter "name=formbricks" | grep "1/1"; then 
        sleep 10 
        break 
    fi 

    sleep 5 
done 
} 

wait_nocodb() { 
    echo "This process may take a while, if it takes more than 5 minutes, cancel it... why did it go bad..." 
while true; do 
    # Check if the chatwoot service is active 
    if docker service ls --filter "name=nocobase" | grep "1/1"; then 
        sleep 10 
        break 
    fi 

    sleep 5 
done 
} 

wait_langfuse() { 
    echo "This process may take a while, if it takes more than 5 minutes, cancel it... why did it go bad..." 
while true; do 
    # Check if the chatwoot service is active 
    if docker service ls --filter "name=langfuse" | grep "1/1"; then 
        sleep 10 
        break 
    fi 

    sleep 5 
done 
} 

wait_metabase() { 
    echo "This process may take a while, if it takes more than 5 minutes, cancel it... why did it go bad..." 
while true; do 
    # Check if the chatwoot service is active 
    if docker service ls --filter "name=metabase" | grep "1/1"; then 
        sleep 10 
        break 
    fi 

    sleep 5 
done 
} 

wait_odoo() { 
    echo "This process may take a while, if it takes more than 5 minutes, cancel it... why did it go bad..." 
while true; do 
    # Check if the chatwoot service is active 
    if docker service ls --filter "name=odoo" | grep "1/1"; then 
        sleep 10 
        break 
    fi 

    sleep 5 
done 
} 

wait_unoapi(){ 
    echo "This process may take a while,If it takes more than 5 minutes, cancel... because it went bad..." 
    while true; do
        # Check if the chatwoot service is active 
        if docker service ls --filter "name=unoapi_unoapi" | grep "1/1"; then 
            sleep 10 
            break 
        fi 
    
        sleep 5 
    done 
} 

wait_quepasa(){ 
    echo "This process may take a while, if it takes more than 5 minutes, cancel it... because it went bad..." 
    while true; do 
        # Check if the chatwoot service is active 
        if docker service ls --filter "name=quepasa" | grep "1/1"; then 
            sleep 10 
            break 
        fi 
    
        sleep 5 
    done 
} 

wait_dify(){ 
    echo "This process may take a while, if it takes more than 5 minutes, cancel it... because it went bad..." 
    while true; do 
        # Check if the chatwoot service is active 
        if docker service ls --filter "name=dify" | grep "1/1"; then 
            sleep 10 
            break 
        fi 
    
        sleep 5 
    done 
} 

wait_ollama(){ 
    echo "This process may take a while, if it takes more than 5 minutes, cancel it... because it went bad..." 
    while true; do 
        # Check if the chatwoot service is active 
        if docker service ls --filter "name=ollama" | grep "1/1"; then 
            sleep 10 
            break 
        fi 
    
        sleep 5 
    done 
} 

wait_affine(){ 
    echo "This process may take a while, if it takes more than 5 minutes, cancel it... because it went bad..." 
    while true; do 
        # Check if the chatwoot service is active 
        if docker service ls --filter "name=affine" | grep "1/1"; then 
            sleep 10 
            break 
        fi 
    
        sleep 5 
    done 
} 

wait_docuseal(){ 
    echo "This process may take a while, if it takes more than 5 minutes, cancel it... because it went bad..." 
    while true; do 
        # Check if the chatwoot service is active 
        if docker service ls --filter "name=docuseal" | grep "1/1"; then 
            sleep 10 
            break 
        fi 
    
        sleep 5 
    done 
} 

wait_directus(){ 
    echo "This process may take a while, if it takes more than 5 minutes, cancel it... because it went bad..." 
    while true; do 
        # Checks if the chatwoot service is active
        if docker service ls --filter "name=directus" | grep "1/1"; then 
            sleep 10 
            break 
        fi 
    
        sleep 5 
    done 
} 

wait_vaultwarden(){ 
    echo "This process may take a while, if it takes more than 10 minutes, cancel it... because it went bad..." 
    while true; do 
        # Check if the chatwoot service is active 
        if docker service ls --filter "name=vaultwarden" | grep "1/1"; then 
            sleep 30 
            break 
        fi 
    
        sleep 5 
    done 
} 

wait_monitor(){ 
    echo "This process may take a while, if it takes more than 5 minutes, cancel it... because it went bad..." 
    while true; do 
        # Check if the chatwoot service is active 
        if docker service ls --filter "name=monitor" | grep "1/1"; then 
            sleep 10 
            break 
        fi 
    
        sleep 5 
    done 
} 

wait_nextcloud(){ 
    echo "This process may take a while, if it takes more than 5 minutes, cancel it... why did it go bad..." 
    while true; do 
        # Check if the chatwoot service is active 
        if docker service ls --filter "name=nextcloud" | grep "1/1"; then 
            sleep 10 
            break 
        fi 
    
        sleep 5 
    done 
} 
####################################### ########### 

## Get information 


## Get Postgres password 

get_password_postgres() { 
    while :; do 
        if [ -f /root/postgres.yaml ]; then 
            postgres_password=$(grep "POSTGRES_PASSWORD" /root/postgres.yaml | awk -F '=' '{print $2}') 
            break 
        else 
            sleep 5 
        fi 
    done 
} 

get_user_password_rabbitmq() { 
    while :; do 
        if [ -f /root/rabbitmq.yaml ]; then 
            user_rabbit_mqs=$(grep "RABBITMQ_DEFAULT_USER" /root/rabbitmq.yaml | awk -F ': ' '{print $2}') 
            password_rabbit_mqs=$(grep "RABBITMQ_DEFAULT_PASS" /root/rabbitmq.yaml | awk -F ': ' '{print $2}') 
            break 
        else 
            sleep 5 
            echo "error" 
        fi 
    done 
} 

## Get mysql password 

get_password_mysql() { 
    while :; do 
        if [ -f /root/mysql.yaml ]; then 
            password_mysql=$(grep "MYSQL_ROOT_PASSWORD" /root/mysql.yaml | awk -F '=' '{print $2}') 
            break 
        else 
            sleep 5
        fi 
    done 
} 

## Get Minio password 

get_minio_password() { 
    user_minio=$(grep "MINIO_ROOT_USER" /root/minio.yaml | awk -F '=' '{print $2}') 
    minio_password=$(grep "MINIO_ROOT_PASSWORD" /root /minio.yaml | awk -F '=' '{print $2}') 
    url_minio=$(grep "MINIO_BROWSER_REDIRECT_URL" /root/minio.yaml | awk -F '=' '{print $2}' | sed 's/ https:\/\///') 
    url_s3=$(grep "MINIO_SERVER_URL" /root/minio.yaml | awk -F '=' '{print $2}' | sed 's/https:\/\/// ') 
} 

## Get link S3 

get_link_s3() { 
    url_s3=$(grep "MINIO_SERVER_URL" /root/minio.yaml | awk -F '=' '{print $2}' | sed 's/https:\/\/ //') 
} 

########################################### ####### 

## Postgres database creators 

## Create Chatwoot database 
create_bank_postgres_chatwoot() { 
    while :; do 
        if docker ps -q --filter "name=postgres" | grep -q.; then 
            CONTAINER_ID=$(docker ps -q --filter "name=postgres") 

            # Check if the database already exists 
            docker exec "$CONTAINER_ID" psql -U postgres -lqt | cut -d \| -f 1 | grep -qw "chatroot" 

            if [ $? -eq 0 ]; then 
                echo "The chatwoot database already exists." 

                read -p "Do you want to delete and create a new database? (Y/N): " response 
                if [ "$response" == "Y" ] || [ "$response" == "y" ]; then 
                    # Delete the database 
                    docker exec "$CONTAINER_ID" psql -U postgres -c "DROP DATABASE IF EXISTS chatwoot;" 
                    echo "Chatwoot database deleted successfully." 
                    
                    # Create the database again 
                    docker exec "$CONTAINER_ID" psql -U postgres -c "CREATE DATABASE chatwoot;" 
                    
                    echo "Chatwoot database created successfully." 
                else 
                    echo "Using existing database." 
                fi 
                break 
            else 
                # Create the database 
                docker exec "$CONTAINER_ID" psql -U postgres -c "CREATE DATABASE chatwoot;" 
                
                # Check again if the database was created successfully 
                docker exec "$CONTAINER_ID" psql -U postgres 
                    -lqt | cut -d \| -f 1 | grep -qw "chatwoot" 
 
                if [ $?
                    echo "Chatwoot database created successfully. 
                "
                    echo "Error creating the database. Trying again..." 
                fi 
            fi 
        else 
            sleep 5 
        fi 
    done 
} 

## Create Chatwoot_UNO database 
create_banco_postgres_chatwoot_uno() { 
    while :; do 
        if docker ps -q --filter "name=postgres" | grep -q.; then 
            CONTAINER_ID=$(docker ps -q --filter "name=postgres") 

            # Check if the database already exists 
            docker exec "$CONTAINER_ID" psql -U postgres -lqt | cut -d \| -f 1 | grep -qw "chatwoot_uno" 

            if [ $? -eq 0 ]; then 
                echo "The chatwoot_uno database already exists." 

                read -p "Do you want to delete and create a new database? (Y/N): " response 
                if [ "$response" == "Y" ] || [ "$response" == "y" ]; then 
                    # Delete the database 
                    docker exec "$CONTAINER_ID" psql -U postgres -c "DROP DATABASE IF EXISTS chatwoot_uno;" 
                    echo "Chatwoot_uno database deleted successfully." 
                    
                    # Create the database again 
                    docker exec "$CONTAINER_ID" psql -U postgres -c "CREATE DATABASE chatwoot_uno;" 
                    
                    echo "Chatwoot_uno database created successfully." 
                else 
                    echo "Using existing database." 
                fi 
                break 
            else 
                # Create the database 
                docker exec "$CONTAINER_ID" psql -U postgres -c "CREATE DATABASE chatwoot_uno;" 
                
                # Check again if the database was created successfully 
                docker exec "$CONTAINER_ID" psql -U postgres -lqt | cut -d \| -f 1 | grep -qw "chatwoot_uno" 

                if [ $? -eq 0 ]; then 
                    echo "Chatwoot_uno database created successfully." 
                    break 
                else 
                    echo "Error creating the database. Trying again..." 
                fi 
            fi 
        else 
            sleep 5 
        fi 
    done 
} 

create_banco_postgres_chatwoot_nestor() { 
    while :; do 
        if docker ps -q --filter "name=postgres" | grep -q.; then 
            CONTAINER_ID=$(docker ps -q --filter "name=postgres") 

            # Check if the database already exists
            docker exec "$CONTAINER_ID" psql -U postgres -lqt | cut -d \| -f 1 | grep -qw "chatroot_nestor" 

            if [ $? -eq 0 ]; then 
                echo "The chatwoot_nestor database already exists." 

                read -p "Do you want to delete and create a new database? (Y/N): " response 
                if [ "$response" == "Y" ] || [ "$response" == "y" ]; then 
                    # Delete the database 
                    docker exec "$CONTAINER_ID" psql -U postgres -c "DROP DATABASE IF EXISTS chatwoot_nestor;" 
                    echo "Chatwoot_nestor database deleted successfully." 
                    
                    # Create the database again 
                    docker exec "$CONTAINER_ID" psql -U postgres -c "CREATE DATABASE chatwoot_nestor;" 
                    
                    echo "Chatwoot_nestor database created successfully." 
                else 
                    echo "Using existing database." 
                fi 
                break 
            else 
                # Create the database 
                docker exec "$CONTAINER_ID" psql -U postgres -c "CREATE DATABASE chatwoot_nestor;" 
                
                # Check again if the database was created successfully 
                docker exec "$CONTAINER_ID" psql -U postgres -lqt | cut -d \| -f 1 | grep -qw "chatroot_nestor" 

                if [ $? -eq 0 ]; then 
                    echo "Chatwoot_nestor database created successfully." 
                    break 
                else 
                    echo "Error creating the database. Trying again..." 
                fi 
            fi 
        else 
            sleep 5 
        fi 
    done 
} 

## Create N8N database 
create_banco_postgres_n8n_queue() { 
    while :; do 
        if docker ps -q --filter "name=postgres" | grep -q.; then 
            CONTAINER_ID=$(docker ps -q --filter "name=postgres") 

            # Check if the database already exists 
            docker exec "$CONTAINER_ID" psql -U postgres -lqt | cut -d \| -f 1 | grep -qw "n8n_queue" 

            if [ $? -eq 0 ]; then 
                echo "The n8n_queue database already exists." 

                read -p "Do you want to delete and create a new database? (Y/N):" response 
                if [ "$response" == "Y" ] || [ "$response" == "y" ]; then 
                    # Delete the database
                    docker exec "$CONTAINER_ID" psql -U postgres -c "DROP DATABASE IF EXISTS n8n_queue;" 
                    echo "Database n8n_queue deleted successfully." 
                    
                    # Create the database again 
                    docker exec "$CONTAINER_ID" psql -U postgres -c "CREATE DATABASE n8n_queue;" 
                    
                    echo "Database n8n_queue created successfully." 
                else 
                    echo "Using existing database." 
                fi 
                break 
            else 
                # Create the database 
                docker exec "$CONTAINER_ID" psql -U postgres -c "CREATE DATABASE n8n_queue;" 
                
                # Check again if the database was created successfully 
                docker exec "$CONTAINER_ID" psql -U postgres -lqt | cut -d \| -f 1 | grep -qw "n8n_queue" 

                if [ $? -eq 0 ]; then 
                    echo "Database n8n_queue created successfully." 
                    break 
                else 
                    echo "Error creating the database. Trying again..." 
                fi 
            fi 
        else 
            sleep 5 
        fi 
    done 
} 

## Create N8N_Quepasa database 
create_banco_postgres_n8n_quepasa() { 
    while :; do 
        if docker ps -q --filter "name=postgres" | grep -q.; then 
            CONTAINER_ID=$(docker ps -q --filter "name=postgres") 

            # Check if the database already exists 
            docker exec "$CONTAINER_ID" psql -U postgres -lqt | cut -d \| -f 1 | grep -qw "n8n_quepasa" 

            if [ $? -eq 0 ]; then 
                echo "The n8n_quepasa database already exists." 

                read -p "Do you want to delete and create a new database? (Y/N): " response 
                if [ "$response" == "Y" ] || [ "$response" == "y" ]; then 
                    # Delete the database 
                    docker exec "$CONTAINER_ID" psql -U postgres -c "DROP DATABASE IF EXISTS n8n_quepasa;" 
                    echo "Database n8n_quepasa deleted successfully." 
                    
                    # Create the database again 
                    docker exec "$CONTAINER_ID" psql -U postgres -c "CREATE DATABASE n8n_quepasa;" 
                    
                    echo "Database n8n_quepasa created successfully." 
                else 
                    echo "Using the existing database." 
                fi 
                break 
            else 
                # Create the database
                docker exec "$CONTAINER_ID" psql -U postgres -c "CREATE DATABASE n8n_quepasa;" 
                
                # Check again if the database was created successfully 
                docker exec "$CONTAINER_ID" psql -U postgres -lqt | cut -d \| -f 1 | grep -qw "n8n_quepasa" 

                if [ $? -eq 0 ]; then 
                    echo "Database n8n_quepasa created successfully." 
                    break 
                else 
                    echo "Error creating the database. Trying again..." 
                fi 
            fi 
        else 
            sleep 5 
        fi 
    done 
} 

## Create Typebot database 
create_bank_postgres_typebot() { 
    while :; do 
        if docker ps -q --filter "name=postgres" | grep -q.; then 
            CONTAINER_ID=$(docker ps -q --filter "name=postgres") 

            # Check if the database already exists 
            docker exec "$CONTAINER_ID" psql -U postgres -lqt | cut -d \| -f 1 | grep -qw "typebot" 

            if [ $? -eq 0 ]; then 
                echo "The typebot database already exists." 

                read -p "Do you want to delete and create a new database? (Y/N): " response 
                if [ "$response" == "Y" ] || [ "$response" == "y" ]; then 
                    # Delete the database 
                    docker exec "$CONTAINER_ID" psql -U postgres -c "DROP DATABASE IF EXISTS typebot;" 
                    echo "Typebot database deleted successfully." 
                    
                    # Create the database again 
                    docker exec "$CONTAINER_ID" psql -U postgres -c "CREATE DATABASE typebot;" 
                    
                    echo "Typebot database created successfully." 
                else 
                    echo "Using existing database." 
                fi 
                break 
            else 
                # Create the database 
                docker exec "$CONTAINER_ID" psql -U postgres -c "CREATE DATABASE typebot;" 
                
                # Check again if the database was created successfully 
                docker exec "$CONTAINER_ID" psql -U postgres 
                    -lqt | cut -d \| -f 1 | grep -qw "typebot" 
        if 
                [ 
                    $ 

                ? -eq 
            ] 
                    [ . Trying again..."
                fi 
            fi 
        fi 
    done 
} 

## Create Flowise bank 
create_bank_postgres_flowise() { 
    while :; do 
        if docker ps -q --filter "name=postgres" | grep -q.; then 
            CONTAINER_ID=$(docker ps -q --filter "name=postgres") 

            # Check if the database already exists 
            docker exec "$CONTAINER_ID" psql -U postgres -lqt | cut -d \| -f 1 | grep -qw "flowise" 

            if [ $? -eq 0 ]; then 
                echo "The flowise database already exists." 

                read -p "Do you want to delete and create a new database? (Y/N): " response 
                if [ "$response" == "Y" ] || [ "$response" == "y" ]; then 
                    # Delete the database 
                    docker exec "$CONTAINER_ID" psql -U postgres -c "DROP DATABASE IF EXISTS flowise;" 
                    echo "Flowise database deleted successfully." 
                    
                    # Create the database again 
                    docker exec "$CONTAINER_ID" psql -U postgres -c "CREATE DATABASE flowise;" 
                    
                    echo "Flowise database created successfully." 
                else 
                    echo "Using existing database." 
                fi 
                break 
            else 
                # Create the database 
                docker exec "$CONTAINER_ID" psql -U postgres -c "CREATE DATABASE flowise;" 
                
                # Check again if the database was created successfully 
                docker exec "$CONTAINER_ID" psql -U postgres -lqt | cut -d \| -f 1 | grep -qw "flowise" 

                if [ $? -eq 0 ]; then 
                    echo "Flowise database created successfully." 
                    break 
                else 
                    echo "Error creating the database. Trying again..." 
                fi 
            fi 
        else 
            sleep 5 
        fi 
    done 
} 

## Create Nocobase database 
create_banco_postgres_nocobase() { 
    while :; do 
        if docker ps -q --filter "name=postgres" | grep -q .; then 
            CONTAINER_ID=$(docker ps -q --filter "name=postgres") 

            # Check if the database already exists 
            docker exec "$CONTAINER_ID" psql -U postgres -lqt | cut -d \| -f 1 | grep -qw "nocobase" 

            if [ $? -eq 0 ]; then 
                echo "The nocobase database already exists."

                read -p "Do you want to delete and create a new database? (Y/N): " response 
                if [ "$response" == "Y" ] || [ "$response" == "y" ]; then 
                    # Delete the database 
                    docker exec "$CONTAINER_ID" psql -U postgres -c "DROP DATABASE IF EXISTS nocobase;" 
                    echo "Nocobase database deleted successfully." 
                    
                    # Create the database again 
                    docker exec "$CONTAINER_ID" psql -U postgres -c "CREATE DATABASE nocobase;" 
                    
                    # Grant privileges to user postgres 
                    docker exec "$CONTAINER_ID" psql -U postgres -d nocobase -c "GRANT ALL PRIVILEGES ON DATABASE nocobase TO postgres;" 
                    
                    echo "Nocobase database successfully created and permissions granted." 
                else 
                    echo "Using existing database." 
                fi 
                break 
            else 
                # Create the database 
                docker exec "$CONTAINER_ID" psql -U postgres -c "CREATE DATABASE nocobase;" 
                
                # Grant privileges to user postgres 
                docker exec "$CONTAINER_ID" psql -U postgres -d nocobase -c "GRANT ALL PRIVILEGES ON DATABASE nocobase TO postgres;" 
                
                # Check again if the database was created successfully 
                docker exec "$CONTAINER_ID" psql -U postgres -lqt | cut -d \| -f 1 | grep -qw "nocobase" 

                if [ $? -eq 0 ]; then 
                    echo "Nocobase database successfully created and permissions granted." 
                    break 
                else 
                    echo "Error creating the database. Trying again..." 
                fi 
            fi 
        else 
            sleep 5 
        fi 
    done 
} 

## Create Botpress database 
create_bank_postgres_botpress() { 
    while :; do 
        if docker ps -q --filter "name=postgres" | grep -q .; then 
            CONTAINER_ID=$(docker ps -q --filter "name=postgres") 

            # Check if the database already exists 
            docker exec "$CONTAINER_ID" psql -U postgres -lqt | cut -d \| -f 1 | grep -qw "botpress" 

            if [ $? -eq 0 ]; then 
                echo "The botpress database already exists." 

                read -p "Do you want to delete and create a new database? (Y/N): " response 
                if [ "$response" == "Y" ] || [ "$response" == "y" ]; then 
                    # Delete the database 
                    docker exec "$CONTAINER_ID" psql -U postgres -c "DROP DATABASE IF EXISTS botpress;" 
                    echo "Botpress database deleted successfully." 
                    
                    # Create the database again 
                    docker exec "$CONTAINER_ID" psql -U postgres -c "CREATE DATABASE botpress;" 
                    
                    echo "Botpress database created successfully." 
                else 
                    echo "Using existing database." 
                fi 
                break 
            else 
                # Create the database 
                docker exec "$CONTAINER_ID" psql -U postgres -c "CREATE DATABASE botpress;" 
                
                # Check again if the database was created successfully 
                docker exec "$CONTAINER_ID" psql -U postgres -lqt | cut -d \| -f 1 | grep -qw "botpress" 

                if [ $? -eq 0 ]; then 
                    echo "Botpress database created successfully." 
                    break 
                else 
                    echo "Error creating the database. Trying again..." 
                fi 
            fi 
        else 
            sleep 5 
        fi 
    done 
} 

## Create Calcom database 
create_banco_postgres_calcom() { 
    while :; do 
        if docker ps -q --filter "name=postgres" | grep -q.; then 
            CONTAINER_ID=$(docker ps -q --filter "name=postgres") 

            # Check if the database already exists 
            docker exec "$CONTAINER_ID" psql -U postgres -lqt | cut -d \| -f 1 | grep -qw "calcom" 

            if [ $? -eq 0 ]; then 
                echo "The calcom database already exists." 

                read -p "Do you want to delete and create a new database? (Y/N):" response 
                if [ "$response" == "Y" ] || [ "$response" == "y" ]; then 
                    # Delete the database 
                    docker exec "$CONTAINER_ID" psql -U postgres -c "DROP DATABASE IF EXISTS calcom;" 
                    echo "Calcom database deleted successfully." 
                    
                    # Create the database again 
                    docker exec "$CONTAINER_ID" psql -U postgres -c "CREATE DATABASE calcom;"
                    
                    echo "Calcom database created successfully."  
                else
                    echo "Using existing database." 
                fi 
                break 
            else 
                # Create the database 
                docker exec "$CONTAINER_ID" psql -U postgres -c "CREATE DATABASE calcom;" 
                
                # Check again if the database was created successfully 
                docker exec "$CONTAINER_ID" psql -U postgres -lqt | cut -d \| -f 1 | grep -qw "calcom" 

                if [ $? -eq 0 ]; then 
                    echo "Calcom database created successfully." 
                    break 
                else 
                    echo "Error creating the database. Trying again..." 
                fi 
            fi 
        else 
            sleep 5 
        fi 
    done 
} 

## Create WoofedCRM database 
create_banco_postgres_woofedcrm() { 
    while :; do 
        if docker ps -q --filter "name=postgres" | grep -q.; then 
            CONTAINER_ID=$(docker ps -q --filter "name=postgres") 

            # Check if the database already exists 
            docker exec "$CONTAINER_ID" psql -U postgres -lqt | cut -d \| -f 1 | grep -qw "woofedcrm" 

            if [ $? -eq 0 ]; then 
                echo "The woofedcrm database already exists." 

                read -p "Do you want to delete and create a new database? (Y/N): " response 
                if [ "$response" == "Y" ] || [ "$response" == "y" ]; then 
                    # Delete the database 
                    docker exec "$CONTAINER_ID" psql -U postgres -c "DROP DATABASE IF EXISTS woofedcrm;" 
                    echo "Wofedcrm database deleted successfully." 
                    
                    # Create the database again 
                    docker exec "$CONTAINER_ID" psql -U postgres -c "CREATE DATABASE woofedcrm;" 
                    
                    echo "Woofedcrm database created successfully." 
                else 
                    echo "Using existing database." 
                fi 
                break 
            else 
                # Create the database 
                docker exec "$CONTAINER_ID" psql -U postgres -c "CREATE DATABASE woofedcrm;" 
                
                # Check again if the database was created successfully 
                docker exec "$CONTAINER_ID" psql -U postgres -lqt | cut -d \| -f 1 |

                if [$? -eq 0 ]; then 
    while :; do
                    echo "Woofedcrm database created successfully." 
                    break 
                else 
                    echo "Error creating the database. Trying again..." 
                fi 
            fi 
        else 
            sleep 5 
        fi 
    done 
} 

## Create Formbricks database 
create_banco_postgres_formbricks() { 
    while :; do 
        if docker ps -q --filter "name=postgres" | grep -q.; then 
            CONTAINER_ID=$(docker ps -q --filter "name=postgres") 

            # Check if the database already exists 
            docker exec "$CONTAINER_ID" psql -U postgres -lqt | cut -d \| -f 1 | grep -qw "formbricks" 

            if [ $? -eq 0 ]; then 
                echo "The formbricks database already exists." 

                read -p "Do you want to delete and create a new database? (Y/N): " response 
                if [ "$response" == "Y" ] || [ "$response" == "y" ]; then 
                    # Delete the database 
                    docker exec "$CONTAINER_ID" psql -U postgres -c "DROP DATABASE IF EXISTS formbricks;" 
                    echo "Formbricks database deleted successfully." 
                    
                    # Create the database again 
                    docker exec "$CONTAINER_ID" psql -U postgres -c "CREATE DATABASE formbricks;" 
                    
                    echo "Formbricks database created successfully." 
                else 
                    echo "Using existing database." 
                fi 
                break 
            else 
                # Create the database 
                docker exec "$CONTAINER_ID" psql -U postgres -c "CREATE DATABASE formbricks;" 
                
                # Check again if the database was created successfully 
                docker exec "$CONTAINER_ID" psql -U postgres -lqt | cut -d \| -f 1 | grep -qw "formbricks" 

                if [ $? -eq 0 ]; then 
                    echo "Formbricks database created successfully." 
                    break 
                else 
                    echo "Error creating database. Trying again..." 
                fi 
            fi 
        else 
            sleep 5 
        fi 
    done 
} 


## Create NocoDB database 
create_banco_postgres_nocodb() {
        if docker ps -q --filter "name=postgres" | grep -q.; then 
                if [ "$response" == "Y" ] || [ "$response" == "y" ]; then
            CONTAINER_ID=$(docker ps -q --filter "name=postgres") 

            # Check if the database already exists 
            docker exec "$CONTAINER_ID" psql -U postgres -lqt | cut -d \| -f 1 | grep -qw "nocodb" 

            if [ $? -eq 0 ]; then 
                echo "The nocodb database already exists." 

                read -p "Do you want to delete and create a new database? (Y/N): " response 
                if [ "$response" == "Y" ] || [ "$response" == "y" ]; then 
                    # Delete the database 
                    docker exec "$CONTAINER_ID" psql -U postgres -c "DROP DATABASE IF EXISTS nocodb;" 
                    echo "Nocodb database deleted successfully." 
                    
                    # Create the database again 
                    docker exec "$CONTAINER_ID" psql -U postgres -c "CREATE DATABASE nocodb;" 
                    
                    echo "Nocodb database created successfully." 
                else 
                    echo "Using existing database." 
                fi 
                break 
            else 
                # Create the database 
                docker exec "$CONTAINER_ID" psql -U postgres -c "CREATE DATABASE nocodb;" 
                
                # Check again if the database was created successfully 
                docker exec "$CONTAINER_ID" psql -U postgres -lqt | cut -d \| -f 1 | grep -qw "nocodb" 

                if [ $? -eq 0 ]; then 
                    echo "Nocodb database created successfully." 
                    break 
                else 
                    echo "Error creating the database. Trying again..." 
                fi 
            fi 
        else 
            sleep 5 
        fi 
    done 
} 

## Create Langfuse database 
create_banco_postgres_langfuse() { 
    while :; do 
        if docker ps -q --filter "name=postgres" | grep -q.; then 
            CONTAINER_ID=$(docker ps -q --filter "name=postgres") 

            # Check if the database already exists 
            docker exec "$CONTAINER_ID" psql -U postgres -lqt | cut -d \| -f 1 | grep -qw "langfuse" 

            if [ $? -eq 0 ]; then 
                echo "The langfuse database already exists." 

                read -p "Do you want to delete and create a new database? (Y/N): " response 
                    # Delete database 
                    docker exec "$CONTAINER_ID" psql -U postgres -c "DROP DATABASE IF EXISTS langfuse;" 
                    echo "Nocodb database deleted successfully." 
                    
                    # Create the database again 
                    docker exec "$CONTAINER_ID" psql -U postgres -c "CREATE DATABASE langfuse;" 
                    
                    echo "Langfuse database created successfully." 
                else 
                    echo "Using existing database." 
                fi 
                break 
            else 
                # Create the database 
                docker exec "$CONTAINER_ID" psql -U postgres -c "CREATE DATABASE langfuse;" 
                
                # Check again if the database was created successfully 
                docker exec "$CONTAINER_ID" psql -U postgres -lqt | cut -d \| -f 1 | grep -qw "langfuse" 

                if [ $? -eq 0 ]; then 
                    echo "Langfuse database created successfully." 
                    break 
                else 
                    echo "Error creating the database. Trying again..." 
                fi 
            fi 
        else 
            sleep 5 
        fi 
    done 
} 

## Create Metabase database 
create_banco_postgres_metabase() { 
    while :; do 
        if docker ps -q --filter "name=postgres" | grep -q.; then 
            CONTAINER_ID=$(docker ps -q --filter "name=postgres") 

            # Check if the database already exists 
            docker exec "$CONTAINER_ID" psql -U postgres -lqt | cut -d \| -f 1 | grep -qw "metabase" 

            if [ $? -eq 0 ]; then 
                echo "The metabase database already exists." 

                read -p "Do you want to delete and create a new database? (Y/N): " response 
                if [ "$response" == "Y" ] || [ "$response" == "y" ]; then 
                    # Delete the database 
                    docker exec "$CONTAINER_ID" psql -U postgres -c "DROP DATABASE IF EXISTS metabase;" 
                    echo "Metabase database deleted successfully." 
                    
                    # Create the database again 
                    docker exec "$CONTAINER_ID" psql -U postgres -c "CREATE DATABASE metabase;" 
                    
                    echo "Metabase database created successfully." 
                else 
                    echo "Using existing database." 
                fi 
                break 
            else 
                # Create the database 
                docker exec "$CONTAINER_ID" psql -U postgres -c "CREATE DATABASE metabase;" 
                
                # Check again if the database was created successfully 
                docker exec "$CONTAINER_ID" psql -U postgres -lqt | cut -d \| -f 1 | grep -qw "metabase" 

                if [ $? -eq 0 ]; then 
                    echo "Metabase database created successfully." 
                    break 
                else 
                    echo "Error creating the database. Trying again..." 
                fi 
            fi 
        else 
            sleep 5 
        fi 
    done 
} 

create_banco_postgres_dify() { 
    while :; do 
        if docker ps -q --filter "name=postgres" | grep -q.; then 
            CONTAINER_ID=$(docker ps -q --filter "name=postgres") 

            # Check if the database already exists 
            docker exec "$CONTAINER_ID" psql -U postgres -lqt | cut -d \| -f 1 | grep -qw "dify" 

            if [ $? -eq 0 ]; then 
                echo "The dify database already exists." 

                read -p "Do you want to delete and create a new database? (Y/N): " response 
                if [ "$response" == "Y" ] || [ "$response" == "y" ]; then 
                    # Delete the database 
                    docker exec "$CONTAINER_ID" psql -U postgres -c "DROP DATABASE IF EXISTS dify;" 
                    echo "Dify database deleted successfully." 
                    
                    # Create the database again 
                    docker exec "$CONTAINER_ID" psql -U postgres -c "CREATE DATABASE dify;" 
                    
                    echo "Dify database created successfully." 
                else 
                    echo "Using existing database." 
                fi 
                break 
            else 
                # Create the database 
                docker exec "$CONTAINER_ID" psql -U postgres -c "CREATE DATABASE dify;" 
                
                # Check again if the database was created successfully 
                docker exec "$CONTAINER_ID" psql -U postgres -lqt | cut -d \| -f 1 | grep -qw "dify" 

                if [ $? -eq 0 ]; then 
                    echo "Dify database created successfully." 
                    break 
                else 
                    echo "Error creating the database. Trying again..." 
                fi 
            fi
        else  
            sleep 5 
        fi
    done 
} 

create_bank_postgres_affine() { 
    while :; do 
        if docker ps -q --filter "name=postgres" | grep -q.; then 
            CONTAINER_ID=$(docker ps -q --filter "name=postgres") 

            # Check if the database already exists 
            docker exec "$CONTAINER_ID" psql -U postgres -lqt | cut -d \| -f 1 | grep -qw "affine" 

            if [ $? -eq 0 ]; then 
                echo "The affine database already exists." 

                read -p "Do you want to delete and create a new database? (Y/N): " response 
                if [ "$response" == "Y" ] || [ "$response" == "y" ]; then 
                    # Delete the database 
                    docker exec "$CONTAINER_ID" psql -U postgres -c "DROP DATABASE IF EXISTS affine;" 
                    echo "Affine database deleted successfully." 
                    
                    # Create the database again 
                    docker exec "$CONTAINER_ID" psql -U postgres -c "CREATE DATABASE affine;" 
                    
                    echo "Affine database created successfully." 
                else 
                    echo "Using existing database." 
                fi 
                break 
            else 
                # Create the database 
                docker exec "$CONTAINER_ID" psql -U postgres -c "CREATE DATABASE affine;" 
                
                # Check again if the database was created successfully 
                docker exec "$CONTAINER_ID" psql -U postgres -lqt | cut -d \| -f 1 | grep -qw "affine" 

                if [ $? -eq 0 ]; then 
                    echo "Affine database created successfully." 
                    break 
                else 
                    echo "Error creating the database. Trying again..." 
                fi 
            fi 
        else 
            sleep 5 
        fi 
    done 
} 

create_banco_postgres_docuseal() { 
    while :; do 
        if docker ps -q --filter "name=postgres" | grep -q .; then 
            CONTAINER_ID=$(docker ps -q --filter "name=postgres") 

            # Check if the database already exists 
            docker exec "$CONTAINER_ID" psql -U postgres -lqt | cut -d \| -f 1 | grep -qw "docuseal" 

            if [ $? -eq 0 ]; then 
                echo "The docuseal database already exists." 

                read -p "Do you want to delete and create a new database? (Y/N): " response
                if [ "$response" == "Y" ] || [ "$response" == "y" ]; then 
                    # Delete the database 
                    docker exec "$CONTAINER_ID" psql -U postgres -c "DROP DATABASE IF EXISTS docuseal;" 
                    echo "Docuseal database deleted successfully." 
                    
                    # Create the database again 
                    docker exec "$CONTAINER_ID" psql -U postgres -c "CREATE DATABASE docuseal;" 
                    
                    echo "Docuseal database created successfully." 
                else 
                    echo "Using existing database." 
                fi 
                break 
            else 
                # Create the docker database 
                exec "$CONTAINER_ID" psql -U postgres -c "CREATE DATABASE docuseal;" 
                
                # Check again if the database was created successfully 
                docker exec "$CONTAINER_ID" psql -U postgres -lqt | cut -d \| -f 1 | grep -qw "docuseal" 

                if [ $? -eq 0 ]; then 
                    echo "Docuseal database created successfully." 
                    break 
                else 
                    echo "Error creating the database. Trying again..." 
                fi 
            fi 
        else 
            sleep 5 
        fi 
    done 
} 

create_banco_postgres_directus() { 
    while :; do 
        if docker ps -q --filter "name=postgres" | grep -q.; then 
            CONTAINER_ID=$(docker ps -q --filter "name=postgres") 

            # Check if the database already exists 
            docker exec "$CONTAINER_ID" psql -U postgres -lqt | cut -d \| -f 1 | grep -qw "directus" 

            if [ $? -eq 0 ]; then 
                echo "The directus database already exists." 

                read -p "Do you want to delete and create a new database? (Y/N): " response 
                if [ "$response" == "Y" ] || [ "$response" == "y" ]; then 
                    # Delete the database 
                    docker exec "$CONTAINER_ID" psql -U postgres -c "DROP DATABASE IF EXISTS directus;" 
                    echo "Directus database deleted successfully." 
                    
                    # Create the database again 
                    docker exec "$CONTAINER_ID" psql -U postgres -c "CREATE DATABASE directus;" 
                    
                    echo "Directus database created successfully." 
                else 
                    echo "Using existing database." 
                fi 
                break 
            else
                # Create the database 
                docker exec "$CONTAINER_ID" psql -U postgres -c "CREATE DATABASE directus;" 
                
                # Check again if the database was created successfully 
                docker exec "$CONTAINER_ID" psql -U postgres -lqt | cut -d \| -f 1 | grep -qw "directus" 

                if [ $? -eq 0 ]; then 
                    echo "Directus database created successfully." 
                    break 
                else 
                    echo "Error creating the database. Trying again..." 
                fi 
            fi 
        else 
            sleep 5 
        fi 
    done 
} 

create_banco_postgres_nextcloud() { 
    while :; do 
        if docker ps -q --filter "name=postgres" | grep -q.; then 
            CONTAINER_ID=$(docker ps -q --filter "name=postgres") 

            # Check if the database already exists 
            docker exec "$CONTAINER_ID" psql -U postgres -lqt | cut -d \| -f 1 | grep -qw "nextcloud" 

            if [ $? -eq 0 ]; then 
                echo "The nextcloud database already exists." 

                read -p "Do you want to delete and create a new database? (Y/N): " response 
                if [ "$response" == "Y" ] || [ "$response" == "y" ]; then 
                    # Delete the database 
                    docker exec "$CONTAINER_ID" psql -U postgres -c "DROP DATABASE IF EXISTS nextcloud;" 
                    echo "Nextcloud database deleted successfully." 
                    
                    # Create the database again 
                    docker exec "$CONTAINER_ID" psql -U postgres -c "CREATE DATABASE nextcloud;" 
                    
                    echo "Nextcloud database created successfully." 
                else 
                    echo "Using existing database." 
                fi 
                break 
            else 
                # Create the database 
                docker exec "$CONTAINER_ID" psql -U postgres -c "CREATE DATABASE nextcloud;" 
                
                # Check again if the database was created successfully 
                docker exec "$CONTAINER_ID" psql -U postgres -lqt | cut -d \| -f 1 | grep -qw "nextcloud" 
                    if 
                    [ $? 
                -eq 

                0 ]; Trying again..." 
                fi [ $? 
                    break 
            fi 
        else 
            sleep 5 
        fi 
    done 
} 


######################################## ########## 

## Mysql database creators 

## Create Mautic database 
create_bank_mysql_mautic() { 
    data 
    get_password_mysql 
    while :; do 
        if CONTAINER_ID=$(docker ps -q --filter "name=mysql"); then 
            if docker exec "$CONTAINER_ID" mysql -u root -p"$senha_mysql" -e "SHOW DATABASES LIKE 'mautic';" | grep -qw "mautic"; then 
                echo "The mautic database already exists." 

                response="N" 
                if [ "$response" == "Y" ] || [ "$response" == "y" ]; then 
                    docker exec "$CONTAINER_ID" mysql -u root -p"$senha_mysql" -e "DROP DATABASE IF EXISTS mautic;" 
                    echo "Mautic database deleted successfully." 
                else 
                    echo "Using existing database." 
                    break 
                fi 
            else 
                docker exec "$CONTAINER_ID" mysql -u root -p"$senha_mysql" -e "CREATE DATABASE mautic;" 
                echo "Mautic database created successfully." 
                break 
            fi 
        else 
            sleep 5 
        fi 
    done 
} 

create_banco_mysql_wordpress() { 
    data 
    fetch_password_mysql 
    while :; do 
        if CONTAINER_ID=$(docker ps -q --filter "name=mysql"); then 
            if docker exec "$CONTAINER_ID" mysql -u root -p"$password_mysql" -e "SHOW DATABASES LIKE '$name_site_wordpress';" | grep -qw "$name_site_wordpress"; then 
                echo "The Wordpress database already exists." 

                response="N" 
                if [ "$response" == "Y" ] || [ "$response" == "y" ]; then 
                    docker exec "$CONTAINER_ID" mysql -u root -p"$password_mysql" -e "DROP DATABASE IF EXISTS $name_site_wordpress;" 
                    echo "Wordpress database deleted successfully." 
                else 
                    echo "Using existing database." 
                    break 
                fi 
            else 
                docker exec "$CONTAINER_ID" mysql -u root -p"$mysql_password" -e "CREATE DATABASE $wordpress_sitename;" 
                echo "Wordpress database created successfully." 
                break 
            fi
        else  
            sleep 5
        fi 
    done 
} 


############################################ ###### 

## Installation of Tools 

## ████████╗███████╗███████╗████████╗█ ██ ████╗ ███████╗███╗ ███╗████████████╗ 
═██╔══╝██ ╔════╝██╔════╝╚══██╔══╝██╔════╝ ██╔════╝█ ███╗ ████║╚ ══██╔══╝██╔══██╗ 
## ██║ █████╗ ███████╗ ███ ███╗ ██████ █╗██╔████╔██║ ██║ ██████╔╝ 
## ██║ ██╔══╝ ╚════ ██║ ██║ ██╔═ ═╝ ╚════██║██║╚██╔╝██║ ██║ ██╔═══╝ 
## ██║ ████ ███╗██████ █║ ██║ ███████╗ ███████║██║ ╚═╝ ██║ ██║ ██║      
## ═╝ ╚══════╝╚ ══════╝ ╚═╝ ╚══════╝ ╚══════╝╚═╝ ╚═╝ ╚═╝ ╚═╝      tool_ 
emailtest 
                                                                                  
() { 
clear 
dataemail_name 
fill_as_info 
while true; do 
echo -en "\e[33mEnter the email address (e.g. contato@oriondesign.art.br): \e[0m" && read -r email_teste 
echo "" 
echo -e "\e[97mPasso$amarelo 2/ 5\e[0m" 
echo -e "$amarelo--> If you don't have an email username, use your own email address below" 
echo -en "\e[33mEnter your email username (e.g. oriondesign or contato@oriondesign. art.br): \e[0m" && read -r user_teste 
echo "" 
echo -e "\e[97mPasso$amarelo 3/5\e[0m" 
echo -e "$amarelo--> No special characters: \ !#$ | If you are using gmail, use the app password " 
echo -en "\e[33mEnter the email password (ex: @Password123_): \e[0m" && read -r test_password 
echo "" 
echo -e " \e[97mStep$yellow 4/5\e[0m" 
echo -en "\e[33mEnter the Smtp Host (ex: smtp.hostinger.com): \e[0m" && read -r host_teste 
echo "" 
echo - and "\e[97mStep$yellow 5/5\e[0m" 
echo -en "\e[33mEnter the Smtp Port (ex: 465): \e[0m" && read -r test_port 
echo "" 
clear 
test_namemail 
checking_as_info 
echo -e "\e[33mEmail:\e[97m $email_teste\e[0m" 
echo "" 
echo -e "\e[33mUsuário:\e[97m $user_teste\e[0m" 
echo "" 
echo -e "\ e[33mPassword:\e[97m $test_password\e[0m" 
echo "" 
echo -e "\e[33mHost:\e[97m $test_host\e[0m" 
echo "" 
echo -e "\e[33mPort: \e[97m $porta_teste\e[0m" 
echo "" 
read -p "Are the answers correct? (Y/N):" confirmation 
if [ "$confirmation" = "Y" ] || [ "$confirmation" = "y" ]; then 
    clear 
    nome_testando 
    break 
else 
    clear 
    nome_testeemail 
    fill_as_info 
fi 
done 
#STARTING MESSAGE (STEPS) 
echo -e "\e[ 97m• STARTING CHECK \e[33m[1/3]\e[0m"













 
echo "" 

sudo apt-get update > /dev/null 2>&1 
sudo apt-get install swaks -y > /dev/null 2>&1 

msg="If you're reading this, your SMTP is working =D. 
By: OrionDesign" 

if swaks --to "$email_teste" - -from "$email_teste" --server "$host_teste" --port "$porta_teste" --auth LOGIN --auth-user "$user_teste" --auth-password "$senha_teste" --tls --body "$ msg"; then 
    sleep 2 
    clear 
    email_test_name 
    echo -e "\e[32m[SMTP Test Result]\e[0m" 
    echo "" 
    echo -e "\e[33mThe data entered\e[92m is working correctly\e[33m.\ e[0m" 
else 
    sleep 2 
    clear 
    test_nameemail 
    echo -e "\e[32m[SMTP Test Result]\e[0m" 
    echo "" 
    echo -e "\e[33mThe data entered\e[91m is NOT working correctly. \e[33m Please check the data and try again.\e[0m" 
fi 

creditos_msg 

read -p "Do you want to install another application (Y/N):" choice 
    if [ "$choice" = "Y" ] || [ "$choice" = "y" ]; then 
        return 
    else 
        cd 
        cd 
        clear 
        exit 1 
    fi    
} 

## ████████╗███ ███╗ █████╗ ███████╗███████╗██╗██╗ ██╗ ████ ███╗      
## ╚══██ ╔══╝██╔══██╗██╔══██╗██╔════╝██╔════╝██║█ █║ ██╔╝ ██╔═ ═══╝      
## ██║ ██████╔╝███████║█████╗ █████╗ ██║ █████╔╝ ███ ██╗        
## ██║ ██╔══██╗██╔══██║██╔══╝ ██╔══╝██║█ █╔═██╗ ██╔═ ═╝        
## ██║ ██║ ██║██║ ██║███████╗██║ ██║██║ ██╗ ███████╗      
## ╚ ═╝ ╚═╝ ╚═╝╚═╝ ╚═╝╚══════╝╚═╝ ╚═╝╚═╝ ╚═╝ ╚═══ ═══╝      
##                                                                         
## ████ ██╗ ██████╗ ██████╗ ████████╗ █████╗ ██╗███████╗ ██████╗ 
## ██╔══██╗██╔═══██╗██╔══██╗╚══██╔═ ═╝██╔══██ ╗██║████╗ ██║██╔════╝██╔══██╗ 
██║██████ ╔╝ ██║ ███████║██║██╔██╗ ██████╗ 
# ██╔═══╝ ██ ║ ██║██╔══██╗ ██║ ██╔══██║██║██║╚██╗██║██╔ ══╝ ██╔══██╗ 
## ██║ ╚██████╔╝██║ ██║ ██║ ██║ ██║██║██║ ║███████╗█ █║ ██║ 
## ╚═╝ ╚═════╝ ╚═╝ ╚═╝ ╚═╝ ╚═╝ ╚═╝╚═╝╚═╝ ═══╝╚══════ ╝╚═╝ ╚═╝ 

tool_traefik_e_portainer() { 

## Clears the terminal 
clear ## 

Shows the name of the application 
name_traefik_e_portainer 
## Shows a message to fill in information 
fill_as_info 
## Starts a Loop until the data is correct 
while true; ## 
    Ask the Domain for application



    echo -e "\e[97mStep$yellow 1/4\e[0m"
    echo -en "\e[33mEnter the Domain for Portainer (ex: portainer.oriondesign.art.br): \e[0m" && read -r url_portainer 
    echo "" 

    ## Asks for the Server Name 
    echo -e "\ e[97mStep$yellow 2/4\e[0m" 
    echo -e "$yellow--> Cannot contain spaces and/or special characters, except Underline_" 
    echo -en "\e[33mChoose a name for your server ( ex: OrionDesign): \e[0m" && read -r server_name 
    echo "" 
    
    ## Asks for the name of the Internal Network 
    echo -e "\e[97mStep$yellow 3/4\e[0m" 
    echo -e "$yellow --> Cannot contain spaces and/or special characters, except Underline_" 
    echo -en "\e[33mEnter a name for your internal network (ex: OrionNet): \e[0m" && read -r internal_network_name 
    echo "" 
    
    # # Ask Email for information about the certificate 
    echo -e "\e[97mPasso$amarelo 4/4\e[0m" 
    echo -en "\e[33mEnter a valid Email address (e.g. contato@oriondesign.art.br ): \e[0m" && read -r email_ssl 
    echo "" 

    ## Clears the termianl 
    clear 

    ## Shows the name of the application 
    name_traefik_e_portainer 

    ## Shows a message to check the information 
    checking_as_info 

    ## Information about URL 
    echo -e "\e[ 33mPortainer Link:\e[97m $url_portainer\e[0m" 
    echo "" 

    ## Server Name Information 
    echo -e "\e[33mServerName:\e[97m $server_name\e[0m" 
    echo "" 

    ## Information about internal Network Name 
    echo -e "\e[33mInternal network:\e[97m $internal_network_name\e[0m" 
    echo "" 

    ## Information about Email 
    echo -e "\e[33mEmail:\e[97m $email_ssl\e[0m" 
    echo "" 
    echo "" 

    ## Asks if the answers are correct 
    read -p "Are the answers correct? (Y/N): " confirmation 
    if [ "$confirmation" = "Y" ] || [ "$confirmation" = "y" ]; then 

        ## Typed Y to confirm that the information is correct 

        ## Clear the terminal 
        clear 

        ## Show Installing message 
        installing_msg 

        ## Exit Loop 
        break 
    else 

        ## You typed N to say that the information is not correct.

        ## Clear terminal 
        clear 

        ## Shows the name of the tool 
        name_traefik_e_portainer 

        ## Shows message to fill in information 
        fill_as_info 

    ## Returns to the beginning of the loop with the questions
    fi 
done 

## Step Message 
echo -e "\e[97m• STARTING TRAEFIK INSTALLATION \e[33m[1/8]\e[0m" 
echo "" 
sleep 1 

##In this step we will be saving the data filled in previously so that the installer can use it later when installing any tool. 

## Ensures that the user is in /root/ 
cd 
cd 

## Checks if a folder called "dados_vps" doesn't already exist, if it exists it ignores it and if it doesn't exist it creates one 
## This was a PR that came from user Fabio => https://github.com/hipnologo 

if [ ! -d "vps_data" ]; then 
    mkdir dados_vps 
fi 

## End of PR 

## Open the vps_data folder 
cd dados_vps 

## Create a file called "vps_data" with: "server name", "internal network name", "email", "portainer link" 
cat > dados_vps << EOL 
[VPS DATA] 

This data was filled in when you installed Traefik and Portainer and 
will be used to perform installations on SetupOrion v.2 

Server Name: $nome_servidor 

Internal network: $nome_rede_interna 

Email to SSL: $email_ssl 

Portainer Link : $url_portainer 

Thank you for using our AutoInstaller. 
If this content was useful, be sure to support our project. 

pix@oriondesign.art.br 

Drink water! 
EOL 

## Return to /root/ 
cd 
cd 

## Activate the data function to get data from the 
data vps 

## Step Message 
echo -e "\e[97m• UPDATING AND CONFIGURING THE VPS \e[33m[2/8 ]\e[0m" 
echo "" 
sleep 1 

## In this step we will be updating and configuring the vps to be able to run our setup 

## All the steps that are with "> /dev/null 2>&1" are to not show the logs. 

## I did this in order to improve the visualization, leaving the terminal with only the pre-described steps 

## I will add a check with echo and the step in case there is a problem to check.

sudo apt-get update > /dev/null 2>&1 
if [ $? -eq 0 ]; then 
    echo "1/9 - [ OK ]" 
else 
    echo "1/9 - [ OFF ]" 
fi 
sudo apt upgrade -y > /dev/null 2>&1 
if [ $? -eq 0 ]; then 
    echo "2/9 - [ OK ]" 
else 
    echo "2/9 - [ OFF ]" 
fi 
sudo timedatectl set-timezone America/Sao_Paulo > /dev/null 2>&1 
if [ $? -eq 0 ]; then 
    echo "3/9 - [ OK ]" 
else 
    echo "3/9 - [ OFF ]"  
fi
sudo apt-get install -y apt-utils > /dev/null 2>&1 
if [ $? -eq 0 ]; then
    echo "4/9 - [ OK ]" 
else 
    echo "4/9 - [ OFF ]" 
fi 
sudo apt-get update > /dev/null 2>&1 
if [ $? -eq 0 ]; then 
    echo "5/9 - [ OK ]" 
else 
    echo "5/9 - [ OFF ]" 
fi 
hostnamectl set-hostname $server_name > /dev/null 2>&1 
if [ $? -eq 0 ]; then 
    echo "6/9 - [ OK ]" 
else 
    echo "6/9 - [ OFF ]" 
fi 
sudo sed -i "s/127.0.0.1[[:space:]]localhost/127.0.0.1 $server_name/g" /etc/hosts > /dev/null 2>&1 
if [ $? -eq 0 ]; then 
    echo "7/9 - [ OK ]" 
else 
    echo "7/9 - [ OFF ]" 
fi 
sudo apt-get update > /dev/null 2>&1 
if [ $? -eq 0 ]; then 
    echo "8/9 - [ OK ]" 
else 
    echo "8/9 - [ OFF ]" 
fi 
if [ $? -eq 0 ]; then 
    echo "9/9 - [ OK ]" 
else 
    echo "9/9 - [ OFF ]" 
fi 
echo "" 

## Step Message 
echo -e "\e[97m• INSTALLING DOCKER SWARM \e[33m[3/ 8]\e[0m" 
echo "" 
sleep 1 

## In this step we will be installing docker in swarm mode 


ip=$(curl -s ifconfig.me) 
if [ $? -eq 0 ]; then 
    echo "1/3 - [ OK ]" 
else 
    echo "1/3 - [ OFF ]" 
fi 
curl -fsSL https://get.docker.com | bash > /dev/null 2>&1 
if [ $? -eq 0 ]; then 
    echo "2/3 - [ OK ]" 
else 
    echo "2/3 - [ OFF ]" 
fi 
docker swarm init --advertise-addr $ip > /dev/null 2>&1 
if [ $? -eq 0 ]; then 
    echo "3/3 - [ OK ]" 
else 
    echo "3/3 - [ OFF ]" 
fi 
echo "" 

## Step Message 
echo -e "\e[97m• CREATING INTERNAL NETWORK \e[33m[4/ 8]\e[0m" 
echo "" 
sleep 1 

## In this step we will create the internal network to use in other applications 

docker network create --driver=overlay $nome_rede_interna > /dev/null 2>&1 
if [ $? -eq 0 ]; then 
    echo "1/1 - [ OK ]" 
else 
    echo "1/1 - [ OFF ]" 
fi 
echo "" 

 ## Step Message 
echo -e "\e[97m• INSTALLING TRAEFIK \e[33m[5/8] \e[0m" 
echo "" 
sleep 1 

## In this step we will be creating the traefik Stack yaml in the /root/ folder 
## This will allow the user to edit it later 

## Then we will install traefik and check if everything is ok. 

## Creating stack 
  traefik: 
    image: traefik:latest 
cat > traefik.yaml << EOL
version: "3.7" 

services: 

    command: 
      - "--api.dashboard=true" 
      - "--providers.docker.swarmMode=true" 
      - "--providers.docker.endpoint=unix:///var/run/ docker.sock" 
      - "--providers.docker.exposedbydefault=false" 
      - "--providers.docker.network=$internal_network_name" ## Internal network name 
      - "--entrypoints.web.address=:80" 
      - "- -entrypoints.web.http.redirections.entryPoint.to=websecure" 
      - "--entrypoints.web.http.redirections.entryPoint.scheme=https" 
      - "--entrypoints.web.http.redirections.entrypoint.permanent=true " 
      - "--entrypoints.websecure.address=:443" 
      - "--certificatesresolvers.letsencryptresolver.acme.httpchallenge=true" 
      - "--certificatesresolvers.letsencryptresolver.acme.storage=/etc/traefik/letsencrypt/acme.json " 
      - "--certificatesresolvers.letsencryptresolver.acme.email=$email_ssl" ## Email to receive notifications 
      - "--log.level=DEBUG" 
      - "--log.format=common" 
      - "--log.filePath= /var/log/traefik/traefik.log" 
      - "--accesslog=true" 
      - "--accesslog.filepath=/var/log/traefik/access-log" 
    deploy: 
      placement: 
        constraints: 
          - node.role == manager 
      labels: 
        - "traefik.enable=true" 
        - "traefik.http.middlewares.redirect-https.redirectscheme.scheme=https" 
        - "traefik.http.middlewares.redirect-https.redirectscheme.permanent=true" 
        - "traefik .http.routers.http-catchall.rule=Host(\`{host:.+}\`)" 
        - "traefik.http.routers.http-catchall.entrypoints=web" 
        - "traefik.http.routers.http -catchall.middlewares=redirect-https@docker" 
        - "traefik.http.routers.http-catchall.priority=1" 
    volumes: 
      - "vol_certificates:/etc/traefik/letsencrypt" 
      - "/var/run/docker.sock :/var/run/docker.sock:ro" 
    ports: 
      - target: 80 
        published: 80 
        mode: host 
      - target: 443 
        published: 443 
        mode: host 
    networks: 
      - $nome_rede_interna ## Internal network name 

volumes: 

  vol_shared: 
    external : true 
    name: volume_swarm_shared 
  vol_certificates: 
    external: true 
    name:volume_swarm_certificates 

networks: 

  $internal_network_name: ## Internal network name 
    external: true 
    name: $internal_network_name ## Internal network name
EOL 
if [ $? -eq 0 ]; then  
    echo "1/2 - [OK]" 
else
    echo "1/2 - [ OFF ]" 
    echo "Oops, unable to create the Traefik stack" 
fi 

docker stack deploy --prune --resolve-image always -c traefik.yaml traefik > /dev/null 2> &1 
if [ $? -eq 0 ]; then 
    echo "2/2 - [ OK ]" 
else 
    echo "2/2 - [ OFF ]" 
    echo "Oops, it was not possible to upload Traefik." 
fi 

## Step Message 
echo -e "\e[97m• WAITING FOR TRAEFIK TO BE ONLINE \e[33m[6/8]\e[0m" 
echo "" 
sleep 1 

## Use the wait_traefik service to check if the service is online 
wait_traefik 

## Wait 30 seconds 
wait_30_sec 

## Step Message 
echo -e "\e[97m• INSTALLING PORTAINER \e[33m[7/8]\e[0m" 
sleep 1 

## In this step we will be creating the Portainer Stack yaml in the /root/ folder 
## This will allow the user to edit it later 

## Then we will install Portainer and check if everything is ok. 

## Creating the stack 
cat > portainer.yaml </dev/null 2>&1 
if [ $? -eq 0 ]; then 
    echo "1/2 - [ OK ]" 
else 
    echo "1/2 - [ OFF ]" 
    echo "Oops, it was not possible to increase Portainer's stack" 
fi 

## Mensagem de Passo 
echo -e "\e[97m• WAITING FOR PORTAINER TO BE ONLINE \e[33m[8/8]\e[0m" 
echo "" 
sleep 1 

## Use the wait_portainer service to check if the service is online 
wait_portainer 

## Saving installation information within /dados_vps/ 
cd dados_vps 

cat > data_portainer <
    postgres.yaml <
     /dev/null 2>&1 
if [ $? -eq 0 ]; then 
    echo "2/2 - [ OK ]" 
else 
    echo "2/2 - [ OFF ]" 
    echo "Oops, unable to upload the Postgres stack." 
fi 

## Saving installation information within /dados_vps/ 
cd dados_vps 

cat > dados_postgres <
      redis.yaml <
       redis_data <
        
         mysql.yaml <
         
          /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Oops, unable to upload the Postgres stack." fi ## Saving installation information within /dados_vps/ cd dados_vps cat > dados_mysql <
          
           No special characters: \!#$ | If you are using gmail, use the app password" echo -en "\e[33mEnter the Email SMTP Password (ex: @Password123_): \e[0m" && read -r password_email_chatwoot echo "" ## Asks the SMTP Host of email echo -e "\e[97mStep$yellow 4/5\e[0m" echo -en "\e[33mEnter the Email SMTP Host (ex: smtp.hostinger.com): \e[0m" && read - r smtp_email_chatwoot echo "" ## Asks for the SMTP port of the email echo -e "\e[97mStep$yellow 5/5\e[0m" echo -en "\e[33mEnter the SMTP port of the Email (ex: 465): \e[0m" && read -r porta_smtp_chatwoot ## Checks if the port is 465, if yes, leave ssl true, if not, leave false if [ "$porta_smtp_chatwoot" -eq 465 ]; then sobre_ssl=true else sobre_ssl=false fi ## Clears the terminal clear ## Shows the name of the application chat_name ## Shows a message to check the information checking_as_info ## Information about URL echo -e "\e[33mChatwoot Domain:\e[97m $url_chatwoot\e[0m " echo "" ## Company Name Information echo -e "\e[33mCompany Name:\e[97m $chatroot_company_name\e[0m" echo "" ## SMTP Email Information echo -e "\e[ 33mSMTP Email:\e[97m $email_admin_chatwoot\e[0m" echo "" ## SMTP Password Information echo -e "\e[33mSMTP Password:\e[97m $password_email_chatroot\e[0m" echo "" ## SMTP Host Information echo -e "\e[33mSMTPHost:\e[97m $smtp_email_chatroot\e[0m" echo "" ## SMTP Port Information echo -e "\e[33mSMTP Port:\e[97m $porta_smtp_chatroot\e[0m" echo "" echo "" ## Asks if the answers are correct read -p "Are the answers correct? (Y/N): " confirmation if [ "$confirmation" = "Y" ] || [ "$confirmation" = "y" ]; then ## Typed Y to confirm that the information is correct ## Clear the terminal clear ## Show Installing message installing_msg ## Exit Loop break else ## You typed N to say that the information is not correct.## Clear terminal clear ## Shows the name of the tool chat_name ## Shows message to fill in information fill_as_info ## Returns to the beginning of the loop with the questions fi done ## Step Message echo -e "\e[97m• STARTING INSTALLING CHATWOOT \e[33m[1/6]\e[0m" echo "" sleep 1 ## Activates the data function to get data from the data vps ## Step Message echo -e "\e[97m• CHECKING/INSTALLING POSTGRES AND REDIS \e[33m[2/6]\e[0m" echo "" sleep 1 ## Here we will check if Postgres and Redis are already installed ## If so, it will create a database in postgres or ask if you want to delete what already exists and create another ## Check postgres container and create database in postgres verify_container_postgres if [ $? -eq 0 ]; then get_password_postgres > /dev/null 2>&1 create_banco_postgres_chatroot else tool_postgres > /dev/null 2>&1 get_password_postgres > /dev/null 2>&1 create_bank_postgres_chatroot fi if [ $? -eq 0 ]; then echo "1/2 - [ OK ]" else echo "1/2 - [ OFF ]" fi ## Check redis container check_container_redis if [ $? -eq 0 ]; then echo "" else redis_tool > /dev/null 2>&1 fi if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" fi ## Step Message echo -e "\e[97m• INSTALLING CHATWOOT \e[33m[3/6]\e [0m" echo "" sleep 1 ## In this step we will be creating the Chatwoot Stack yaml in the /root/ folder ## This will allow the user to edit it later ## Then we will install Chatwoot and check if everything is ok . ## Creating random key encryption_key=$(openssl rand -hex 16) ## Creating stack cat > chatwoot.yaml <
           
            <$email_admin_chatwoot> ## Email SMTP - SMTP_DOMAIN=$domain_smtp_chatwoot ## Email domain - SMTP_ADDRESS=$smtp_email_chatwoot ## Host SMTP - SMTP_PORT=$porta_smtp_chatwoot ## SMTP port - SMTP_SSL=$about_ssl ## If the port is 465 = true | If the port is 587 = false - SMTP_USERNAME=$email_admin_chatwoot ## SMTP email - SMTP_PASSWORD=$password_email_chatwoot ## SMTP password - SMTP_AUTHENTICATION=login - SMTP_ENABLE_STARTTLS_AUTO=true - SMTP_OPENSSL_VERIFY_MODE=peer - MAILER_INBOUND_EMAIL_DOMAIN=$email_ admin_chatroot ## Email SMTP deploy: mode : replicated replicas: 1 placement: constraints: - node.role == manager resources: limits: cpus: "1" memory: 1024M labels: - traefik.enable=true - traefik.http.routers.chatwoot_app.rule=Host(\ `$url_chatwoot\`) - traefik.http.routers.chatwoot_app.entrypoints=websecure - traefik.http.routers.chatwoot_app.tls.certresolver=letsencryptresolver - traefik.http.routers.chatwoot_app.priority=1 - traefik.http.routers .chatwoot_app.service=chatwoot_app - traefik.http.services.chatwoot_app.loadbalancer.server.port=3000 - traefik.http.services.chatwoot_app.loadbalancer.passhostheader=true - traefik.http.middlewares.sslheader.headers.customrequestheaders.X -Forwarded-Proto=https - traefik.http.routers.chatwoot_app.middlewares=sslheader@docker chatwoot_sidekiq: image: chatwoot/chatwoot:latest command: bundle exec sidekiq -C config/sidekiq.yml volumes: - chatwoot_data:/app/storage ## Directory of conversation files - chatwoot_public_orion:/app ## Directory of all chatwoot networks files: - $nome_rede_interna ## Name of the internal network environment: - CHATWOOT_HUB_URL=https://oriondesign.art.br/setup - INSTALLATION_NAME =$company_name_chatwoot ## Company name - NODE_ENV=production - RAILS_ENV=production - INSTALLATION_ENV=docker - SECRET_KEY_BASE=$encryption_key ## Random key generated randomly - FRONTEND_URL=https://$url_chatwoot ## Chatwoot Url - DEFAULT_LOCALE=pt_BR - FORCE_SSL=true - ENABLE_ACCOUNT_SIGNUP=false ## false = Disable new signups at startup | true = Enable new subscriptions at the beginning - REDIS_URL=redis://redis:6379 - POSTGRES_HOST=postgres - POSTGRES_USERNAME=postgres - POSTGRES_PASSWORD=$password_postgres ## Postgres password - POSTGRES_DATABASE=chatwoot - ACTIVE_STORAGE_SERVICE=local - RAILS_LOG_TO_STDOUT=true - _INBOX_AVATAR_FOR_BOT= true - MAILER_SENDER_EMAIL=$email_admin_chatwoot <$email_admin_chatwoot> ## Email SMTP - SMTP_DOMAIN=$domain_smtp_chatwoot ## Email domain - SMTP_ADDRESS=$smtp_email_chatwoot ## SMTP Host - SMTP_PORT=$porta_smtp_chatwoot ## SMTP Port - SMTP_SSL= $about_ssl ## If port is 465 = true | If the port is 587 = false - SMTP_USERNAME=$email_admin_chatwoot ## SMTP email - SMTP_PASSWORD=$password_email_chatwoot ## SMTP password - SMTP_AUTHENTICATION=login - SMTP_ENABLE_STARTTLS_AUTO=true - SMTP_OPENSSL_VERIFY_MODE=peer - MAILER_INBOUND_EMAIL_DOMAIN=$email_ admin_chatroot ## Email SMTP deploy: mode : replicated replicas:1 placement: constraints: - node.role == manager resources: limits: cpus: "1" memory: 1024M volumes: chatwoot_data: external: true name: chatwoot_data chatwoot_public_orion: external: true name: chatwoot_public_orion networks: $name_rede_interna: ## Name of the internal network external: true name: $internal_network_name ## Name of the internal network EOL if [ $? -eq 0 ]; then echo "1/2 - [ OK ]" else echo "1/2 - [ OFF ]" echo "Unable to create Chatwoot stack" fi docker stack deploy --prune --resolve-image always -c chatwoot. yaml chatwoot > /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to upload Chatwoot stack" fi ## Step Message echo -e "\e[97m• WAITING FOR SERVICE DO CHATWOOT BE READY \e[33m[4/6]\e[0m" echo "" sleep 1 ## Use the wait_chatwoot service to check if the service is online wait_chatwoot ## Step Message echo -e "\e[97m • MIGRATING DATABASE \e[33m[5/6]\e[0m" echo "" sleep 1 ## Here we will be migrating the database using the command "bundle exec rails db:chatwoot_prepare" ## Basically you could enter the chatwoot database and execute the command there also container_name="chatwoot_chatwoot_app" max_wait_time=1200 wait_interval=60 elapsed_time=0 while [ $elapsed_time -lt $max_wait_time ]; do CONTAINER_ID=$(docker ps -q --filter "name=$container_name") if [ -n "$CONTAINER_ID" ]; then break fi sleep $wait_interval elapsed_time=$((elapsed_time + wait_interval)) done if [ -z "$CONTAINER_ID" ]; then echo "Container was not found after $max_wait_time seconds." exit 1 fi docker exec -it "$CONTAINER_ID" bundle exec rails db:chatroot_prepare if [ $? -eq 0 ]; then echo "1/1 - [ OK ]" else echo "1/1 - [ OFF ]" echo "Unable to migrate the database" fi ## Step Message echo -e "\e[97m• ACTIVATING FUNCTIONS FROM SUPER ADMIN \e[33m[6/6]\e[0m" echo "" sleep 1 ## Here we will change some data in postgres to release some hidden functions in the super admin panel wait_for_postgres docker exec -i $CONTAINER_ID psql - U postgres <yaml chatwoot > /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to upload Chatwoot stack" fi ## Step Message echo -e "\e[97m• WAITING FOR SERVICE DO CHATWOOT BE READY \e[33m[4/6]\e[0m" echo "" sleep 1 ## Use the wait_chatwoot service to check if the service is online wait_chatwoot ## Step Message echo -e "\e[97m • MIGRATING DATABASE \e[33m[5/6]\e[0m" echo "" sleep 1 ## Here we will be migrating the database using the command "bundle exec rails db:chatwoot_prepare" ## Basically you could enter the chatwoot database and execute the command there also container_name="chatwoot_chatwoot_app" max_wait_time=1200 wait_interval=60 elapsed_time=0 while [ $elapsed_time -lt $max_wait_time ]; do CONTAINER_ID=$(docker ps -q --filter "name=$container_name") if [ -n "$CONTAINER_ID" ]; then break fi sleep $wait_interval elapsed_time=$((elapsed_time + wait_interval)) done if [ -z "$CONTAINER_ID" ]; then echo "Container was not found after $max_wait_time seconds." exit 1 fi docker exec -it "$CONTAINER_ID" bundle exec rails db:chatroot_prepare if [ $? -eq 0 ]; then echo "1/1 - [ OK ]" else echo "1/1 - [ OFF ]" echo "Unable to migrate the database" fi ## Step Message echo -e "\e[97m• ACTIVATING FUNCTIONS FROM SUPER ADMIN \e[33m[6/6]\e[0m" echo "" sleep 1 ## Here we will change some data in postgres to release some hidden functions in the super admin panel wait_for_postgres docker exec -i $CONTAINER_ID psql - U postgres <yaml chatwoot > /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to upload Chatwoot stack" fi ## Step Message echo -e "\e[97m• WAITING FOR SERVICE DO CHATWOOT BE READY \e[33m[4/6]\e[0m" echo "" sleep 1 ## Use the wait_chatwoot service to check if the service is online wait_chatwoot ## Step Message echo -e "\e[97m • MIGRATING DATABASE \e[33m[5/6]\e[0m" echo "" sleep 1 ## Here we will be migrating the database using the command "bundle exec rails db:chatwoot_prepare" ## Basically you could enter the chatwoot database and execute the command there also container_name="chatwoot_chatwoot_app" max_wait_time=1200 wait_interval=60 elapsed_time=0 while [ $elapsed_time -lt $max_wait_time ]; do CONTAINER_ID=$(docker ps -q --filter "name=$container_name") if [ -n "$CONTAINER_ID" ]; then break fi sleep $wait_interval elapsed_time=$((elapsed_time + wait_interval)) done if [ -z "$CONTAINER_ID" ]; then echo "The container was not found after $max_wait_time seconds." exit 1 fi docker exec -it "$CONTAINER_ID" bundle exec rails db:chatroot_prepare if [ $? -eq 0 ]; then echo "1/1 - [ OK ]" else echo "1/1 - [ OFF ]" echo "Unable to migrate the database" fi ## Step Message echo -e "\e[97m• ACTIVATING FUNCTIONS FROM SUPER ADMIN \e[33m[6/6]\e[0m" echo "" sleep 1 ## Here we will change some data in postgres to release some hidden functions in the super admin panel wait_for_postgres docker exec -i $CONTAINER_ID psql - U postgres <chatwoot_prepare if [ $? -eq 0 ]; then echo "1/1 - [ OK ]" else echo "1/1 - [ OFF ]" echo "Unable to migrate the database" fi ## Step Message echo -e "\e[97m• ACTIVATING FUNCTIONS FROM SUPER ADMIN \e[33m[6/6]\e[0m" echo "" sleep 1 ## Here we will change some data in postgres to release some hidden functions in the super admin panel wait_for_postgres docker exec -i $CONTAINER_ID psql - U postgres <chatwoot_prepare if [ $? -eq 0 ]; then echo "1/1 - [ OK ]" else echo "1/1 - [ OFF ]" echo "Unable to migrate the database" fi ## Step Message echo -e "\e[97m• ACTIVATING FUNCTIONS FROM SUPER ADMIN \e[33m[6/6]\e[0m" echo "" sleep 1 ## Here we will change some data in postgres to release some hidden functions in the super admin panel wait_for_postgres docker exec -i $CONTAINER_ID psql - U postgres <
            
             data_chatroot <
             
              No special characters: \!#$ | If you are using gmail, use the app password" echo -en "\e[33mEnter the Email SMTP Password (ex: @Password123_): \e[0m" && read -r password_email_chatwoot echo "" ## Asks the SMTP Host of email echo -e "\e[97mStep$yellow 4/5\e[0m" echo -en "\e[33mEnter the Email SMTP Host (ex: smtp.hostinger.com): \e[0m" && read - r smtp_email_chatwoot echo "" ## Asks for the SMTP port of the email echo -e "\e[97mStep$yellow 5/5\e[0m" echo -en "\e[33mEnter the SMTP port of the Email (ex: 465): \e[0m" && read -r porta_smtp_chatwoot ## Checks if the port is 465, if yes, leave ssl true, if not, leave false if [ "$porta_smtp_chatwoot" -eq 465 ]; then sobre_ssl=true else sobre_ssl=false fi ## Clears the terminal clear ## Shows the name of the application chat_name ## Shows a message to check the information checking_as_info ## Information about URL echo -e "\e[33mChatwoot Domain:\e[97m $url_chatwoot\e[0m " echo "" ## Company Name Information echo -e "\e[33mCompany Name:\e[97m $chatroot_company_name\e[0m" echo "" ## SMTP Email Information echo -e "\e[ 33mSMTP Email:\e[97m $email_admin_chatwoot\e[0m" echo "" ## SMTP Password Information echo -e "\e[33mSMTP Password:\e[97m $password_email_chatroot\e[0m" echo "" ## SMTP Host Information echo -e "\e[33mSMTPHost:\e[97m $smtp_email_chatroot\e[0m" echo "" ## SMTP Port Information echo -e "\e[33mSMTP Port:\e[97m $porta_smtp_chatroot\e[0m" echo "" echo "" ## Asks if the answers are correct read -p "Are the answers correct? (Y/N): " confirmation if [ "$confirmation" = "Y" ] || [ "$confirmation" = "y" ]; then ## Typed Y to confirm that the information is correct ## Clear the terminal clear ## Show Installing message installing_msg ## Exit Loop break else ## You typed N to say that the information is not correct.## Clear terminal clear ## Shows the name of the tool chat_name ## Shows message to fill in information fill_as_info ## Returns to the beginning of the loop with the questions fi done ## Step Message echo -e "\e[97m• STARTING INSTALLING CHATWOOT ARM \e[33m[1/6]\e[0m" echo "" sleep 1 ## Activates the data function to get data from the data vps ## Step Message echo -e "\e[97m • CHECKING/INSTALLING POSTGRES AND REDIS \e[33m[2/6]\e[0m" echo "" sleep 1 ## Here we will check if Postgres and Redis are already installed ## If so, it will create a database data in postgres or ask if you want to delete what already exists and create another ## Check postgres container and create database in postgres verify_container_postgres if [ $? -eq 0 ]; then get_password_postgres > /dev/null 2>&1 create_banco_postgres_chatroot else tool_postgres > /dev/null 2>&1 get_password_postgres > /dev/null 2>&1 create_bank_postgres_chatroot fi if [ $? -eq 0 ]; then echo "1/2 - [ OK ]" else echo "1/2 - [ OFF ]" fi ## Check redis container check_container_redis if [ $? -eq 0 ]; then echo "" else redis_tool > /dev/null 2>&1 fi if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" fi ## Step Message echo -e "\e[97m• INSTALLING CHATWOOT \e[33m[3/6]\e [0m" echo "" sleep 1 ## In this step we will be creating the Chatwoot Stack yaml in the /root/ folder ## This will allow the user to edit it later ## Then we will install Chatwoot and check if everything is ok . ## Creating random key encryption_key=$(openssl rand -hex 16) ## Creating stack cat > chatwoot.yaml <
              
               <$email_admin_chatwoot> ## Email SMTP - SMTP_DOMAIN=$domain_smtp_chatwoot ## Email domain - SMTP_ADDRESS=$smtp_email_chatwoot ## Host SMTP - SMTP_PORT=$porta_smtp_chatwoot ## SMTP port - SMTP_SSL=$about_ssl ## If the port is 465 = true | If the port is 587 = false - SMTP_USERNAME=$email_admin_chatwoot ## SMTP email - SMTP_PASSWORD=$password_email_chatwoot ## SMTP password - SMTP_AUTHENTICATION=login - SMTP_ENABLE_STARTTLS_AUTO=true - SMTP_OPENSSL_VERIFY_MODE=peer - MAILER_INBOUND_EMAIL_DOMAIN=$email_ admin_chatroot ## Email SMTP deploy: mode : replicated replicas: 1 placement: constraints: - node.role == manager resources: limits: cpus: "1" memory: 1024M labels: - traefik.enable=true - traefik.http.routers.chatwoot_app.rule=Host(\ `$url_chatwoot\`) - traefik.http.routers.chatwoot_app.entrypoints=websecure - traefik.http.routers.chatwoot_app.tls.certresolver=letsencryptresolver - traefik.http.routers.chatwoot_app.priority=1 - traefik.http.routers .chatwoot_app.service=chatwoot_app - traefik.http.services.chatwoot_app.loadbalancer.server.port=3000 - traefik.http.services.chatwoot_app.loadbalancer.passhostheader=true - traefik.http.middlewares.sslheader.headers.customrequestheaders.X -Forwarded-Proto=https - traefik.http.routers.chatwoot_app.middlewares=sslheader@docker chatwoot_sidekiq: image: sendingtk/chatwoot-arm:latest command: bundle exec sidekiq -C config/sidekiq.yml volumes: - chatwoot_data:/app /storage ## Directory of conversation files - chatwoot_public_orion:/app ## Directory of all chatwoot networks files: - $nome_rede_interna ## Name of the internal network environment: - CHATWOOT_HUB_URL=https://oriondesign.art.br/setup - INSTALLATION_NAME=$company_name_chatwoot ## Company name - NODE_ENV=production - RAILS_ENV=production - INSTALLATION_ENV=docker - SECRET_KEY_BASE=$encryption_key ## Randomly generated random key - FRONTEND_URL=https://$url_chatwoot ## Chatwoot Url - DEFAULT_LOCALE= pt_BR - FORCE_SSL=true - ENABLE_ACCOUNT_SIGNUP=false ## false = Disable new registrations at the beginning | true = Enable new subscriptions at the beginning - REDIS_URL=redis://redis:6379 - POSTGRES_HOST=postgres - POSTGRES_USERNAME=postgres - POSTGRES_PASSWORD=$password_postgres ## Postgres password - POSTGRES_DATABASE=chatwoot - ACTIVE_STORAGE_SERVICE=local - RAILS_LOG_TO_STDOUT=true - _INBOX_AVATAR_FOR_BOT= true - MAILER_SENDER_EMAIL=$email_admin_chatwoot <$email_admin_chatwoot> ## Email SMTP - SMTP_DOMAIN=$domain_smtp_chatwoot ## Email domain - SMTP_ADDRESS=$smtp_email_chatwoot ## SMTP Host - SMTP_PORT=$porta_smtp_chatwoot ## SMTP Port - SMTP_SSL= $about_ssl ## If port is 465 = true | If the port is 587 = false - SMTP_USERNAME=$email_admin_chatwoot ## SMTP email - SMTP_PASSWORD=$password_email_chatwoot ## SMTP password - SMTP_AUTHENTICATION=login - SMTP_ENABLE_STARTTLS_AUTO=true - SMTP_OPENSSL_VERIFY_MODE=peer - MAILER_INBOUND_EMAIL_DOMAIN=$email_ admin_chatroot ## Email SMTP deploy: mode : replicated replicas:1 placement: constraints: - node.role == manager resources: limits: cpus: "1" memory: 1024M volumes: chatwoot_data: external: true name: chatwoot_data chatwoot_public_orion: external: true name: chatwoot_public_orion networks: $name_rede_interna: ## Name of the internal network external: true name: $internal_network_name ## Name of the internal network EOL if [ $? -eq 0 ]; then echo "1/2 - [ OK ]" else echo "1/2 - [ OFF ]" echo "Unable to create Chatwoot stack" fi docker stack deploy --prune --resolve-image always -c chatwoot. yaml chatwoot > /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to upload Chatwoot stack" fi ## Step Message echo -e "\e[97m• WAITING FOR SERVICE DO CHATWOOT BE READY \e[33m[4/6]\e[0m" echo "" sleep 1 ## Use the wait_chatwoot service to check if the service is online wait_chatwoot ## Step Message echo -e "\e[97m • MIGRATING DATABASE \e[33m[5/6]\e[0m" echo "" sleep 1 ## Here we will be migrating the database using the command "bundle exec rails db:chatwoot_prepare" ## Basically you could enter the chatwoot database and execute the command there also container_name="chatwoot_chatwoot_app" max_wait_time=1200 wait_interval=60 elapsed_time=0 while [ $elapsed_time -lt $max_wait_time ]; do CONTAINER_ID=$(docker ps -q --filter "name=$container_name") if [ -n "$CONTAINER_ID" ]; then break fi sleep $wait_interval elapsed_time=$((elapsed_time + wait_interval)) done if [ -z "$CONTAINER_ID" ]; then echo "The container was not found after $max_wait_time seconds." exit 1 fi docker exec -it "$CONTAINER_ID" bundle exec rails db:chatroot_prepare if [ $? -eq 0 ]; then echo "1/1 - [ OK ]" else echo "1/1 - [ OFF ]" echo "Unable to migrate the database" fi ## Step Message echo -e "\e[97m• ACTIVATING FUNCTIONS FROM SUPER ADMIN \e[33m[6/6]\e[0m" echo "" sleep 1 ## Here we will change some data in postgres to release some hidden functions in the super admin panel wait_for_postgres docker exec -i $CONTAINER_ID psql - U postgres <yaml chatwoot > /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to upload Chatwoot stack" fi ## Step Message echo -e "\e[97m• WAITING FOR SERVICE DO CHATWOOT BE READY \e[33m[4/6]\e[0m" echo "" sleep 1 ## Use the wait_chatwoot service to check if the service is online wait_chatwoot ## Step Message echo -e "\e[97m • MIGRATING DATABASE \e[33m[5/6]\e[0m" echo "" sleep 1 ## Here we will be migrating the database using the command "bundle exec rails db:chatwoot_prepare" ## Basically you could enter the chatwoot database and execute the command there also container_name="chatwoot_chatwoot_app" max_wait_time=1200 wait_interval=60 elapsed_time=0 while [ $elapsed_time -lt $max_wait_time ]; do CONTAINER_ID=$(docker ps -q --filter "name=$container_name") if [ -n "$CONTAINER_ID" ]; then break fi sleep $wait_interval elapsed_time=$((elapsed_time + wait_interval)) done if [ -z "$CONTAINER_ID" ]; then echo "The container was not found after $max_wait_time seconds." exit 1 fi docker exec -it "$CONTAINER_ID" bundle exec rails db:chatroot_prepare if [ $? -eq 0 ]; then echo "1/1 - [ OK ]" else echo "1/1 - [ OFF ]" echo "Unable to migrate the database" fi ## Step Message echo -e "\e[97m• ACTIVATING FUNCTIONS FROM SUPER ADMIN \e[33m[6/6]\e[0m" echo "" sleep 1 ## Here we will change some data in postgres to release some hidden functions in the super admin panel wait_for_postgres docker exec -i $CONTAINER_ID psql - U postgres <yaml chatwoot > /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to upload Chatwoot stack" fi ## Step Message echo -e "\e[97m• WAITING FOR SERVICE DO CHATWOOT BE READY \e[33m[4/6]\e[0m" echo "" sleep 1 ## Use the wait_chatwoot service to check if the service is online wait_chatwoot ## Step Message echo -e "\e[97m • MIGRATING DATABASE \e[33m[5/6]\e[0m" echo "" sleep 1 ## Here we will be migrating the database using the command "bundle exec rails db:chatwoot_prepare" ## Basically you could enter the chatwoot database and execute the command there also container_name="chatwoot_chatwoot_app" max_wait_time=1200 wait_interval=60 elapsed_time=0 while [ $elapsed_time -lt $max_wait_time ]; do CONTAINER_ID=$(docker ps -q --filter "name=$container_name") if [ -n "$CONTAINER_ID" ]; then break fi sleep $wait_interval elapsed_time=$((elapsed_time + wait_interval)) done if [ -z "$CONTAINER_ID" ]; then echo "The container was not found after $max_wait_time seconds." exit 1 fi docker exec -it "$CONTAINER_ID" bundle exec rails db:chatroot_prepare if [ $? -eq 0 ]; then echo "1/1 - [ OK ]" else echo "1/1 - [ OFF ]" echo "Unable to migrate the database" fi ## Step Message echo -e "\e[97m• ACTIVATING FUNCTIONS FROM SUPER ADMIN \e[33m[6/6]\e[0m" echo "" sleep 1 ## Here we will change some data in postgres to release some hidden functions in the super admin panel wait_for_postgres docker exec -i $CONTAINER_ID psql - U postgres <chatwoot_prepare if [ $? -eq 0 ]; then echo "1/1 - [ OK ]" else echo "1/1 - [ OFF ]" echo "Unable to migrate the database" fi ## Step Message echo -e "\e[97m• ACTIVATING FUNCTIONS FROM SUPER ADMIN \e[33m[6/6]\e[0m" echo "" sleep 1 ## Here we will change some data in postgres to release some hidden functions in the super admin panel wait_for_postgres docker exec -i $CONTAINER_ID psql - U postgres <chatwoot_prepare if [ $? -eq 0 ]; then echo "1/1 - [ OK ]" else echo "1/1 - [ OFF ]" echo "Unable to migrate the database" fi ## Step Message echo -e "\e[97m• ACTIVATING FUNCTIONS FROM SUPER ADMIN \e[33m[6/6]\e[0m" echo "" sleep 1 ## Here we will change some data in postgres to release some hidden functions in the super admin panel wait_for_postgres docker exec -i $CONTAINER_ID psql - U postgres <
               
                data_chatroot_arm <
                
                 evolution.yaml <
                 
                  /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to upload Evolution API stack" fi sleep 10 ## Step Message echo -e "\e[97m • CHECKING SERVICE \e[33m[3/3]\e[0m" echo "" sleep 1 ## Uses the wait_evolution service to check if the service is online wait_evolution cd dados_vps cat > dados_evolution <
                  
                   evolution.yaml <
                   
                    /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to upload Evolution API stack" fi sleep 10 ## Step Message echo -e "\e[97m • CHECKING SERVICE \e[33m[3/3]\e[0m" echo "" sleep 1 ## Uses the wait_evolution service to check if the service is online wait_evolution cd dados_vps cat > dados_evolution <
                    
                     Avoid special characters: \!#$ and/or space" echo -en "\e[33mEnter a user for MinIO (ex: OrionDesign): \e[0m" && read -r user_minio echo "" ##Ask Minio for Password echo -e "\e[97mPasso$amarelo 4/4\e[0m" echo -e "$amarelo--> Minimum 8 characters. Use UPPERCASE and lowercase letters, numbers and a special character @ or _" echo -e "$yellow--> Avoid special characters: \!#$" echo -en "\e[33mEnter a password for MinIO (ex: @Senha123_): \e[0m" && read -r minio_password echo "" ## Clean the terminal clear ## Shows the application name minio_name ## Show message to verify information conferring_as_info ## Minio URL Information echo -e "\e[ 33mDomain of MinIO:\e[97m $url_minio\e[0m" echo "" ## Information about URL for S# of Minio echo -e "\e[33mDomain of S3:\e[97m $url_s3\e[0m " echo "" ## Minio User Information echo -e "\e[33mMinIO User:\e[97m $user_minio\e[0m" echo "" ## Minio Password Information echo -e "\e[ 33mMinIO Password:\e[97m $minio_password\e[0m" echo "" ## Asks if the answers are correct read -p "Are the answers correct? (Y/N): " confirmation if [ "$confirmation" = "Y" ] || [ "$confirmation" = "y" ]; then ## Typed Y to confirm that the information is correct ## Clear the terminal clear ## Show Installing message installing_msg ## Exit the Loop break else ## Enter N to say that the information is not correct ## Clear the terminal clear ## Show the name of the tool mini_name ## Show a message to fill in information fill_as_info # # Return to the beginning of the loop with the questions fi done ## Step Message echo -e "\e[97m• STARTING THE MINIO INSTALLATION \e[33m[1/3]\e[0m" echo "" sleep 1 # # NOTHING ## Step Message echo -e "\e[97m• INSTALLING MINIO \e[33m[2/3]\e[0m" echo "" sleep 1 ## Creating the stack cat > minio.yaml <
                     
                      mini_data <
                      
                       If you don't have an email username, use your own email address below" echo -en "\e[33mEnter the User for SMTP (e.g. oriondesign or contato@oriondesign.art.br): \e[0m" && read -r usuario_email_typebot echo "" ## Asks for SMTP password echo -e "\e[97mPasso$amarelo 6/10\e[0m" echo -e "$amarelo--> No special characters: \!#$ | If you are using gmail, use the app password" echo -en "\e[33mEnter the Email SMTP Password (ex: @Password123_): \e[0m" && read -r password_email_typebot echo "" ## Asks the SMTP Host of the email echo -e "\e[97mStep$yellow 7/10\e[0m" echo -en "\e[33mEnter the Email SMTP Host (ex: smtp.hostinger.com): \e[0m" && read - r smtp_email_typebot echo "" ## Asks for the SMTP port of the email echo -e "\e[97mStep$yellow 8/10\e[0m" echo -en "\e[33mEnter the SMTP port of the Email (ex: 465): \e[0m" && read -r porta_smtp_typebot echo "" ## Checks if the port is 465, if yes, leave ssl true, if not, leave false if [ "$porta_smtp_typebot" -eq 465 ]; then smtp_secure_typebot=true else smtp_secure_typebot=false fi ## Asks what is the minio's Access Key echo -e "\e[97mPasso$amarelo 9/10\e[0m" echo -en "\e[33mAccess Key Minio: \e[0m" && read -r S3_ACCESS_KEY echo "" ## Asks what is the minio's Secret Key echo -e "\e[97mPasso$amarelo 10/10\e[0m" echo -en "\e[33mSecret Key Minio: \e[0m" && read -r S3_SECRET_KEY echo "" ## Clears the terminal clear ## Shows the application name typebot_name ## Shows a message to check the information checking_as_info ## Information about the Builder URL echo -e "\e[33mTypebot Builder Domain: \e[97m $url_typebot\e[0m" echo "" ## Viewer URL information echo -e "\e[33mTypebot Viewer domain:\e[97m $url_viewer\e[0m" echo "" ## Information about the tool version echo -e "\e[33mTypebot Version:\e[97m $version_typebot\e[0m" echo "" ## Information about Email echo -e "\e[33mSMTP Email:\e[97m $email_typebot\e[0m" echo "" ## Email Information echo -e "\e[33mSMTP User:\e[97m $usuario_email_typebot\e[0m" echo "" ## Email Password Information echo -e "\e[33mEmail Password:\e[97m $password_email_typebot\e[0m" echo "" ## SMTP Host Information echo -e "\e[33mEmail SMTP Host:\e[97m $smtp_email_typebot\e[0m " echo "" ## Information about SMTP Port echo -e "\e[33mEmail SMTP Port:\e[97m $porta_smtp_typebot\e[0m" echo "" ## Information about Secure SMTP echo -e "\e[33mSecure Email SMTP:\e[97m $smtp_secure_typebot\e[0m" echo "" ## Information about Access Key echo -e "\e[33mAccess Key Minio:\e[97m $S3_ACCESS_KEY\e[0m" echo "" ## Information about Secret Key echo -e "\e[33mSecret Key Minio:\e[97m $S3_SECRET_KEY\e[0m" echo "" ## Asks if the answers are correct read -p "Are the answers correct? (Y/N): " confirmation if [ "$confirmation" = "Y" ] || [ "$confirmation" = "y" ]; then ## Typed Y to confirm that the information is correct ## Clear the terminal clear ## Show Installing message installing_msg ## Exit the Loop break else ## Enter N to say that the information is not correct ## Clear the terminal clear ## Show the name of the tool name_typebot ## Show a message to fill in information fill_as_info # # Returns to the beginning of the loop with the questions fi done ## Step Message echo -e "\e[97m• STARTING TYPEBOT INSTALLATION \e[33m[1/4]\e[0m" echo "" sleep 1 ## Nothing nothing nothing.. only for the step message to appear.. ## Step Message echo -e "\e[97m• CHECKING/INSTALLING POSTGRES \e[33m[2/4]\e[0m" echo " " sleep 1 ## Here we will check if there is already Postgres and redis installed ## If so, it will create a database in Postgres or ask if you want to delete what already exists and create another ## Check postgres container and create database in postgres check_container_postgres if [ $? -eq 0 ]; then pick up_password_postgres > /dev/null 2>&1 create_bank_postgres_typebot #> /dev/null 2>&1 else postgres_tool > /dev/null 2>&1 pick up_postgres_password > /dev/null 2>&1 create_bank_postgres_typebot #> /dev/null 2>&1 fi get_password_minio if [ $? -eq 0 ]; then echo "1/2 - [ OK ]" else echo "1/2 - [ OFF ]" echo "Unable to get the minio's password" fi pega_link_s3 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to get the S3 link" fi ## Step Message echo -e "\e[97m• INSTALLING TYPEBOT \e[33m[3/4]\e[0m" echo "" sleep 1 ## Creating Random key key_typebot=$(openssl rand -hex 16) ## Creating stack cat > typebot.yaml <## Clear terminal clear ## Shows the name of the tool name_typebot ## Shows message to fill in information fill_as_info ## Returns to the beginning of the loop with the questions fi done ## Step Message echo -e "\e[97m• STARTING INSTALLING TYPEBOT \e[33m[1/4]\e[0m" echo "" sleep 1 ## Nothing nothing nothing.. only for the step message to appear.. ## Step Message echo -e "\e [97m• CHECKING/INSTALLING POSTGRES \e[33m[2/4]\e[0m" echo "" sleep 1 ## Here we will check if there is already Postgres and redis installed ## If so, it will create a database data in postgres or ask if you want to delete what already exists and create another ## Check postgres container and create database in postgres verify_container_postgres if [ $? -eq 0 ]; then pick up_password_postgres > /dev/null 2>&1 create_bank_postgres_typebot #> /dev/null 2>&1 else postgres_tool > /dev/null 2>&1 pick up_postgres_password > /dev/null 2>&1 create_bank_postgres_typebot #> /dev/null 2>&1 fi get_password_minio if [ $? -eq 0 ]; then echo "1/2 - [ OK ]" else echo "1/2 - [ OFF ]" echo "Unable to get the minio's password" fi pega_link_s3 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to get the S3 link" fi ## Step Message echo -e "\e[97m• INSTALLING TYPEBOT \e[33m[3/4]\e[0m" echo "" sleep 1 ## Creating Random key key_typebot=$(openssl rand -hex 16) ## Creating stack cat > typebot.yaml <## Clear terminal clear ## Shows the name of the tool name_typebot ## Shows message to fill in information fill_as_info ## Returns to the beginning of the loop with the questions fi done ## Step Message echo -e "\e[97m• STARTING INSTALLING TYPEBOT \e[33m[1/4]\e[0m" echo "" sleep 1 ## Nothing nothing nothing.. only for the step message to appear.. ## Step Message echo -e "\e [97m• CHECKING/INSTALLING POSTGRES \e[33m[2/4]\e[0m" echo "" sleep 1 ## Here we will check if there is already Postgres and redis installed ## If so, it will create a database data in postgres or ask if you want to delete what already exists and create another ## Check postgres container and create database in postgres verify_container_postgres if [ $? -eq 0 ]; then pick up_password_postgres > /dev/null 2>&1 create_bank_postgres_typebot #> /dev/null 2>&1 else postgres_tool > /dev/null 2>&1 pick up_postgres_password > /dev/null 2>&1 create_bank_postgres_typebot #> /dev/null 2>&1 fi get_password_minio if [ $? -eq 0 ]; then echo "1/2 - [ OK ]" else echo "1/2 - [ OFF ]" echo "Unable to get the minio's password" fi pega_link_s3 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to get the S3 link" fi ## Step Message echo -e "\e[97m• INSTALLING TYPEBOT \e[33m[3/4]\e[0m" echo "" sleep 1 ## Creating Random key key_typebot=$(openssl rand -hex 16) ## Creating stack cat > typebot.yaml <
                       
                        <$email_typebot> - SMTP_AUTH_DISABLED=false - SMTP_USERNAME=$user_email_typebot - SMTP_PASSWORD=$password_email_typebot - SMTP_HOST=$smtp_email_typebot - SMTP_PORT=$porta_smtp_typebot - SMTP_SECURE=$smtp_secure_typebot ## Google Cloud data #- CLIENT_ID= #- GOOGLE_CLIENT_SECRET= ## Client data Minio/S3 - S3_ACCESS_KEY=$S3_ACCESS_KEY - S3_SECRET_KEY=$S3_SECRET_KEY - S3_BUCKET=typebot - S3_ENDPOINT=$url_s3 deploy: mode: replicated replicas: 1 placement: constraints: - node.role == manager resources: limits: cpus: "1" memory: 1024M labels: - io.portainer.accesscontrol.users=admin - traefik.enable=true - traefik.http.routers.typebot_builder.rule=Host(\`$url_typebot\`) - traefik.http.routers.typebot_builder. entrypoints=websecure - traefik.http.routers.typebot_builder.tls.certresolver=letsencryptresolver - traefik.http.services.typebot_builder.loadbalancer.server.port=3000 - traefik.http.services.typebot_builder.loadbalancer.passHostHeader=true - traefik. http.routers.typebot_builder.service=typebot_builder ####################################### ##################################### typebot_viewer: image: baptistearno/typebot-viewer:$ version_typebot ## Version of Typebot networks: - $nome_rede_interna ## Name of the internal network environment: ## Postgres data - DATABASE_URL=postgresql://postgres:$senha_postgres@postgres:5432/typebot ## Encryption key - ENCRYPTION_SECRET=$key_typebot ## Standard Plan (for new accounts) - DEFAULT_WORKSPACE_PLAN=UNLIMITED ## Typebot Urls - NEXTAUTH_URL=https://$url_typebot ## URL Builder - NEXT_PUBLIC_VIEWER_URL=https://$url_viewer ## URL Viewer - NEXTAUTH_URL_INTERNAL=http:/ /localhost:3000 ## Disable/activate new registrations - DISABLE_SIGNUP=false ## SMTP data - ADMIN_EMAIL=$email_typebot ## Email SMTP - NEXT_PUBLIC_SMTP_FROM='Support' <$email_typebot> - SMTP_AUTH_DISABLED=false - SMTP_USERNAME=$usuario_email_typebot - SMTP_PASSWORD =$password_email_typebot - SMTP_HOST=$smtp_email_typebot - SMTP_PORT=$porta_smtp_typebot - SMTP_SECURE=$smtp_secure_typebot ## Google Cloud data #- GOOGLE_CLIENT_ID= #- GOOGLE_CLIENT_SECRET= ## Minio/S3 data - S3_ACCESS_KEY=$S3_ACCESS _KEY - S3_SECRET_KEY=$S3_SECRET_KEY - S3_BUCKET =typebot - S3_ENDPOINT=$url_s3 deploy: mode: replicated replicas: 1 placement: constraints: - node.role == manager resources: limits: cpus: "1" memory: 1024M labels: - io.portainer.accesscontrol.users=admin - traefik.enable=true - traefik.http.routers.typebot_viewer.rule=Host(\`$url_viewer\`) - traefik.http.routers.typebot_viewer.entrypoints=websecure - traefik.http.routers.typebot_viewer.tls.certresolver =letsencryptresolver - traefik.http.services.typebot_viewer.loadbalancer.server.port=3000 - traefik.http.services.typebot_viewer.loadbalancer.passHostHeader=true - traefik.http.routers.typebot_viewer.service=typebot_viewer networks: $internal_network_name: # # Internal network name external: true name:$internal_network_name ## Internal network name EOL if [ $? -eq 0 ]; then echo "1/2 - [ OK ]" else echo "1/2 - [ OFF ]" echo "Unable to create the Typebot stack" fi docker stack deploy --prune --resolve-image always -c typebot. yaml typebot > /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to upload Typebot stack" fi ## Step Message echo -e "\e[97m• CHECKING SERVICE \e[33m[4/4]\e[0m" echo "" sleep 1 ## Use the wait_typebot service to check if the service is online wait_typebot cd data_vps cat > data_typebot <
                        
                         /dev/null 2>&1 create_banco_postgres_n8n_queue #> /dev/null 2>&1 else postgres_tool > /dev/null 2>&1 get_postgres_password > /dev/null 2>&1 create_banco_postgres_n8n_queue #> /dev/null 2>&1 fi ## Check If you have redis, if you do, continue, if you don't, install verify_container_redis if [ $? -eq 0 ]; then sleep 1 else tool_redis > /dev/null 2>&1 fi ## Step Message echo -e "\e[97m• INSTALLING N8N \e[33m[3/4]\e[0m" echo "" sleep 1 # # Creating Random key encryption_key=$(openssl rand -hex 16) ## Creating stack cat > n8n.yaml <
                         
                          /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to upload N8N stack" fi ## Step Message echo -e "\e[97m• CHECKING SERVICE \e[33m[4/4]\e[0m" echo "" sleep 1 ## Use the wait_n8n service to check if the service is online wait_n8n cd data_vps cat > data_n8n <
                          
                           Minimum 5 characters. Avoid special characters: \!#$ and/or space" echo -en "\e[33mEnter a user for Flowise (e.g. admin): \e[0m" && read -r user_flowise echo "" ##Question to Password for the tool echo -e "\e[97mPasso$amarelo 3/3\e[0m" echo -e "$amarelo--> Minimum 8 characters. Use UPPERCASE and lowercase letters, numbers and a special character @ or _" echo -e "$yellow--> Avoid special characters: \!#$" echo -en "\e[33mEnter a password for the user (ex: @Password123_): \e[0m" && read -r pass_flowise echo "" ## Clears the terminal clear ## Shows the application name flowise_name ## Shows a message to check the information checking_as_info ## Information about the Flowise URL echo -e "\e[33mFlowise Domain\e[97m $url_flowise\e[0m" echo "" ## Flowise User Information echo -e "\e[33mUser:\e[97m $user_flowise\e[0m" echo " " ## Information about the Flowise User Password echo -e "\e[33mPassword:\e[97m $pass_flowise\e[0m" echo "" ## Asks if the answers are correct read -p "The answers are correct ? (Y/N): " confirmation if [ "$confirmation" = "Y" ] || [ "$confirmation" = "y" ]; then ## Typed Y to confirm that the information is correct ## Clear the terminal clear ## Show Installing message installing_msg ## Exit the Loop break else ## Enter N to say that the information is not correct ## Clear the terminal clear ## Show the name of the tool mini_name ## Show a message to fill in information fill_as_info # # Returns to the beginning of the loop with the questions fi done ## Step Message echo -e "\e[97m• STARTING FLOWISE INSTALLATION \e[33m[1/4]\e[0m" echo "" sleep 1 ## Step Message echo -e "\e[97m• VERIFYING/INSTALLING POSTGRES \e[33m[2/4]\e[0m" echo "" sleep 1 ## You already know, right ksk verify_container_postgres if [ $? 0 ]; then sleep 1 get_password_postgres > /dev/null 2>&1 create_bank_postgres_flowise #> /dev/null 2>&1 else tool_postgres > /dev/null 2>&1 get_password_postgres > /dev/null 2>&1 create_bank_postgres_flowise #> /dev/ null 2>&1 fi ## Step Message echo -e "\e[97m• INSTALLING FLOWISE \e[33m[3/4]\e[0m" echo "" sleep 1 ## Creating a Random Encryption Key encryption_key=$ (openssl rand -hex 16) ## Creating the stack cat > flowise.yaml <
                           
                            /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to Upload Flowise Stack" fi ## Step Message echo -e "\e[97m• CHECKING SERVICE \e[33m[4/4]\e[0m" echo "" sleep 1 ## Use the wait_flowise service to check if the service is online wait_flowise cd dados_vps cat > dados_flowise <
                            
                             Minimum 8 characters. Use UPPERCASE and lowercase letters, numbers and a special character @ or _" echo -e "$yellow--> Avoid special characters: \!#$" echo -en "\e[33mEnter a password for the user (ex: @Password123_): \e[0m" && read -r pass_PgAdmin_4 echo "" ## Clears the terminal clear ## Shows the application name pgAdmin_4 name ## Shows a message to check the information checking_as_info ## Information about the PgAdmin URL echo -e "\e[33mDomain of PgAdmin 4\e[97m $url_PgAdmin_4\e[0m" echo "" ## PgAdmin email information echo -e "\e[33mEmail:\e[97m $user_PgAdmin_4\e[0m" echo "" ## Information about the PgAdmin password echo -e "\e[33mPassword:\e[97m $pass_PgAdmin_4\e[0m" echo "" ## Asks if the answers are correct read -p "Are the answers correct? (Y/N): " confirmation if [ "$confirmation" = "Y" ] || [ "$confirmation" = "y" ]; then ## Typed Y to confirm that the information is correct ## Clear the terminal clear ## Show Installing message installing_msg ## Exit the Loop break else ## Enter N to say that the information is not correct ## Clear the terminal clear ## Show the name of the tool mini_name ## Show a message to fill in information fill_as_info # # Returns to the beginning of the loop with the questions fi done ## Step Message echo -e "\e[97m• STARTING PGADMIN4 INSTALLATION \e[33m[1/3]\e[0m" echo "" sleep 1 ## NOTHING ## Step Message echo -e "\e[97m• INSTALLING PGADMIN4 \e[33m[2/3]\e[0m" echo "" sleep 1 ## Creating the stack cat > pgadmin.yaml <
                             
                              /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to upload PgAdmin 4 stack" fi ## Step Message echo -e "\e[97m• CHECKING SERVICE \e[33m[3/3]\e[0m" echo "" sleep 1 ## Uses the wait_pgadmin_4 service to check if the service is online wait_pgadmin_4 cd data_vps cat > data_pgadmin <
                              
                              Minimum 8 characters. Use UPPERCASE and lowercase letters, numbers and a special character @ or _" echo -e "$yellow--> Avoid special characters: \!#$" echo -en "\e[33mEnter a password for the user (ex: @Password123_): \e[0m" && read -r pass_nocobase echo "" ## Clears the terminal clear ## Shows the application name nocobase_name ## Shows a message to check the information checking_as_info ## Information about the Nocobase URL echo -e "\e[33mNocobase Domain:\e[97m $url_nocobase\e[0m" echo "" ## Nocobase Email Information echo -e "\e[33mEmail:\e[97m $mail_nocobase\e[0m" echo "" ## Nocobase User Information echo -e "\e[33mUser:\e[97m $user_nocobase\e[0m" echo "" ## Nocobase Password Information echo -e "\e[33mPassword:\e [97m $pass_nocobase\e[0m" echo "" ## Asks if the answers are correct read -p "Are the answers correct? (Y/N): " confirmation if [ "$confirmation" = "Y" ] || [ "$confirmation" = "y" ]; then ## Typed Y to confirm that the information is correct ## Clear the terminal clear ## Show Installing message installing_msg ## Exit the Loop break else ## Enter N to say that the information is not correct ## Clear the terminal clear ## Show the name of the tool mini_name ## Show a message to fill in information fill_as_info # # Returns to the beginning of the loop with the questions fi done ## Step Message echo -e "\e[97m• STARTING NOCOBASE INSTALLATION \e[33m[1/4]\e[0m" echo "" sleep 1 ## NOTHING ## Step Message echo -e "\e[97m• CHECKING/INSTALLING POSTGRES \e[33m[2/4]\e[0m" echo "" sleep 1 ## I'm tired of explaining what this does kkkk verify_container_postgres if [ $? -eq 0 ]; then sleep 1 get_postgres_pass > /dev/null 2>&1 create_banco_postgres_nocobase #> /dev/null 2>&1 else postgres_post > /dev/null 2>&1 get_postgres_pass > /dev/null 2 >&1 create_banco_postgres_nocobase #> /dev/null 2>&1 fi ## Step Message echo -e "\e[97m• INSTALLING NOCOBASE \e[33m[3/4]\e[0m" echo "" sleep 1 ## Creating a Random Encryption Key nocobase_key=$(openssl rand -hex 16) ## Creating the stack cat > nocobase.yaml <
                              
                              /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to Upload Nocobase Stack" fi ## Step Message echo -e "\e[97m• CHECKING SERVICE \e[33m[4/4]\e[0m" echo "" sleep 1 ## Use the wait_nocobase service to check if the service is online wait_nocobase cd dados_vps cat > dados_nocobase<
                              
                              /dev/zero $? -eq 0 ]; then sleep 1 else tool_redis > /dev/null 2>&1 fi ## Step Message echo -e "\e[97m• INSTALLING BOTPRESS \e[33m[3/4]\e[0m" echo "" sleep 1 # # Creating the stack cat > botpress.yaml <
                              
                              /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to Upload Botpress Stack" fi ## Step Message echo -e "\e[97m• CHECKING SERVICE \e[33m[4/4]\e[0m" echo "" sleep 1 ## Use the wait_botpress service to check if the service is online wait_botpress cd dados_vps cat > dados_botpress <
                              
                              Use only lowercase letters, no spaces or special characters" echo -en "\e[33mEnter the name of the Site (ex: lojaorion): \e[0m" && read -r name_site_wordpress echo "" ##Treats information name_of_stack_mysql="$ {wordpress_site_name}_mysql.yaml" mysql_stack_name up="${wordpress_site_name}_mysql" wordpress_stack_name="${wordpress_site_name}_wordpress.yaml" wordpress_stack_name}_up="${wordpress_site_name}_wordpress" mysql_service_name="${wordpress_site_name}_mys ql" date_name_mysql="${ wordpress_site_name}_mysql_data" wordpress_service_name="${wordpress_site_name}_wordpress" wordpress_date_name="${wordpress_site_name}_data" wordpress_date_name="${wordpress_site_name}_php" ## Clears the terminal clear ## Shows the application name wordpress_name ## Shows message for check the information by checking_as_info ## Information about Wordpress URL echo -e "\e[33mWordpress Domain:\e[97m $url_wordpress\e[0m" echo "" ## Information about Site Name echo -e "\e[ 33mSite Name:\e[97m $name_site_wordpress\e[0m" echo "" ## Asks if the answers are correct read -p "Are the answers correct? (Y/N): " confirmation if [ "$confirmation" = "Y" ] || [ "$confirmation" = "y" ]; then ## Typed Y to confirm that the information is correct ## Clear the terminal clear ## Show Installing message installing_msg ## Exit the Loop break else ## Enter N to say that the information is not correct ## Clear the terminal clear ## Show the name of the tool mini_name ## Show a message to fill in information fill_as_info # # Returns to the beginning of the loop with the questions fi done ## Step Message echo -e "\e[97m• STARTING WORDPRESS INSTALLATION \e[33m[1/7]\e[0m" echo "" sleep 1 ## NOTHING ## Step Message echo -e "\e[97m• VERIFYING/INSTALLING REDIS \e[33m[2/7]\e[0m" echo "" sleep 1 ## I'm tired of explaining what this does kkkk verify_container_redis if [ $? -eq 0 ]; then sleep 1 else tool_redis > /dev/null 2>&1 fi sleep 3 ## Step Message echo -e "\e[97m• VERIFYING/INSTALLING MYSQL \e[33m[ 3/7]\e[0m" echo "" sleep 1 ## I'm tired of explaining what this does kkkk verify_container_mysql if [ $? -eq 0 ]; then pick up_password_mysql > /dev/null 2>&1 else tool_mysql > /dev/null 2>&1 pick up_password_mysql > /dev/null 2>&1 fi ## Wait 30 seconds wait_30_sec ## Create website database in mysql data create_bank_mysql_wordpress ## Step Message echo -e "\e[97m• INSTALLING WORDPRESS \e[33m[4/7]\e[0m" echo "" sleep 1 ## Creating the stack cat > $stack_name_wordpress <
                              
                              /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to Upload Wordpress Stack" fi ## Step Message echo -e "\e[97m• CHECKING SERVICE \e[33m[5/7]\e[0m" echo "" sleep 1 ## Use the wait_wordpress service to check if the service is online wait_wordpress ## Step Message echo -e "\e[97m• EDITING PHP. INI \e[33m[6/7]\e[0m" echo "" sleep 1 ## Editing PHP.INI cp /var/lib/docker/volumes/$nome_da_date_wordpress_php/_data/php.ini-production /var/ lib/docker/volumes/$name_of_date_wordpress_php/_data/php.ini #path_php_ini="/var/lib/docker/volumes/$name_of_date_wordpress_php/_data/php.ini" path_files_site="/var/lib/docker/volumes/$name_of_date_wordpress_php /_data/php.ini" # sed -i "s/^upload_max_filesize =.*/upload_max_filesize = 1024M/" "$path_php_ini" sed -i "s/^max_execution_time =.*/max_execution_time = 450/" "$path_php_ini" sed -i "s/^memory_limit =.*/memory_limit = 1024M/" "$php_ini_path" cd docker service update --force ${wordpress_service_name}_${wordpress_service_name} docker stack deploy --prune --resolve-image always - c $stack_name_wordpress $stack_name_wordpress_up ## Step Message echo -e "\e[97m• CHECKING SERVICE \e[33m[7/7]\e[0m" echo "" sleep 1 ## Uses the wait_wordpress service to check whether the service is online wait_wordpress cd dados_vps cat > $nome_do_service_wordpress <
                              
                              baserow.yaml <
                              
                              /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to Upload Baserow Stack" fi ## Step Message echo -e "\e[97m• CHECKING SERVICE \e[33m[3/3]\e[0m" echo "" sleep 1 ## Use the wait_baserow service to check if the service is online wait_baserow cd dados_vps cat > dados_baserow <
                              
                              Avoid special characters: @\!#$ and/or space" echo -en "\e[33mEnter the username (ex: oriondesign): \e[0m" && read -r user_mongo echo "" ## Generates the random password pass_mongo=$(openssl rand -hex 16) ## Clears the terminal clear ## Shows the name of the application mongodb_name ## Shows a message to check the information checking_as_info ## User Information echo -e "\e[33mUser:\ e[97m $user_mongo\e[0m" echo "" ## Generated password information echo -e "\e[33mGenerated password:\e[97m $pass_mongo\e[0m" echo "" ## Asks if the answers are correct read -p "Are the answers correct? (Y/N): " confirmation if [ "$confirmation" = "Y" ] || [ "$confirmation" = "y" ]; then ## Typed Y to confirm that the information is correct ## Clear the terminal clear ## Show Installing message installing_msg ## Exit Loop break else ## Entered N to say that the information is not correct ## Clear terminal clear ## Shows the name of the tool mongodb_name ## Shows message to fill in information fill_as_info # # Returns to the beginning of the loop with the questions fi done ## Step Message echo -e "\e[97m• STARTING MONGO DB INSTALLATION \e[33m[1/3]\e[0m" echo "" sleep 1 ## NOTHING NOTHING NOTHING ## Step Message echo -e "\e[97m• INSTALLING MONGO DB \e[33m[2/3]\e[0m" echo "" sleep 1 ## Creating the stack cat > mongodb .yaml <
                              
                              /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to Upload MongoDB Stack" fi ## Step Message echo -e "\e[97m• CHECKING SERVICE \e[33m[3/3]\e[0m" echo "" sleep 1 ## Use the wait_pgadmin_4 service to check if the service is online wait_mongodb cd dados_vps ip_vps=$(curl -s ifconfig.me) cat > dados_mongodb <
                              
                              Avoid special characters: @\!#$ and/or space" echo -en "\e[33mEnter the username (ex: OrionDesign): \e[0m" && read -r user_rabbitmq echo "" ## Generates the random password pass_rabbitmq=$(openssl rand -hex 16) ## Clears the terminal clear ## Shows the application name rabbitmq_name ## Shows a message to check the information checking_as_info ## RabbitMQ Domain Information echo -e "\e[33mDomain RabbitMQ:\e[97m $url_rabbitmq\e[0m" echo "" ## RabbitMQ User Information echo -e "\e[33mUsario:\e[97m $user_rabbitmq\e[0m" echo "" ## Information of RabbitMQ Password echo -e "\e[33mPassword:\e[97m $pass_rabbitmq\e[0m" echo "" ## Asks if the answers are correct read -p "Are the answers correct? (Y/N): " confirmation if [ "$confirmation" = "Y" ] || [ "$confirmation" = "y" ]; then ## Typed Y to confirm that the information is correct ## Clear the terminal clear ## Show Installing message installing_msg ## Exit Loop break else ## Entered N to say that the information is not correct ## Clear terminal clear ## Shows the name of the tool rabbitmq_name ## Shows message to fill in information fill_as_info # # Returns to the beginning of the loop with the questions fi done ## Step Message echo -e "\e[97m• STARTING RABBITMQ INSTALLATION \e[33m[1/3]\e[0m" echo "" sleep 1 ## Step Message echo -e "\e[97m• INSTALLING RABBITMQ \e[33m[2/3]\e[0m" echo "" sleep 1 #Random key cookie key_cookie=$(openssl rand -hex 16) # # Creating the stack cat > rabbitmq.yaml <
                              
                              /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to Upload RabbitMQ Stack" fi ## Step Message echo -e "\e[97m• CHECKING SERVICE \e[33m[3/3]\e[0m" echo "" sleep 1 ## Use the wait_pgadmin_4 service to check if the service is online wait_rabbitmq cd data_vps ip_vps=$(curl -s ifconfig.me) cat > data_rabbitmq <
                              
                              uptimekuma.yaml <
                              
                              /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to Upload Kuma Uptime Stack" fi ## Step Message echo -e "\e[97m• CHECKING SERVICE \e[33m[3/3]\e[0m" echo "" sleep 1 ## Uses the wait_pgadmin_4 service to check if the service is online wait_uptimekuma cd dados_vps ip_vps=$(curl -s ifconfig.me) cat > dados_uptimekuma <
                              
                              No special characters: \!#$ | If you are using gmail, use the app password" echo -en "\e[33mEnter the SMTP Email Password (ex: @Password123_): \e[0m" && read -r password_email_calcom echo "" ## Asks the SMTP Host of email echo -e "\e[97mStep$yellow 4/5\e[0m" echo -en "\e[33mEnter the Email SMTP Host (ex: smtp.hostinger.com): \e[0m" && read - r smtp_email_calcom echo "" ## Asks for the SMTP port of the email echo -e "\e[97mStep$yellow 5/5\e[0m" echo -en "\e[33mEnter the SMTP port of the Email (ex: 465): \e[0m" && read -r porta_smtp_calcom echo "" ## Clears the terminal clear ## Shows the name of the application chat_name ## Shows a message to check the information checking_as_info ## Information about URL echo -e "\e[33mDomain of Cal.com\e[97m $url_calcom\e[0m" echo "" ## SMTP Email Information echo -e "\e[33mEmail SMTP:\e[97m $email_calcom\e[0m" echo "" ## Information about SMTP Password echo -e "\e[33mSMTPPassword:\e[97m $password_email_calcom\e[0m" echo "" ## Information about SMTP Host echo -e "\e[33mSMTPHost:\e[97m $smtp_email_calcom\ e[0m" echo "" ## SMTP Port Information echo -e "\e[33mSMTP Port:\e[97m $porta_smtp_calcom\e[0m" echo "" ## Asks if the answers are correct read -p "As Are answers correct? (Y/N): " confirmation if [ "$confirmation" = "Y" ] || [ "$confirmation" = "y" ]; then ## Typed Y to confirm that the information is correct ## Clear the terminal clear ## Show Installing message installing_msg ## Exit Loop break else ## Entered N to say that the information is not correct ## Clear terminal clear ## Shows the name of the tool name_calcom ## Shows message to fill in information fill_as_info # # Returns to the beginning of the loop with the questions fi done ## Step Message echo -e "\e[97m• STARTING CALCOM INSTALLATION \e[33m[1/4]\e[0m" echo "" sleep 1 ## Step Message echo -e "\e[97m• CHECKING/INSTALLING POSTGRES \e[33m[2/4]\e[0m" echo "" sleep 1 verify_container_postgres if [ $? get_password_postgres > /dev/null 2>&1 create_banco_postgres_calcom #> /dev/null 2>&1 else postgres_tool > /dev/null 2>&1 get_password_postgres > /dev/null 2>&1 create_banco_postgres_calcom #> /dev/null 2>&1 fi # # Step Message echo -e "\e[97m• INSTALLING CAL.COM \e[33m[3/4]\e[0m" echo "" sleep 1 ## Creating random key secret=$(openssl rand -hex 16 ) ## Creating the stack cat > calcom.yaml <
                              
                              /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to upload CalCom stack" fi ## Step Message echo -e "\e[97m• CHECKING SERVICE \e[33m[4/4]\e[0m" echo "" sleep 1 ## Use the wait_calcom service to check if the service is online wait_calcom cd dados_vps cat > dados_calcom <
                              
                              No special characters: \!#$ and/or spaces" echo -en "\e[33mEnter a user (ex: OrionDesign): \e[0m" && read -r user_mautic echo "" ## Asks for the echo tool's email -e "\e[97mPasso$amarelo 3/4\e[0m" echo -en "\e[33mEnter admin email: (ex: contato@oriondesign.art.br): \e[0m" && read - r email_mautic echo "" ## Asks for the tool's password echo -e "\e[97mStep$yellow 4/4\e[0m" echo -e "$yellow--> No special characters: \!#$" echo - en "\e[33mEnter a Password (ex: @Password123_): \e[0m" && read -r password_email_mautic echo "" ## Clears the terminal clear ## Shows the name of the application mautic_name ## Shows a message to verify the information conferring_as_info ## Information about URL echo -e "\e[33mMautic Domain:\e[97m $url_mautic\e[0m" echo "" ## Information about Admin User echo -e "\e[33mAdmin User:\e[ 97m $user_mautic\e[0m" echo "" ## Admin Email Information echo -e "\e[33mAdmin Email:\e[97m $email_mautic\e[0m" echo "" ## Admin Password Information echo - and "\e[33mAdmin Password:\e[97m $password_email_mautic\e[0m" echo "" ## Asks if the answers are correct read -p "Are the answers correct? (Y/N): " confirmation if [ "$confirmation" = "Y" ] || [ "$confirmation" = "y" ]; then ## Typed Y to confirm that the information is correct ## Clear the terminal clear ## Show Installing message installing_msg ## Exit Loop break else ## Entered N to say that the information is not correct ## Clear terminal clear ## Shows the name of the tool mautic_name ## Shows message to fill in information fill_as_info # # Returns to the beginning of the loop with the questions fi done ## Step Message echo -e "\e[97m• STARTING THE MAUTIC INSTALLATION \e[33m[1/4]\e[0m" echo "" sleep 1 ## Step Message echo -e "\e[97m• ERIFYING/INSTALLING MYSQL \e[33m[2/4]\e[0m" echo "" sleep 1 data verify_container_mysql if [ $? -eq 0 ]; > /dev/null 2>&1 create_bank_mysql_mautic else tool_mysql > /dev/null 2>&1 get_password_mysql > /dev/null 2>&1 create_bank_mysql_mautic fi ## Wait 30 seconds wait_30_sec ## Step Message echo -e "\e[97m• INSTALLING MAUTIC \e[33m[3/4]\e[0m" echo "" sleep 1 ## Creating the stack cat > mautic.yaml <
                              
                              /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to upload Mautic stack" fi ## Step Message echo -e "\e[97m• CHECKING SERVICE \e[33m[4/4]\e[0m" echo "" sleep 1 ## Use the wait_calcom service to check if the service is online wait_mautic cd data_vps cat > data_mautic <
                              
                              appsmith.yaml <
                              
                              /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to Upload Appsmith Stack" fi ## Step Message echo -e "\e[97m• CHECKING SERVICE \e[33m[3/3]\e[0m" echo "" sleep 1 ## Use the wait_nocobase service to check if the service is online wait_appsmith cd dados_vps cat > dados_appsmith <
                              
                              qdrant.yaml <<-EOF version: "3.7" services: EOF for ((node=0; node
                              
                              > qdrant.yaml <<-EOF $SERVICE_NAME: image: qdrant/qdrant:latest volumes: - qdrant_data:/qdrant command: $COMMAND restart: always environment: - QDRANT__SERVICE__GRPC_PORT=6334 - QDRANT__CLUSTER__ENABLED=true - QDRANT__CLUSTER__P2P__PORT=6335 - QDRANT__CLUSTER__CONSENSUS__MAX_ MESSAGE_QUEUE_SIZE=5000 - QDRANT__LOG_LEVEL=debug,raft=info ports: - "$HTTP_PORT:6333" - "$GRPC_PORT:6334" deploy: resources: limits: cpus: "0.3" EOF cat > qdrant.yaml <<-EOF volumes: qdrant_data: external : true name: qdrant_data EOF done if [ $? -eq 0 ]; then echo "1/2 - [ OK ]" else echo "1/2 - [ OFF ]" echo "Unable to create Qdrant stack" fi docker stack deploy --prune --resolve-image always -c qdrant. yaml qdrant > /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to Upload Qdrant Stack" fi ## Step Message echo -e "\e[97m• CHECKING SERVICE \e[33m[3/3]\e[0m" echo "" sleep 1 ## Use the wait_nocobase service to check if the service is online wait_qdrant cd dados_vps cat > dados_qdrant <
                              
                              Avoid special characters: @\!#$ and/or space" echo -en "\e[33mEnter the ENGINE User (ex: oriondesign): \e[0m" && read -r email_admin_woofed echo "" ## Question name of the Engine Password echo -e "\e[97mStep$yellow 4/4\e[0m" echo -e "$yellow--> Avoid special characters: \!#$ and/or space" echo -en " \e[33mEnter the ENGINE Password (ex: @Password123_): \e[0m" && read -r password_email_woofed echo "" ## Clears the terminal clear ## Shows the name of the application rabbit_name ## Shows a message to verify the information conferring_as_info ## Information about the domain echo -e "\e[33mDomain:\e[97m $url_woofed\e[0m" echo "" ## Information about the version echo -e "\e[33mVersão:\e[97m $ v_woofed\e[0m" echo "" ## User information echo -e "\e[33mUser MOTOR:\e[97m $email_admin_woofed\e[0m" echo "" ## Password information echo -e "\ e[33mPassword ENGINE:\e[97m $senha_email_woofed\e[0m" echo "" ## Asks if the answers are correct read -p "Are the answers correct? (Y/N): " confirmation if [ "$confirmation" = "Y" ] || [ "$confirmation" = "y" ]; then ## Typed Y to confirm that the information is correct ## Clear the terminal clear ## Show Installing message installing_msg ## Exit Loop break else ## Entered N to say that the information is not correct ## Clear terminal clear ## Shows the name of the tool woofedcrm_name ## Shows message to fill in information fill_as_info # # Returns to the beginning of the loop with the questions fi done ## Step Message echo -e "\e[97m• STARTING WOOFED CRM INSTALLATION \e[33m[1/7]\e[0m" echo "" sleep 1 ## Step Message echo -e "\e[97m• CHECKING/INSTALLING POSTGRES \e[33m[2/7]\e[0m" echo "" sleep 1 data verify_container_postgres if [ $? repeat &1 fi sleep 5 ## Step Message echo -e "\e[97m• VERIFYING/INSTALLING REDIS \e[33m[3/7]\e[0m" echo "" verify_container_redis if [ $? -eq 0 ]; then echo "" else tool_redis > /dev/null 2>&1 fi ## Step Message echo -e "\e[97m• INSTALLING WOOFED CRM \e[33m[4/7]\e[0m" echo "" sleep 1 ## Creating a Random Encryption Key encryption_key_woofed=$(openssl rand -hex 16) ## Creating the stack cat > woofedcrm.yaml <
                              
                              /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to Upload WoofedCRM Stack" fi ## Step Message echo -e "\e[97m• CHECKING SERVICE \e[33m[5/7]\e[0m" wait_30_sec echo "" sleep 1 ## Use the wait_woofedrm service to check if the service is online wait_woofedcrm ## Step Message echo -e "\e[97m• CONFIGURING AND MIGRATING DATABASE \e[33m[6/7]\e[0m" echo "" sleep 1 #MIGRATING DATABASE FROM WOOFED CRM container_name=" woofedcrm_woofedcrm" max_wait_time=1200 wait_interval=60 elapsed_time=0 while [ $elapsed_time - lt $max_wait_time ]; do CONTAINER_ID=$(docker ps -q --filter "name=$container_name") if [ -n "$CONTAINER_ID" ]; then break fi sleep $wait_interval elapsed_time=$((elapsed_time + wait_interval)) done if [ -z "$CONTAINER_ID" ]; then echo "The container was not found after $max_wait_time seconds." exit 1 fi docker exec -it "$CONTAINER_ID" bundle exec rails db:create docker exec -it "$CONTAINER_ID" bundle exec rails db:migrate #docker exec -it "$CONTAINER_ID" bundle exec rails db:seed ## Message from Step echo -e "\e[97m• CHECKING SERVICE \e[33m[7/7]\e[0m" echo "" sleep 1 ## Use the wait_woofedrm service to check if the service is online wait_woofedcrm cd dados_vps cat > dados_woofedcrm <
                              
                              No special characters: \!#$ | If you are using gmail, use the app password" echo -en "\e[33mEnter the email's SMTP Password (ex: @Password123_): \e[0m" && read -r password_formbricks echo "" ## Ask the SMTP Host echo -e "\e[97mStep$yellow 4/5\e[0m" echo -en "\e[33mEnter the SMTP Host of the email (ex: smtp.hostinger.com): \e[0m" && read -r host_formbricks echo "" ## Ask for SMTP Port echo -e "\e[97mStep$yellow 5/5\e[0m" echo -en "\e[33mEnter the SMTP Port of the email (ex: 465): \e[0m " && read -r porta_formbricks echo "" if [ "$porta_formbricks" -eq 465 ] || [ "$porta_formbricks" -eq 25 ]; then ssl_formbricks=1 else ssl_formbricks=0 fi ## Clears the terminal clear ## Shows the application name formbricks_name ## Shows message to check the information checking_as_info ## Information about URL echo -e "\e[33mDomain:\e[97m $url_formbricks\e[0m" echo "" ## Information about Email echo -e " \e[33mEmail SMTP:\e[97m $email_formbricks\e[0m" echo "" ## Password Information echo -e "\e[33mSMTP Password:\e[97m $password_formbricks\e[0m" echo "" # # Host Information echo -e "\e[33mHost SMTP:\e[97m $host_formbricks\e[0m" echo "" ## Port Information echo -e "\e[33mSMTP Port:\e[97m $port_formbricks\ e[0m" echo "" ## Asks if the answers are correct read -p "Are the answers correct? (Y/N): " confirmation if [ "$confirmation" = "Y" ] || [ "$confirmation" = "y" ]; then ## Typed Y to confirm that the information is correct ## Clear the terminal clear ## Show Installing message installing_msg ## Exit Loop break else ## Entered N to say that the information is not correct ## Clear terminal clear ## Shows the name of the tool name_formbricks ## Shows message to fill in information fill_as_info # # Returns to the beginning of the loop with the questions fi done ## Step Message echo -e "\e[97m• STARTING FORMBRICKS INSTALLATION \e[33m[1/4]\e[0m" echo "" sleep 1 ## Nothing nothing nothing... just for the step message to appear...## Step Message echo -e "\e[97m• CHECKING/INSTALLING POSTGRES \e[33m[2/4]\e[0m" echo "" sleep 1 verify_container_postgres if [ $? -eq 0 ]; then sleep 1 create_banco_postgres_formbricks #> /dev/null 2>&1 get_password_postgres > /dev/null 2>&1 else postgres_tool > /dev/null 2>&1 get_password_postgres > /dev/null 2>&1 create_bank_postgres_formbricks #> /dev/null 2> &1 fi ## Step Message echo -e "\e[97m• INSTALLING FORMBRICKS \e[33m[3/4]\e[0m" echo "" sleep 1 ## Generates random keys encryption_key_form=$(openssl rand -hex 16) next_key_form=$(openssl rand -hex 16) cron_key_form=$(openssl rand -hex 16) ## Creating the stack cat > formbricks.yaml <<-EOF version: "3.7" services: formbricks: image: formbricks/formbricks :latest networks: - $nome_rede_interna volumes: - formbricks_data:/home/nextjs/apps/web/uploads/ environment: ## Application url ## - WEBAPP_URL=https://$url_formbricks - NEXTAUTH_URL=https://$url_formbricks ## Postgres database ## - DATABASE_URL=postgresql://postgres:$senha_postgres@postgres:5432/formbricks ## Enterprise or Self-hosting license ## ## Request Self-hosting license --> https://oriondesign .art.br/formbricks_licence/ <-- ## - ENTERPRISE_LICENSE_KEY= ## Random keys 32 characters ## - ENCRYPTION_KEY=$encryption_key_form - NEXTAUTH_SECRET=$next_key_form - CRON_SECRET=$cron_key_form ## SMTP data ## - MAIL_FROM=$email_formbricks - SMTP_HOST=$host_formbricks - SMTP_PORT=$porta_formbricks - SMTP_SECURE_ENABLED=$ssl_formbricks #(0= false | 1= true) - SMTP_USER=$email_formbricks - SMTP_PASSWORD=$senha_formbricks ## Enable/Disable registrations and invitations (0= false | 1= true) ## - SIGNUP_DISABLED=0 - INVITE_DISABLED=0 - EMAIL_VERIFICATION_DISABLED=0 - PASSWORD_RESET_DISABLED=0 # # Formbricks data (for search) ## - NEXT_PUBLIC_FORMBRICKS_API_HOST= - NEXT_PUBLIC_FORMBRICKS_ENVIRONMENT_ID= - NEXT_PUBLIC_FORMBRICKS_ONBOARDING_SURVEY_ID= ## Google Cloud Login ## - GOOGLE_AUTH_ENABLED=0 - GOOGLE_CLIENT_ID= - GOOGLE_CLIENT_SEC RET= ## Google Sheets ## - GOOGLE_SHEETS_CLIENT_ID= - GOOGLE_SHEETS_CLIENT_SECRET= - GOOGLE_SHEETS_REDIRECT_URL = ## Github Login ## - GITHUB_AUTH_ENABLED=0 - GITHUB_ID= - GITHUB_SECRET= ## Github Login ## - NOTION_OAUTH_CLIENT_ID= - NOTION_OAUTH_CLIENT_SECRET= ## Airtable Login ## - AIRTABLE_CLIENT_ID= ## Terms and privacy policy ## #- PRIVACY_URL = #- TERMS_URL= #- IMPRINT_URL= deploy: mode: replicated replicas: 1 placement: constraints: - node.role == manager resources: limits: cpus: "1" memory: 1024M labels: - traefik.enable=true - traefik .http.routers.formbricks.rule=Host(\`$url_formbricks\`) - traefik.http.services.formbricks.loadbalancer.server.port=3000 - traefik.http.routers.formbricks.service=formbricks - traefik.http .routers.formbricks.tls.certresolver=letsencryptresolver - traefik.http.routers.formbricks.entrypoints=websecure - traefik.http.routers.formbricks.tls=true networks: $internal_network_name: name: $internal_network_name external: true volumes: formbricks_data: external: true EOF if [ $? -eq 0 ]; then echo "1/2 - [ OK ]" else echo "1/2 - [ OFF ]" echo "Unable to create the Formbricks stack" fi docker stack deploy --prune --resolve-image always -c formbricks. yaml formbricks > /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to upload Formbricks stack" fi ## Step Message echo -e "\e[97m• CHECKING SERVICE \e[33m[4/4]\e[0m" echo "" sleep 1 ## Use the wait_formbricks service to check if the service is online wait_formbricks cd data_vps cat > data_formbricks <
                              
                              /dev/zero Step echo -e "\e[97m• INSTALLING NOCODB \e[33m[3/4]\e[0m" echo "" sleep 1 ## Creating the stack cat > nocodb.yaml <
                              
                              /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to Upload NocoDB Stack" fi ## Step Message echo -e "\e[97m• CHECKING SERVICE \e[33m[4/4]\e[0m" echo "" sleep 1 ## Use the wait_nocodb service to check if the service is online wait_nocodb cd data_vps cat > data_nocodb <
                              
                              /dev/null 2>&1 create_bank_postgres_langfuse #> /dev/null 2>&1 else postgres_tool > /dev/null 2>&1 get_postgres_password > /dev/null 2>&1 create_bank_postgres_langfuse #> /dev/null 2>&1 fi ## Message Step echo -e "\e[97m• INSTALLING LANGFUSE \e[33m[3/4]\e[0m" echo "" sleep 1 ## Creating Random key 64 characters key_secret=$(openssl rand -hex 32) ## Creating Random key 32 characters key_salt=$(openssl rand -hex 16) ## Creating stack cat > langfuse.yaml <
                              
                              /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to upload langfuse stack" fi ## Step Message echo -e "\e[97m• CHECKING SERVICE \e[33m[4/4]\e[0m" echo "" sleep 1 ## Use the wait_langfuse service to check if the service is online wait_langfuse cd dados_vps cat > dados_langfuse <
                              
                              /dev/null 2>&1 create_bank_postgres_metabase #> /dev/null 2>&1 else postgres_tool > /dev/null 2>&1 get_postgres_password > /dev/null 2>&1 create_bank_postgres_metabase #> /dev/null 2>&1 fi ## Message Step echo -e "\e[97m• INSTALLING METABASE \e[33m[3/4]\e[0m" echo "" sleep 1 ## Creating Random key 64 characters key_secret=$(openssl rand -hex 32) ## Creating Random key 32 characters key_salt=$(openssl rand -hex 16) ## Creating stack cat > metabase.yaml <
                              
                              /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to upload metabase stack" fi ## Step Message echo -e "\e[97m• CHECKING SERVICE \e[33m[4/4]\e[0m" echo "" sleep 1 ## Use the wait_metabase service to check if the service is online wait_metabase cd dados_vps cat > dados_metabase <
                              
                              odoo.yaml <
                              
                              /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to Upload Odoo Stack" fi ## Step Message echo -e "\e[97m• CHECKING SERVICE \e[33m[3/3]\e[0m" echo "" sleep 1 ## Use the wait_odoo service to check if the service is online wait_odoo cd dados_vps cat > dados_odoo <
                              
                              No special characters: \!#$ | If you are using gmail, use the app password" echo -en "\e[33mEnter the Email SMTP Password (ex: @Password123_): \e[0m" && read -r password_email_chatwoot echo "" ## Asks the SMTP Host of email echo -e "\e[97mStep$yellow 4/5\e[0m" echo -en "\e[33mEnter the Email SMTP Host (ex: smtp.hostinger.com): \e[0m" && read - r smtp_email_chatwoot echo "" ## Asks for the SMTP port of the email echo -e "\e[97mStep$yellow 5/5\e[0m" echo -en "\e[33mEnter the SMTP port of the Email (ex: 465): \e[0m" && read -r porta_smtp_chatwoot ## Checks if the port is 465, if yes, leave ssl true, if not, leave false if [ "$porta_smtp_chatwoot" -eq 465 ]; then sobre_ssl=true else sobre_ssl=false fi ## Clears the terminal clear ## Shows the name of the application chat_name ## Shows a message to check the information checking_as_info ## Information about URL echo -e "\e[33mChatwoot Domain:\e[97m $url_chatwoot\e[0m " echo "" ## Company Name Information echo -e "\e[33mCompany Name:\e[97m $chatroot_company_name\e[0m" echo "" ## SMTP Email Information echo -e "\e[ 33mSMTP Email:\e[97m $email_admin_chatwoot\e[0m" echo "" ## SMTP Password Information echo -e "\e[33mSMTP Password:\e[97m $password_email_chatroot\e[0m" echo "" ## SMTP Host Information echo -e "\e[33mSMTPHost:\e[97m $smtp_email_chatroot\e[0m" echo "" ## SMTP Port Information echo -e "\e[33mSMTP Port:\e[97m $porta_smtp_chatroot\e[0m" echo "" echo "" ## Asks if the answers are correct read -p "Are the answers correct? (Y/N): " confirmation if [ "$confirmation" = "Y" ] || [ "$confirmation" = "y" ]; then ## Typed Y to confirm that the information is correct ## Clear the terminal clear ## Show Installing message installing_msg ## Exit Loop break else ## You typed N to say that the information is not correct.## Clear terminal clear ## Shows the name of the tool chat_name ## Shows message to fill in information fill_as_info ## Returns to the beginning of the loop with the questions fi done ## Step Message echo -e "\e[97m• STARTING CLAIRTON CHATWOOT INSTALLATION \e[33m[1/6]\e[0m" echo "" sleep 1 ## Activates the data function to get data from the vps data ## Step Message echo -e "\e[97m • CHECKING/INSTALLING POSTGRES AND REDIS \e[33m[2/6]\e[0m" echo "" sleep 1 ## Here we will check if Postgres and Redis are already installed ## If so, it will create a database data in postgres or ask if you want to delete what already exists and create another ## Check postgres container and create database in postgres verify_container_postgres if [ $? -eq 0 ]; then pick up_password_postgres > /dev/null 2>&1 create_banco_postgres_chatwoot_uno else postgres_tool > /dev/null 2>&1 pick up_password_postgres > /dev/null 2>&1 create_bank_postgres_chatroot_uno fi if [ $? -eq 0 ]; then echo "1/2 - [ OK ]" else echo "1/2 - [ OFF ]" fi ## Check redis container check_container_redis if [ $? -eq 0 ]; then echo "" else redis_tool > /dev/null 2>&1 fi if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" fi ## Step Message echo -e "\e[97m• INSTALLING CHATWOOT CLAIRTON \e[33m[3/6]\ e[0m" echo "" sleep 1 ## In this step we will be creating the Chatwoot Stack yaml in the /root/ folder ## This will allow the user to edit it later ## Then we will install Chatwoot and check if everything is OK right. ## Creating random key encryption_key=$(openssl rand -hex 16) ## Creating stack cat > chatwoot_uno.yaml <
                              
                              <$email_admin_chatwoot> ## Email SMTP - SMTP_DOMAIN=$domain_smtp_chatwoot ## Email domain - SMTP_ADDRESS=$smtp_email_chatwoot ## Host SMTP - SMTP_PORT=$porta_smtp_chatwoot ## SMTP port - SMTP_SSL=$about_ssl ## If the port is 465 = true | If the port is 587 = false - SMTP_USERNAME=$email_admin_chatwoot ## SMTP email - SMTP_PASSWORD=$password_email_chatwoot ## SMTP password - SMTP_AUTHENTICATION=login - SMTP_ENABLE_STARTTLS_AUTO=true - SMTP_OPENSSL_VERIFY_MODE=peer - MAILER_INBOUND_EMAIL_DOMAIN=$email_ admin_chatroot ## Email SMTP deploy: mode : replicated replicas: 1 placement: constraints: - node.role == manager resources: limits: cpus: "1" memory: 1024M labels: - traefik.enable=true - traefik.http.routers.chatwoot_uno_app.rule=Host(\ `$url_chatwoot\`) - traefik.http.routers.chatwoot_uno_app.entrypoints=websecure - traefik.http.routers.chatwoot_uno_app.tls.certresolver=letsencryptresolver - traefik.http.routers.chatwoot_uno_app.priority=1 - traefik.http.routers .chatwoot_uno_app.service=chatwoot_uno_app - traefik.http.services.chatwoot_uno_app.loadbalancer.server.port=3000 - traefik.http.services.chatwoot_uno_app.loadbalancer.passhostheader=true - traefik.http.middlewares.sslheader.headers.customrequestheaders.X -Forwarded-Proto=https - traefik.http.routers.chatwoot_uno_app.middlewares=sslheader@docker chatwoot_uno_sidekiq: image: clairton/chatwoot:v3.6.1-uno command: bundle exec sidekiq -C config/sidekiq.yml volumes: - chatwoot_uno_data: /app/storage ## Directory of conversation files - chatwoot_uno_public_orion:/app ## Directory of all chatwoot networks files: - $nome_rede_interna ## Name of the internal network environment: - CHATWOOT_HUB_URL=https://oriondesign.art.br /setup# - INSTALLATION_NAME=$company_name_chatwoot ## Company name - NODE_ENV=production - RAILS_ENV=production - INSTALLATION_ENV=docker - SECRET_KEY_BASE=$encryption_key ## Random randomly generated key - FRONTEND_URL=https://$url_chatwoot ## Chatwoot Url - DEFAULT_LOCALE=pt_BR - FORCE_SSL=true - ENABLE_ACCOUNT_SIGNUP=false ## false = Disable new registrations at the beginning | true = Enable new subscriptions at the beginning - REDIS_URL=redis://redis:6379 - POSTGRES_HOST=postgres - POSTGRES_USERNAME=postgres - POSTGRES_PASSWORD=$password_postgres ## Postgres password - POSTGRES_DATABASE=chatwoot_uno - ACTIVE_STORAGE_SERVICE=local - RAILS_LOG_TO_STDOUT=true - USE_INBOX_AVATAR_FOR_BOT=true MAILER_ SENDER_EMAIL=$email_admin_chatroot <$email_admin_chatroot> ## Email SMTP - SMTP_DOMAIN =$domain_smtp_chatwoot ## Email domain - SMTP_ADDRESS=$smtp_email_chatwoot ## SMTP host - SMTP_PORT=$porta_smtp_chatwoot ## SMTP port - SMTP_SSL=$about_ssl ## If the port is 465 = true | If the port is 587 = false - SMTP_USERNAME=$email_admin_chatwoot ## SMTP email - SMTP_PASSWORD=$password_email_chatwoot ## SMTP password - SMTP_AUTHENTICATION=login - SMTP_ENABLE_STARTTLS_AUTO=true - SMTP_OPENSSL_VERIFY_MODE=peer - MAILER_INBOUND_EMAIL_DOMAIN=$email_ admin_chatroot ## Email SMTP deploy: mode : replicated replicas: 1 placement: constraints: - node.role == manager resources: limits: cpus: "1" memory: 1024M volumes: chatwoot_uno_data: external: true name: chatwoot_uno_data chatwoot_uno_public_orion: external: true name: chatwoot_uno_public_orion networks: $nome_rede_interna : ## Internal network name external: true name: $internal_network_name ## Internal network name EOL if [ $? -eq 0 ]; then echo "1/2 - [ OK ]" else echo "1/2 - [ OFF ]" echo "Unable to create Chatwoot stack" fi docker stack deploy --prune --resolve-image always -c chatwoot_uno. yaml chatwoot_uno > /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to upload Chatwoot stack" fi ## Step Message echo -e "\e[97m• WAITING FOR SERVICE DO CHATWOOT BE READY \e[33m[4/6]\e[0m" echo "" sleep 1 ## Use the wait_chatwoot service to check if the service is online wait_chatwoot_uno ## Step Message echo -e "\e[97m • RESTART CHATWOOT \e[33m[5/6]\e[0m" echo "" sleep 1 ## Here we will be migrating the database using the command "bundle exec rails db:chatwoot_prepare" ## Basically you could enter the chatwoot database and run the command there too container_name="chatwoot_uno_chatwoot_uno_app" max_wait_time=1200 wait_interval=60 elapsed_time=0 while [ $elapsed_time -lt $max_wait_time ]; do CONTAINER_ID=$(docker ps -q --filter "name=$container_name") if [ -n "$CONTAINER_ID" ]; then break fi sleep $wait_interval elapsed_time=$((elapsed_time + wait_interval)) done if [ -z "$CONTAINER_ID" ]; then echo "The container was not found after $max_wait_time seconds." exit 1 fi docker exec -it "$CONTAINER_ID" bundle exec rails db:chatwoot_prepare if [ $? -eq 0 ]; then echo "1/1 - [ OK ]" else echo "1/1 - [ OFF ]" echo "Unable to migrate the database" fi ## Step Message echo -e "\e[97m• ACTIVATING FUNCTIONS FROM SUPER ADMIN \e[33m[6/6]\e[0m" echo "" sleep 1 ## Here we will change some data in postgres to release some hidden functions in the super admin panel wait_for_postgres docker exec -i $CONTAINER_ID psql - U postgres <
                              
                              data_chatroot_uno <
                              
                              No special characters: \!#$ | If you are using gmail, use the app password" echo -en "\e[33mEnter the Email SMTP Password (ex: @Password123_): \e[0m" && read -r password_email_chatwoot echo "" ## Asks the SMTP Host of email echo -e "\e[97mStep$yellow 4/5\e[0m" echo -en "\e[33mEnter the Email SMTP Host (ex: smtp.hostinger.com): \e[0m" && read - r smtp_email_chatwoot echo "" ## Asks for the SMTP port of the email echo -e "\e[97mStep$yellow 5/5\e[0m" echo -en "\e[33mEnter the SMTP port of the Email (ex: 465): \e[0m" && read -r porta_smtp_chatwoot ## Checks if the port is 465, if yes, leave ssl true, if not, leave false if [ "$porta_smtp_chatwoot" -eq 465 ]; then sobre_ssl=true else sobre_ssl=false fi ## Clears the terminal clear ## Shows the name of the application chat_name ## Shows a message to check the information checking_as_info ## Information about URL echo -e "\e[33mChatwoot Domain:\e[97m $url_chatwoot\e[0m " echo "" ## Company Name Information echo -e "\e[33mCompany Name:\e[97m $chatroot_company_name\e[0m" echo "" ## SMTP Email Information echo -e "\e[ 33mSMTP Email:\e[97m $email_admin_chatwoot\e[0m" echo "" ## SMTP Password Information echo -e "\e[33mSMTP Password:\e[97m $password_email_chatroot\e[0m" echo "" ## SMTP Host Information echo -e "\e[33mSMTPHost:\e[97m $smtp_email_chatroot\e[0m" echo "" ## SMTP Port Information echo -e "\e[33mSMTP Port:\e[97m $porta_smtp_chatroot\e[0m" echo "" echo "" ## Asks if the answers are correct read -p "Are the answers correct? (Y/N): " confirmation if [ "$confirmation" = "Y" ] || [ "$confirmation" = "y" ]; then ## Typed Y to confirm that the information is correct ## Clear the terminal clear ## Show Installing message installing_msg ## Exit Loop break else ## You typed N to say that the information is not correct.## Clear terminal clear ## Shows the name of the tool chat_name ## Shows message to fill in information fill_as_info ## Returns to the beginning of the loop with the questions fi done ## Step Message echo -e "\e[97m• STARTING INSTALLING CHATWOOT NESTOR \e[33m[1/5]\e[0m" echo "" sleep 1 ## Activates the data function to get data from the vps data ## Step Message echo -e "\e[97m • CHECKING/INSTALLING POSTGRES AND REDIS \e[33m[2/5]\e[0m" echo "" sleep 1 ## Here we will check if Postgres and Redis are already installed ## If so, it will create a database data in postgres or ask if you want to delete what already exists and create another ## Check postgres container and create database in postgres verify_container_postgres if [ $? -eq 0 ]; then get_password_postgres > /dev/null 2>&1 create_bank_postgres_chatwoot_nestor else postgres_tool > /dev/null 2>&1 get_password_postgres > /dev/null 2>&1 create_bank_postgres_chatroot_nestor fi if [ $? -eq 0 ]; then echo "1/2 - [ OK ]" else echo "1/2 - [ OFF ]" fi ## Check redis container check_container_redis if [ $? -eq 0 ]; then echo "" else redis_tool > /dev/null 2>&1 fi if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" fi ## Step Message echo -e "\e[97m• INSTALLING CHATWOOT NESTOR \e[33m[3/5]\ e[0m" echo "" sleep 1 ## In this step we will be creating the Chatwoot Stack yaml in the /root/ folder ## This will allow the user to edit it later ## Then we will install Chatwoot and check if everything is OK right. ## Creating random key encryption_key=$(openssl rand -hex 16) ## Creating stack cat > chatwoot_nestor.yaml <
                              
                              <$email_admin_chatwoot> ## Email SMTP - SMTP_DOMAIN=$domain_smtp_chatwoot ## Email domain - SMTP_ADDRESS=$smtp_email_chatwoot ## Host SMTP - SMTP_PORT=$porta_smtp_chatwoot ## SMTP port - SMTP_SSL=$about_ssl ## If the port is 465 = true | If the port is 587 = false - SMTP_USERNAME=$email_admin_chatwoot ## SMTP email - SMTP_PASSWORD=$password_email_chatwoot ## SMTP password - SMTP_AUTHENTICATION=login - SMTP_ENABLE_STARTTLS_AUTO=true - SMTP_OPENSSL_VERIFY_MODE=peer - MAILER_INBOUND_EMAIL_DOMAIN=$email_ admin_chatroot ## Email SMTP deploy: mode : replicated replicas: 1 placement: constraints: - node.role == manager resources: limits: cpus: "1" memory: 1024M labels: - traefik.enable=true - traefik.http.routers.chatwoot_nestor_app.rule=Host(\ `$url_chatwoot\`) - traefik.http.routers.chatwoot_nestor_app.entrypoints=websecure - traefik.http.routers.chatwoot_nestor_app.tls.certresolver=letsencryptresolver - traefik.http.routers.chatwoot_nestor_app.priority=1 - traefik.http.routers .chatwoot_nestor_app.service=chatwoot_nestor_app - traefik.http.services.chatwoot_nestor_app.loadbalancer.server.port=3000 - traefik.http.services.chatwoot_nestor_app.loadbalancer.passhostheader=true - traefik.http.middlewares.sslheader.headers.customrequestheaders.X -Forwarded-Proto=https - traefik.http.routers.chatwoot_nestor_app.middlewares=sslheader@docker chatwoot_nestor_sidekiq: image: francisbreit/chatwoot-n:v3.6.7-v2 ## Chatwoot version NESTOR command: bundle exec sidekiq -C config/ sidekiq.yml volumes: - chatwoot_nestor_data:/app/storage ## Directory of conversation files - chatwoot_nestor_public_orion:/app ## Directory of all chatwoot networks files: - $nome_rede_interna ## Name of the internal network environment: - CHATWOOT_HUB_URL=https :/ /$url_chatwoot ## Chatwoot Url - DEFAULT_LOCALE=pt_BR - FORCE_SSL=true - ENABLE_ACCOUNT_SIGNUP=false ## false = Disable new registrations at the beginning | true = Enable new subscriptions at the beginning - REDIS_URL=redis://redis:6379 - POSTGRES_HOST=postgres - POSTGRES_USERNAME=postgres - POSTGRES_PASSWORD=$password_postgres ## Postgres password - POSTGRES_DATABASE=chatwoot_nestor - ACTIVE_STORAGE_SERVICE=local - RAILS_LOG_TO_STDOUT=true - USE_INBOX_AVATAR_FOR_BOT=true - _SENDER_EMAIL=$email_admin_chatroot <$email_admin_chatroot> ## Email SMTP - SMTP_DOMAIN =$domain_smtp_chatwoot ## Email domain - SMTP_ADDRESS=$smtp_email_chatwoot ## SMTP host - SMTP_PORT=$porta_smtp_chatwoot ## SMTP port - SMTP_SSL=$about_ssl ## If the port is 465 = true | If the port is 587 = false - SMTP_USERNAME=$email_admin_chatwoot ## SMTP email - SMTP_PASSWORD=$password_email_chatwoot ## SMTP password - SMTP_AUTHENTICATION=login - SMTP_ENABLE_STARTTLS_AUTO=true - SMTP_OPENSSL_VERIFY_MODE=peer - MAILER_INBOUND_EMAIL_DOMAIN=$email_ admin_chatroot ## Email SMTP deploy: mode : replicated replicas: 1 placement: constraints: - node.role == manager resources: limits: cpus: "1" memory: 1024M volumes: chatwoot_nestor_data: external: true name: chatwoot_nestor_data chatwoot_nestor_public_orion: external: true name: chatwoot_nestor_public_orion networks: $nome_rede_interna : ## Internal network name external: true name: $internal_network_name ## Internal network name EOL if [ $? -eq 0 ]; then echo "1/2 - [ OK ]" else echo "1/2 - [ OFF ]" echo "Unable to create Chatwoot stack" fi docker stack deploy --prune --resolve-image always -c chatwoot_nestor. yaml chatwoot_nestor > /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to upload Chatwoot stack" fi ## Step Message echo -e "\e[97m• WAITING FOR SERVICE DO CHATWOOT BE READY \e[33m[4/5]\e[0m" echo "" sleep 1 ## Use the wait_chatwoot_nestor service to check if the service is online wait_chatwoot_nestor ## Step Message echo -e "\e[97m • PREPARING DATABASE \e[33m[5/5]\e[0m" echo "" sleep 1 ## Here we will be migrating the database using the command "bundle exec rails db:chatwoot_prepare" ## Basically you could enter the chatwoot database and execute the command there also container_name="chatwoot_nestor_chatwoot_nestor_app" max_wait_time=1200 wait_interval=60 elapsed_time=0 while [ $elapsed_time -lt $max_wait_time ]; do CONTAINER_ID=$(docker ps -q --filter "name=$container_name") if [ -n "$CONTAINER_ID" ]; then break fi sleep $wait_interval elapsed_time=$((elapsed_time + wait_interval)) done if [ -z "$CONTAINER_ID" ]; then echo "The container was not found after $max_wait_time seconds." exit 1 fi docker exec -it "$CONTAINER_ID" bundle exec rails db:chatwoot_prepare if [ $? -eq 0 ]; then echo "1/1 - [ OK ]" else echo "1/1 - [ OFF ]" echo "Unable to migrate the database" fi ## Saving installation information within /dados_vps/ cd dados_vps cat > dados_chatwoot_nestor <
                              
                              unoapi.yaml <
                              
                              /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to upload Uno API stack" fi ## Step Message echo -e "\e[97m• CHECKING SERVICE \e[33m[3/3]\e[0m" echo "" sleep 1 ## Uses the wait_unoapi service to check if the service is online wait_unoapi cd dados_vps cat > dados_unoapi <
                              
                              /dev/zero If you have redis, if you do, continue, if you don't, install verify_container_redis if [ $? -eq 0 ]; then sleep 1 else tool_redis > /dev/null 2>&1 fi ## Step Message echo -e "\e[97m• INSTALLING N8N \e[33m[3/4]\e[0m" echo "" sleep 1 # # Creating Random key encryption_key=$(openssl rand -hex 16) ## Creating stack cat > n8n_quepasa.yaml <
                              
                              /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to upload N8N Quepasa stack" fi ## Step Message echo -e "\e[97m• CHECKING SERVICE \e[33m[4/4]\e[0m" echo "" sleep 1 ## Uses the wait_n8n service to check if the service is online wait_n8n_quepasa cd dados_vps cat > dados_n8n_quepasa <
                              
                              quepasa.yaml <
                              
                              /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to Upload Quepasa Stack" fi ## Step Message echo -e "\e[97m• CHECKING SERVICE \e[33m[4/4]\e[0m" echo "" sleep 1 ## Use the wait_quepasa service to check if the service is online wait_quepasa cd dados_vps cat > dados_quepasa <
                              
                              No special characters: \!#$ | If you are using gmail, use the app password" echo -en "\e[33mEnter the Email SMTP Password (ex: @Password123_): \e[0m" && read -r password_email_dify echo "" ## Asks the SMTP Host of email echo -e "\e[97mStep$yellow 6/9\e[0m" echo -en "\e[33mEnter the Email SMTP Host (ex: smtp.hostinger.com): \e[0m" && read - r smtp_email_dify echo "" ## Asks for the SMTP port of the email echo -e "\e[97mStep$yellow 7/9\e[0m" echo -en "\e[33mEnter the SMTP port of the Email (ex: 465): \e[0m" && read -r porta_smtp_dify echo "" ## Asks what is the minio's Access Key echo -e "\e[97mPasso$amarelo 8/9\e[0m" echo -en "\e[33mAccess Key Minio: \e[0m" && read -r S3_ACCESS_KEY echo "" ## Asks what is the Minio's Secret Key echo -e "\e[97mPasso$amarelo 9/9\e[0m" echo -en "\e[ 33mSecret Key Minio: \e[0m" && read -r S3_SECRET_KEY echo "" ## Clears the terminal clear ## Shows the application name dify_name ## Shows a message to check the information checking_as_info ## Builder URL information echo -e "\e[33mDify AI Domain:\e[97m $url_dify\e[0m" echo "" ## Viewer URL information echo -e "\e[33mQdrant Domain:\e[97m $url_quedrant\e[ 0m" echo "" ## Tool version information echo -e "\e[33mApi Key Qdrant:\e[97m $apikey_qdrant\e[0m" echo "" ## Email Information echo -e "\e[ 33mSMTP Email:\e[97m $email_dify\e[0m" echo "" ## Email Password Information echo -e "\e[33mEmail Password:\e[97m $senha_email_dify\e[0m" echo "" ## SMTP Host Information echo -e "\e[33mEmail SMTP Host:\e[97m $smtp_email_dify\e[0m" echo "" ## SMTP Port Information echo -e "\e[33mEmail SMTP Port: \e[97m $porta_smtp_dify\e[0m" echo "" ## Information about Access Key echo -e "\e[33mAccess Key Minio:\e[97m $S3_ACCESS_KEY\e[0m" echo "" ## Information about Secret Key echo -e "\e[33mSecret Key Minio:\e[97m $S3_SECRET_KEY\e[0m" echo "" ## Asks if the answers are correct read -p "Are the answers correct? (Y/N): " confirmation if [ "$confirmation" = "Y" ] || [ "$confirmation" = "y" ]; then ## Typed Y to confirm that the information is correct ## Clear the terminal clear ## Show Installing message installing_msg ## Exit Loop break else ## You typed N to say that the information is not correct.## Clear terminal clear ## Shows the name of the tool dify_name ## Shows message to fill in information fill_as_info ## Returns to the beginning of the loop with the questions fi done ## Step Message echo -e "\e[97m• STARTING INSTALLING DIFY \e[33m[1/4]\e[0m" echo "" sleep 1 cd if [ ! -d "nginx" ]; then mkdir nginx fi cd nginx wget https://raw.githubusercontent.com/langgenius/dify/main/docker/nginx/nginx.conf > /dev/null 2>&1 if [ $? -eq 0 ]; then echo "1/3 - [ OK ]" else echo "1/3 - [ OFF ]" fi wget https://raw.githubusercontent.com/langgenius/dify/main/docker/nginx/proxy.conf > /dev /null 2>&1 if [ $? -eq 0 ]; then echo "2/3 - [ OK ]" else echo "2/3 - [ OFF ]" fi if [ ! -d "conf.d" ]; then mkdir conf.d fi cd conf.d wget https://raw.githubusercontent.com/langgenius/dify/main/docker/nginx/conf.d/default.conf > /dev/null 2>&1 if [ $? -eq 0 ]; then echo "3/3 - [ OK ]" else echo "3/3 - [ OFF ]" fi cd cd ## Step Message echo -e "\e[97m• CHECKING/INSTALLING POSTGRES AND REDIS \e[33m[ 2/4]\e[0m" echo "" sleep 1 ## Here we will check whether Postgres and redis are already installed ## If so, it will create a database in Postgres or ask if you want to delete what already exists and create another ## Check postgres container and create database in postgres verify_container_postgres if [ $? -eq 0 ]; then pick up_password_postgres > /dev/null 2>&1 create_bank_postgres_dify #> /dev/null 2>&1 else postgres_tool > /dev/null 2>&1 pick up_postgres_password > /dev/null 2>&1 create_bank_postgres_dify #> /dev/null 2>&1 fi check_container_redis if [ $? -eq 0 ]; then sleep 1 else tool_redis > /dev/null 2>&1 fi ## Step Message echo -e "\e[97m• GETTING MINIMUM DATA \e[33m[3/4]\e[0m" echo "" sleep 1 get_password_minio if [ $? -eq 0 ]; then echo "1/2 - [ OK ]" else echo "1/2 - [ OFF ]" echo "Unable to get the minio's password" fi pega_link_s3 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to get the S3 link" fi ## Step Message echo -e "\e[97m• INSTALLING DIFY \e[33m[4/4]\e[0m" echo "" sleep 1 ## Creating random key secret_key=$(openssl rand -hex 16) ## Creating the stack cat > dify.yaml <conf > /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/3 - [ OK ]" else echo "2/3 - [ OFF ]" fi if [ ! -d "conf.d" ]; then mkdir conf.d fi cd conf.d wget https://raw.githubusercontent.com/langgenius/dify/main/docker/nginx/conf.d/default.conf > /dev/null 2>&1 if [ $? -eq 0 ]; then echo "3/3 - [ OK ]" else echo "3/3 - [ OFF ]" fi cd cd ## Step Message echo -e "\e[97m• CHECKING/INSTALLING POSTGRES AND REDIS \e[33m[ 2/4]\e[0m" echo "" sleep 1 ## Here we will check if Postgres and redis are already installed ## If so, it will create a database in Postgres or ask if you want to delete what already exists and create another ## Check postgres container and create database in postgres verify_container_postgres if [ $? -eq 0 ]; then pick up_password_postgres > /dev/null 2>&1 create_bank_postgres_dify #> /dev/null 2>&1 else postgres_tool > /dev/null 2>&1 pick up_postgres_password > /dev/null 2>&1 create_bank_postgres_dify #> /dev/null 2>&1 fi check_container_redis if [ $? -eq 0 ]; then sleep 1 else tool_redis > /dev/null 2>&1 fi ## Step Message echo -e "\e[97m• GETTING MINIMUM DATA \e[33m[3/4]\e[0m" echo "" sleep 1 get_password_minio if [ $? -eq 0 ]; then echo "1/2 - [ OK ]" else echo "1/2 - [ OFF ]" echo "Unable to get the minio's password" fi pega_link_s3 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to get the S3 link" fi ## Step Message echo -e "\e[97m• INSTALLING DIFY \e[33m[4/4]\e[0m" echo "" sleep 1 ## Creating Random key secret_key=$(openssl rand -hex 16) ## Creating the stack cat > dify.yaml <conf > /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/3 - [ OK ]" else echo "2/3 - [ OFF ]" fi if [ ! -d "conf.d" ]; then mkdir conf.d fi cd conf.d wget https://raw.githubusercontent.com/langgenius/dify/main/docker/nginx/conf.d/default.conf > /dev/null 2>&1 if [ $? -eq 0 ]; then echo "3/3 - [ OK ]" else echo "3/3 - [ OFF ]" fi cd cd ## Step Message echo -e "\e[97m• CHECKING/INSTALLING POSTGRES AND REDIS \e[33m[ 2/4]\e[0m" echo "" sleep 1 ## Here we will check if Postgres and redis are already installed ## If so, it will create a database in Postgres or ask if you want to delete what already exists and create another ## Check postgres container and create database in postgres verify_container_postgres if [ $? -eq 0 ]; then pick up_password_postgres > /dev/null 2>&1 create_bank_postgres_dify #> /dev/null 2>&1 else postgres_tool > /dev/null 2>&1 pick up_postgres_password > /dev/null 2>&1 create_bank_postgres_dify #> /dev/null 2>&1 fi check_container_redis if [ $? -eq 0 ]; then sleep 1 else tool_redis > /dev/null 2>&1 fi ## Step Message echo -e "\e[97m• GETTING MINIMUM DATA \e[33m[3/4]\e[0m" echo "" sleep 1 get_password_minio if [ $? -eq 0 ]; then echo "1/2 - [ OK ]" else echo "1/2 - [ OFF ]" echo "Unable to get the minio's password" fi pega_link_s3 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to get the S3 link" fi ## Step Message echo -e "\e[97m• INSTALLING DIFY \e[33m[4/4]\e[0m" echo "" sleep 1 ## Creating Random key secret_key=$(openssl rand -hex 16) ## Creating the stack cat > dify.yaml <conf > /dev/null 2>&1 if [ $? -eq 0 ]; then echo "3/3 - [ OK ]" else echo "3/3 - [ OFF ]" fi cd cd ## Step Message echo -e "\e[97m• CHECKING/INSTALLING POSTGRES AND REDIS \e[33m[ 2/4]\e[0m" echo "" sleep 1 ## Here we will check whether Postgres and redis are already installed ## If so, it will create a database in Postgres or ask if you want to delete what already exists and create another ## Check postgres container and create database in postgres verify_container_postgres if [ $? -eq 0 ]; then pick up_password_postgres > /dev/null 2>&1 create_bank_postgres_dify #> /dev/null 2>&1 else postgres_tool > /dev/null 2>&1 pick up_postgres_password > /dev/null 2>&1 create_bank_postgres_dify #> /dev/null 2>&1 fi check_container_redis if [ $? -eq 0 ]; then sleep 1 else tool_redis > /dev/null 2>&1 fi ## Step Message echo -e "\e[97m• GETTING MINIMUM DATA \e[33m[3/4]\e[0m" echo "" sleep 1 get_password_minio if [ $? -eq 0 ]; then echo "1/2 - [ OK ]" else echo "1/2 - [ OFF ]" echo "Unable to get the minio's password" fi pega_link_s3 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to get the S3 link" fi ## Step Message echo -e "\e[97m• INSTALLING DIFY \e[33m[4/4]\e[0m" echo "" sleep 1 ## Creating Random key secret_key=$(openssl rand -hex 16) ## Creating the stack cat > dify.yaml <conf > /dev/null 2>&1 if [ $? -eq 0 ]; then echo "3/3 - [ OK ]" else echo "3/3 - [ OFF ]" fi cd cd ## Step Message echo -e "\e[97m• CHECKING/INSTALLING POSTGRES AND REDIS \e[33m[ 2/4]\e[0m" echo "" sleep 1 ## Here we will check whether Postgres and redis are already installed ## If so, it will create a database in Postgres or ask if you want to delete what already exists and create another ## Check postgres container and create database in postgres verify_container_postgres if [ $? -eq 0 ]; then pick up_password_postgres > /dev/null 2>&1 create_bank_postgres_dify #> /dev/null 2>&1 else postgres_tool > /dev/null 2>&1 pick up_postgres_password > /dev/null 2>&1 create_bank_postgres_dify #> /dev/null 2>&1 fi check_container_redis if [ $? -eq 0 ]; then sleep 1 else tool_redis > /dev/null 2>&1 fi ## Step Message echo -e "\e[97m• GETTING MINIMUM DATA \e[33m[3/4]\e[0m" echo "" sleep 1 get_password_minio if [ $? -eq 0 ]; then echo "1/2 - [ OK ]" else echo "1/2 - [ OFF ]" echo "Unable to get the minio's password" fi pega_link_s3 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to get the S3 link" fi ## Step Message echo -e "\e[97m• INSTALLING DIFY \e[33m[4/4]\e[0m" echo "" sleep 1 ## Creating Random key secret_key=$(openssl rand -hex 16) ## Creating the stack cat > dify.yaml <
                              
                              /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "It was not possible to upload the Dify Ai stack" fi ## Step Message echo -e "\e[97m• CHECKING SERVICE \e[33m[4/4]\e[0m" echo "" sleep 1 ## Uses the wait_dify service to check if the service is online wait_dify cd data_vps cat > data_dify <
                              
                              ollama.yaml <
                              
                              /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to Upload Ollama Stack" fi ## Step Message echo -e "\e[97m• CHECKING SERVICE \e[33m[4/4]\e[0m" echo "" sleep 1 ## Use the wait_nocodb service to check if the service is online wait_ollama cd dados_vps cat > dados_ollama <
                              
                              1 { if ($1 == "portainer" || $1 == "traefik") {print "[ \033[0;31m" NR-1" \033[0m] - \033[0;31m" toupper(substr ($0, 1, 1)) substr($0, 2) " (CAUTION) \033[0m" } else {print "[ " NR-1" ] - " toupper(substr($0, 1, 1)) substr( $0, 2)} }' echo "" # Prompt the user to choose a stack to remove or exit read -p "Enter the number of the stack you want to remove (or enter '0' to go back): " user_input # Check if user wants to exit if [ "$user_input" == "0" ]; then echo "Exiting script." break fi # Get the stack name based on the given number stack_name=$(docker stack ls --format "{{.Name}}" | sed -n "${user_input}p") # Check if the stack exists if docker stack ps "$stack_name" &> /dev/null; then # Remove stack docker stack rm "$stack_name" echo "Removing stack $stack_name..." else echo "Stack $stack_name was not found." fi done } ## █████╗ ███████╗███████╗██╗███╗ █╗ ## ██╔ ══██╗██╔════╝██╔════╝██║████╗ # ███████║ █████╗ █████╗ ██║██╔██╗ ██║█████╗ ## ██╔══██║ ██╔══╝ ██╔═ ═╝ ██║██║╚██╗██║██╔══╝ ## ██║ ██║██║ ██║ ██║██ ║ ╚████║███ ████╗ # # # Clear terminal clear ## Activates the data function to get data from the data vps ## Shows the name of the application affine_name ## Shows a message to fill in information fill_as_info ## Starts a Loop until the data is correct while true; do ##Question the Domain for the tool echo -e "\e[97mPasso$amarelo 1/7\e[0m" echo -en "\e[33mEnter the domain for Affine (ex: affine.oriondesign.art.br ): \e[0m" && read -r url_affine echo "" ##Question the Domain for the tool echo -e "\e[97mPasso$amarelo 2/7\e[0m" echo -en "\e[33mEnter the Admin Email (e.g. contato@oriondesign.art.br): \e[0m" && read -r email_affine echo "" ##Question the Domain for the echo -e tool "\e[97mPasso$amarelo 3/7\ e[0m" echo -e "$yellow--> No special characters: \!#$" echo -en "\e[33mEnter the Admin Password (ex: @Password123_): \e[0m" && read -r password_affine echo "" ##Question the Domain for the tool echo -e "\e[97mStep$yellow 4/7\e[0m" echo -en "\e[33mDigite the SMTP Email (ex: contato@oriondesign.art. br): \e[0m" && read -r email_smtp_affine echo "" ##Question the Domain for the tool echo -e "\e[97mPasso$amarelo 5/7\e[0m" echo -e "$amarelo-- > No special characters: \!#$ | If you are using gmail, use the app password" echo -en "\e[33mEnter the SMTP Password (ex: @Password123_):\e[0m" && read -r password_smtp_affine echo "" ##Question the Domain for the tool echo -e "\e[97mStep$yellow 6/7\e[0m" echo -en "\e[33mEnter the SMTP Host (ex: smtp.hostinger.com): \e[0m" && read -r host_smtp_affine echo "" ##Question the Domain for the tool echo -e "\e[97mPasso$amarelo 7/7\e[0m" echo -en "\e[33mEnter the SMTP Port (ex: 465): \e[0m" && read -r smtp_affine_port echo "" ## Clears the terminal clear ## Shows the application name affine_name ## Shows a message to check the information checking_as_info ## Information about affine URL echo -e "\e[33mAffine Domain:\e[97m $url_affine\e[0m" echo "" ## Information about affine URL echo -e "\e[33mEmail from Admin:\e[97m $email_affine\e[0m" echo "" ## Information about affine URL echo -e "\e[33mAdmin Password:\e[97m $password_affine\e[0m" echo "" ## Affine URL information echo -e "\e[33mEmail SMTP:\e[97m $email_smtp_affine\e[0m" echo "" ## Affine URL information echo -e "\e[33mSMTP Password:\e[97m $password_smtp_affine\e[0m" echo "" ## Information about affine URL echo -e "\e[33mHost SMTP:\e[97m $host_smtp_affine\e[0m" echo "" ## Information about affine echo URL - and "\e[33mSMTP Port:\e[97m $porta_smtp_affine\e[0m" echo "" ## Asks if the answers are correct read -p "Are the answers correct? (Y/N): " confirmation if [ "$confirmation" = "Y" ] || [ "$confirmation" = "y" ]; then ## Typed Y to confirm that the information is correct ## Clear the terminal clear ## Show Installing message installing_msg ## Exit Loop break else ## Entered N to say that the information is not correct ## Clear terminal clear ## Shows the name of the tool affine_name ## Shows message to fill in information fill_as_info # # Returns to the beginning of the loop with the questions fi done ## Step Message echo -e "\e[97m• STARTING AFFINE INSTALLATION \e[33m[1/4]\e[0m" echo "" sleep 1 ## Nadaaaaa ## Step Message echo -e "\e[97m• CHECKING/INSTALLING POSTGRES AND REDIS \e[33m[2/4]\e[0m" echo "" sleep 1 ## I'm tired of explaining what this does kkkk verify_container_postgres if [ $? -eq 0 ]; then sleep 1 get_postgres_pass > /dev/null 2>&1 create_bank_postgres_affine #> /dev/null 2>&1 else postgres_post > /dev/null 2>&1 get_postgres_pass > /dev/ null 2>&1 create_banco_postgres_affine #> /dev/null 2>&1 fi verify_container_redis if [ $? -eq 0 ]; then sleep 1 else tool_redis > /dev/null 2>&1 fi ## Step Message echo -e "\e[97m• INSTALLING AFFINE \e[33m[3/4]\e[0m" echo "" sleep 1 # # Creating the stack cat > affine.yaml <yaml <yaml <\e[0m" && read -r host_smtp_affine echo "" ##Question the Domain for the tool echo -e "\e[97mStep$yellow 7/7\e[0m" echo -en "\e[33mEnter the SMTP Port (ex: 465): \e[0m" && read -r porta_smtp_affine echo "" ## Clears the terminal clear ## Shows the application name affine_name ## Shows a message to check the information checking_as_info ## Information about the affine URL echo -e "\e[33mAffine Domain:\e[97m $url_affine\e[0m" echo "" ## Affine URL information echo -e "\e[33mAdmin Email:\e[97m $email_affine\e [0m" echo "" ## Information about affine URL echo -e "\e[33mAdmin Password:\e[97m $affine_password\e[0m" echo "" ## Information about affine URL echo -e "\ e[33mEmail SMTP:\e[97m $email_smtp_affine\e[0m" echo "" ## Information about affine URL echo -e "\e[33mSMTP Password:\e[97m $senha_smtp_affine\e[0m" echo "" ## Information about affine URL echo -e "\e[33mHost SMTP:\e[97m $host_smtp_affine\e[0m" echo "" ## Information about affine URL echo -e "\e[33mSMTP Port:\e [97m $porta_smtp_affine\e[0m" echo "" ## Asks if the answers are correct read -p "Are the answers correct? (Y/N): " confirmation if [ "$confirmation" = "Y" ] || [ "$confirmation" = "y" ]; then ## Typed Y to confirm that the information is correct ## Clear the terminal clear ## Show Installing message installing_msg ## Exit Loop break else ## Entered N to say that the information is not correct ## Clear terminal clear ## Shows the name of the tool affine_name ## Shows message to fill in information fill_as_info # # Returns to the beginning of the loop with the questions fi done ## Step Message echo -e "\e[97m• STARTING AFFINE INSTALLATION \e[33m[1/4]\e[0m" echo "" sleep 1 ## Nadaaaaa ## Step Message echo -e "\e[97m• CHECKING/INSTALLING POSTGRES AND REDIS \e[33m[2/4]\e[0m" echo "" sleep 1 ## I'm tired of explaining what this does kkkk verify_container_postgres if [ $? -eq 0 ]; then sleep 1 get_postgres_pass > /dev/null 2>&1 create_bank_postgres_affine #> /dev/null 2>&1 else postgres_post > /dev/null 2>&1 get_postgres_pass > /dev/ null 2>&1 create_banco_postgres_affine #> /dev/null 2>&1 fi verify_container_redis if [ $? -eq 0 ]; then sleep 1 else tool_redis > /dev/null 2>&1 fi ## Step Message echo -e "\e[97m• INSTALLING AFFINE \e[33m[3/4]\e[0m" echo "" sleep 1 # # Creating the stack cat > affine.yaml <\e[0m" && read -r host_smtp_affine echo "" ##Question the Domain for the tool echo -e "\e[97mStep$yellow 7/7\e[0m" echo -en "\e[33mEnter the SMTP Port (ex: 465): \e[0m" && read -r porta_smtp_affine echo "" ## Clears the terminal clear ## Shows the application name affine_name ## Shows a message to check the information checking_as_info ## Information about the affine URL echo -e "\e[33mAffine Domain:\e[97m $url_affine\e[0m" echo "" ## Affine URL information echo -e "\e[33mAdmin Email:\e[97m $email_affine\e [0m" echo "" ## Information about affine URL echo -e "\e[33mAdmin Password:\e[97m $affine_password\e[0m" echo "" ## Information about affine URL echo -e "\ e[33mEmail SMTP:\e[97m $email_smtp_affine\e[0m" echo "" ## Information about affine URL echo -e "\e[33mSMTP Password:\e[97m $senha_smtp_affine\e[0m" echo "" ## Information about affine URL echo -e "\e[33mHost SMTP:\e[97m $host_smtp_affine\e[0m" echo "" ## Information about affine URL echo -e "\e[33mSMTP Port:\e [97m $porta_smtp_affine\e[0m" echo "" ## Asks if the answers are correct read -p "Are the answers correct? (Y/N): " confirmation if [ "$confirmation" = "Y" ] || [ "$confirmation" = "y" ]; then ## Typed Y to confirm that the information is correct ## Clear the terminal clear ## Show Installing message installing_msg ## Exit Loop break else ## Entered N to say that the information is not correct ## Clear terminal clear ## Shows the name of the tool affine_name ## Shows message to fill in information fill_as_info # # Returns to the beginning of the loop with the questions fi done ## Step Message echo -e "\e[97m• STARTING AFFINE INSTALLATION \e[33m[1/4]\e[0m" echo "" sleep 1 ## Nadaaaaa ## Step Message echo -e "\e[97m• CHECKING/INSTALLING POSTGRES AND REDIS \e[33m[2/4]\e[0m" echo "" sleep 1 ## I'm tired of explaining what this does kkkk verify_container_postgres if [ $? -eq 0 ]; then sleep 1 get_postgres_pass > /dev/null 2>&1 create_bank_postgres_affine #> /dev/null 2>&1 else postgres_post > /dev/null 2>&1 get_postgres_pass > /dev/ null 2>&1 create_banco_postgres_affine #> /dev/null 2>&1 fi verify_container_redis if [ $? -eq 0 ]; then sleep 1 else tool_redis > /dev/null 2>&1 fi ## Step Message echo -e "\e[97m• INSTALLING AFFINE \e[33m[3/4]\e[0m" echo "" sleep 1 # # Creating the stack cat > affine.yaml <\e[0m" && read -r porta_smtp_affine echo "" ## Clears the terminal clear ## Shows the application name affine_name ## Shows a message to check the information checking_as_info ## Information about the affine URL echo -e "\e[ 33mAffine Domain:\e[97m $url_affine\e[0m" echo "" ## Information about affine URL echo -e "\e[33mAdmin Email:\e[97m $email_affine\e[0m" echo "" ## Information about affine URL echo -e "\e[33mAdmin Password:\e[97m $affine_password\e[0m" echo "" ## Information about affine URL echo -e "\e[33mEmail SMTP:\ e[97m $email_smtp_affine\e[0m" echo "" ## Information about affine URL echo -e "\e[33mSMTP Password:\e[97m $senha_smtp_affine\e[0m" echo "" ## Information about URL affine echo -e "\e[33mSMTPHost:\e[97m $host_smtp_affine\e[0m" echo "" ## Information about affine URL echo -e "\e[33mSMTPPort:\e[97m $porta_smtp_affine\e [0m" echo "" ## Asks if the answers are correct read -p "Are the answers correct? (Y/N): " confirmation if [ "$confirmation" = "Y" ] || [ "$confirmation" = "y" ]; then ## Typed Y to confirm that the information is correct ## Clear the terminal clear ## Show Installing message installing_msg ## Exit Loop break else ## Entered N to say that the information is not correct ## Clear terminal clear ## Shows the name of the tool affine_name ## Shows message to fill in information fill_as_info # # Returns to the beginning of the loop with the questions fi done ## Step Message echo -e "\e[97m• STARTING AFFINE INSTALLATION \e[33m[1/4]\e[0m" echo "" sleep 1 ## Nadaaaaa ## Step Message echo -e "\e[97m• CHECKING/INSTALLING POSTGRES AND REDIS \e[33m[2/4]\e[0m" echo "" sleep 1 ## I'm tired of explaining what this does kkkk verify_container_postgres if [ $? -eq 0 ]; then sleep 1 get_postgres_pass > /dev/null 2>&1 create_bank_postgres_affine #> /dev/null 2>&1 else postgres_post > /dev/null 2>&1 get_postgres_pass > /dev/ null 2>&1 create_banco_postgres_affine #> /dev/null 2>&1 fi verify_container_redis if [ $? -eq 0 ]; then sleep 1 else tool_redis > /dev/null 2>&1 fi ## Step Message echo -e "\e[97m• INSTALLING AFFINE \e[33m[3/4]\e[0m" echo "" sleep 1 # # Creating the stack cat > affine.yaml <\e[0m" && read -r porta_smtp_affine echo "" ## Clears the terminal clear ## Shows the application name affine_name ## Shows a message to check the information checking_as_info ## Information about the affine URL echo -e "\e[ 33mAffine Domain:\e[97m $url_affine\e[0m" echo "" ## Information about affine URL echo -e "\e[33mAdmin Email:\e[97m $email_affine\e[0m" echo "" ## Information about affine URL echo -e "\e[33mAdmin Password:\e[97m $affine_password\e[0m" echo "" ## Information about affine URL echo -e "\e[33mEmail SMTP:\ e[97m $email_smtp_affine\e[0m" echo "" ## Information about affine URL echo -e "\e[33mSMTP Password:\e[97m $senha_smtp_affine\e[0m" echo "" ## Information about URL affine echo -e "\e[33mSMTPHost:\e[97m $host_smtp_affine\e[0m" echo "" ## Information about affine URL echo -e "\e[33mSMTPPort:\e[97m $porta_smtp_affine\e [0m" echo "" ## Asks if the answers are correct read -p "Are the answers correct? (Y/N): " confirmation if [ "$confirmation" = "Y" ] || [ "$confirmation" = "y" ]; then ## Typed Y to confirm that the information is correct ## Clear the terminal clear ## Show Installing message installing_msg ## Exit Loop break else ## Entered N to say that the information is not correct ## Clear terminal clear ## Shows the name of the tool affine_name ## Shows message to fill in information fill_as_info # # Returns to the beginning of the loop with the questions fi done ## Step Message echo -e "\e[97m• STARTING AFFINE INSTALLATION \e[33m[1/4]\e[0m" echo "" sleep 1 ## Nadaaaaa ## Step Message echo -e "\e[97m• CHECKING/INSTALLING POSTGRES AND REDIS \e[33m[2/4]\e[0m" echo "" sleep 1 ## I'm tired of explaining what this does kkkk verify_container_postgres if [ $? -eq 0 ]; then sleep 1 get_postgres_pass > /dev/null 2>&1 create_bank_postgres_affine #> /dev/null 2>&1 else postgres_post > /dev/null 2>&1 get_postgres_pass > /dev/ null 2>&1 create_banco_postgres_affine #> /dev/null 2>&1 fi verify_container_redis if [ $? -eq 0 ]; then sleep 1 else tool_redis > /dev/null 2>&1 fi ## Step Message echo -e "\e[97m• INSTALLING AFFINE \e[33m[3/4]\e[0m" echo "" sleep 1 # # Creating the stack cat > affine.yaml <\e[97m $email_affine\e[0m" echo "" ## Information about affine URL echo -e "\e[33mAdmin Password:\e[97m $password_affine\e[0m" echo "" ## Information about Affine URL echo -e "\e[33mEmail SMTP:\e[97m $email_smtp_affine\e[0m" echo "" ## Information about affine URL echo -e "\e[33mSMTP Password:\e[97m $password_smtp_affine \e[0m" echo "" ## Affine URL information echo -e "\e[33mHost SMTP:\e[97m $host_smtp_affine\e[0m" echo "" ## Affine URL information echo -e " \e[33mSMTP Port:\e[97m $porta_smtp_affine\e[0m" echo "" ## Asks if the answers are correct read -p "Are the answers correct? (Y/N): " confirmation if [ "$confirmation" = "Y" ] || [ "$confirmation" = "y" ]; then ## Typed Y to confirm that the information is correct ## Clear the terminal clear ## Show Installing message installing_msg ## Exit Loop break else ## Entered N to say that the information is not correct ## Clear terminal clear ## Shows the name of the tool affine_name ## Shows message to fill in information fill_as_info # # Returns to the beginning of the loop with the questions fi done ## Step Message echo -e "\e[97m• STARTING AFFINE INSTALLATION \e[33m[1/4]\e[0m" echo "" sleep 1 ## Nadaaaaa ## Step Message echo -e "\e[97m• CHECKING/INSTALLING POSTGRES AND REDIS \e[33m[2/4]\e[0m" echo "" sleep 1 ## I'm tired of explaining what this does kkkk verify_container_postgres if [ $? -eq 0 ]; then sleep 1 get_postgres_pass > /dev/null 2>&1 create_bank_postgres_affine #> /dev/null 2>&1 else postgres_post > /dev/null 2>&1 get_postgres_pass > /dev/ null 2>&1 create_banco_postgres_affine #> /dev/null 2>&1 fi verify_container_redis if [ $? -eq 0 ]; then sleep 1 else tool_redis > /dev/null 2>&1 fi ## Step Message echo -e "\e[97m• INSTALLING AFFINE \e[33m[3/4]\e[0m" echo "" sleep 1 # # Creating the stack cat > affine.yaml <\e[97m $email_affine\e[0m" echo "" ## Information about affine URL echo -e "\e[33mAdmin Password:\e[97m $password_affine\e[0m" echo "" ## Information about Affine URL echo -e "\e[33mEmail SMTP:\e[97m $email_smtp_affine\e[0m" echo "" ## Information about affine URL echo -e "\e[33mSMTP Password:\e[97m $password_smtp_affine \e[0m" echo "" ## Affine URL information echo -e "\e[33mHost SMTP:\e[97m $host_smtp_affine\e[0m" echo "" ## Affine URL information echo -e " \e[33mSMTP Port:\e[97m $porta_smtp_affine\e[0m" echo "" ## Asks if the answers are correct read -p "Are the answers correct? (Y/N): " confirmation if [ "$confirmation" = "Y" ] || [ "$confirmation" = "y" ]; then ## Typed Y to confirm that the information is correct ## Clear the terminal clear ## Show Installing message installing_msg ## Exit Loop break else ## Entered N to say that the information is not correct ## Clear terminal clear ## Shows the name of the tool affine_name ## Shows message to fill in information fill_as_info # # Returns to the beginning of the loop with the questions fi done ## Step Message echo -e "\e[97m• STARTING AFFINE INSTALLATION \e[33m[1/4]\e[0m" echo "" sleep 1 ## Nadaaaaa ## Step Message echo -e "\e[97m• CHECKING/INSTALLING POSTGRES AND REDIS \e[33m[2/4]\e[0m" echo "" sleep 1 ## I'm tired of explaining what this does kkkk verify_container_postgres if [ $? -eq 0 ]; then sleep 1 get_postgres_pass > /dev/null 2>&1 create_bank_postgres_affine #> /dev/null 2>&1 else postgres_post > /dev/null 2>&1 get_postgres_pass > /dev/ null 2>&1 create_banco_postgres_affine #> /dev/null 2>&1 fi verify_container_redis if [ $? -eq 0 ]; then sleep 1 else tool_redis > /dev/null 2>&1 fi ## Step Message echo -e "\e[97m• INSTALLING AFFINE \e[33m[3/4]\e[0m" echo "" sleep 1 # # Creating the stack cat > affine.yaml <" confirmation if [ "$confirmation" = "Y" ] || [ "$confirmation" = "y" ]; then ## Typed Y to confirm that the information is correct ## Clear the terminal clear ## Show Installing message installing_msg ## Exit the Loop break else ## You typed N to say that the information is not correct ## Clear the terminal clear ## Shows the name of the tool affine_name ## Shows a message to fill in information fill_as_info ## Returns to the beginning of the process loop with the questions fi done ## Step Message echo -e "\e[97m• STARTING AFFINE INSTALLATION \e[33m[1/4]\e[0m" echo "" sleep 1 ## Nadaaaaa ## Message de Passo echo -e "\e[97m• VERIFYING/INSTALLING POSTGRES AND REDIS \e[33m[2/4]\e[0m" echo "" sleep 1 ## I'm already tired of explaining what this does lol verify_container_postgres if [ # > /dev/null 2>&1 fi verify_container_redis if [ $? -eq 0 ]; then sleep 1 else tool_redis > /dev/null 2>&1 fi ## Step Message echo -e "\e[97m• INSTALLING AFFINE \e[33m[3/4]\e[0m" echo "" sleep 1 # # Creating the stack cat > affine.yaml <" confirmation if [ "$confirmation" = "Y" ] || [ "$confirmation" = "y" ]; then ## Typed Y to confirm that the information is correct ## Clear the terminal clear ## Show Installing message installing_msg ## Exit the Loop break else ## You typed N to say that the information is not correct ## Clear the terminal clear ## Shows the name of the tool affine_name ## Shows a message to fill in information fill_as_info ## Returns to the beginning of the process loop with the questions fi done ## Step Message echo -e "\e[97m• STARTING AFFINE INSTALLATION \e[33m[1/4]\e[0m" echo "" sleep 1 ## Nadaaaaa ## Message de Passo echo -e "\e[97m• VERIFYING/INSTALLING POSTGRES AND REDIS \e[33m[2/4]\e[0m" echo "" sleep 1 ## I'm already tired of explaining what this does lol verify_container_postgres if [ # > /dev/null 2>&1 fi verify_container_redis if [ $? -eq 0 ]; then sleep 1 else tool_redis > /dev/null 2>&1 fi ## Step Message echo -e "\e[97m• INSTALLING AFFINE \e[33m[3/4]\e[0m" echo "" sleep 1 # # Creating the stack cat > affine.yaml <
                              
                              /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to Upload Affine Stack" fi ## Step Message echo -e "\e[97m• CHECKING SERVICE \e[33m[4/4]\e[0m" echo "" sleep 1 ## Use the wait_affine service to check if the service is online wait_affine cd data_vps cat > data_affine <
                              
                              No special characters: \!#$ | If you are using gmail, use the app password" echo -en "\e[33mEnter the SMTP Password (ex: @Password123_): \e[0m" && read -r password_smtp_docuseal echo "" ##Question the Domain for the echo tool -e "\e[97mStep$yellow 4/5\e[0m" echo -en "\e[33mEnter the SMTP Host (ex: smtp.hostinger.com): \e[0m" && read -r host_smtp_docuseal echo " " ##Question the Domain for the echo -e tool "\e[97mStep$yellow 5/5\e[0m" echo -en "\e[33mEnter the SMTP Port (ex: 465): \e[0m" && read -r docuseal_smtp_port echo "" ## Clears the terminal clear ## Shows the name of the application docuseal_name ## Shows a message to check the information checking_as_info ## Information about docuseal URL echo -e "\e[33mDocuseal domain:\e [97m $url_docuseal\e[0m" echo "" ## Information about docuseal URL echo -e "\e[33mEmail SMTP:\e[97m $email_smtp_docuseal\e[0m" echo "" ## Information about docuseal URL echo -e "\e[33mSMTP Password:\e[97m $password_smtp_docuseal\e[0m" echo "" ## Information about docuseal URL echo -e "\e[33mSMTPHost:\e[97m $host_smtp_docuseal\e[ 0m" echo "" ## Information about docuseal URL echo -e "\e[33mSMTP Port:\e[97m $porta_smtp_docuseal\e[0m" echo "" ## Asks if the answers are correct read -p "The answers they are correct? (Y/N): " confirmation if [ "$confirmation" = "Y" ] || [ "$confirmation" = "y" ]; then ## Typed Y to confirm that the information is correct ## Clear the terminal clear ## Show Installing message installing_msg ## Exit Loop break else ## You typed N to say that the information is not correct.## Clear terminal clear ## Shows the tool name docuseal_name ## Shows message to fill in information fill_as_info ## Returns to the beginning of the loop with the questions fi done ## Step Message echo -e "\e[97m• STARTING DOCUSEAL INSTALLATION \e[33m[1/4]\e[0m" echo "" sleep 1 ## Nadaaaaa ## Step Message echo -e "\e[97m• CHECKING/INSTALLING POSTGRES \e[33m[2 /4]\e[0m" echo "" sleep 1 ## I'm tired of explaining what this does kkkk verify_container_postgres if [ $? -eq 0 ]; then sleep 1 get_postgres_password > /dev/null 2>&1 create_bank_postgres_docuseal #> /dev/null 2>&1 else postgres_tool > /dev/null 2>&1 get_postgres_password > /dev/null 2>&1 create_bank_postgres_docuseal #> /dev/null 2> &1 fi ## Step Message echo -e "\e[97m• INSTALLING DOCUSEAL \e[33m[3/4]\e[0m" echo "" sleep 1 ## Get the email domain dominio_smtp_docuseal="${email_smtp_docuseal ##*@}" key_docuseal=$(openssl rand -hex 16) key_docuseal2=$(openssl rand -hex 16) ## Creating the stack cat > docuseal.yaml <
                              
                              /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to upload docuseal stack" fi ## Step Message echo -e "\e[97m• CHECKING SERVICE \e[33m[4/4]\e[0m" echo "" sleep 1 ## Use the wait_docuseal service to check if the service is online wait_docuseal cd data_vps cat > data_docuseal <
                              
                              No special characters: \!#$" echo -en "\e[33mEnter the SMTP Password (ex: @Password123_): \e[0m" && read -r password_directus echo "" ##Question the Domain for the echo tool - and "\e[97mPasso$amarelo 4/9\e[0m" echo -en "\e[33mDigite a Email SMTP (ex: contato@oriondesign.art.br): \e[0m" && read -r email_smtp_directus echo "" ##Question the Domain for the tool echo -e "\e[97mPasso$amarelo 5/9\e[0m" echo -e "$amarelo--> No special characters: \!#$ | If you are using gmail, use the app password" echo -en "\e[33mEnter the SMTP Password (ex: @Password123_): \e[0m" && read -r password_smtp_directus echo "" ##Question the Domain for the echo tool -e "\e[97mStep$yellow 6/9\e[0m" echo -en "\e[33mEnter the SMTP Host (ex: smtp.hostinger.com): \e[0m" && read -r host_smtp_directus echo " " ##Ask the Domain for the echo -e tool "\e[97mStep$yellow 7/9\e[0m" echo -en "\e[33mEnter the SMTP Port (ex: 465): \e[0m" && read -r porta_smtp_directus echo "" ## Asks what is the minio's Access Key echo -e "\e[97mPasso$amarelo 8/9\e[0m" echo -en "\e[33mAccess Key Minio: \e[0m " && read -r S3_ACCESS_KEY echo "" ## Asks what is the Secret Key of the minio echo -e "\e[97mPasso$amarelo 9/9\e[0m" echo -en "\e[33mSecret Key Minio: \e [0m" && read -r S3_SECRET_KEY echo "" pega_senha_minio if [ $? -eq 0 ]; then echo "1/2 - [ OK ]" else echo "1/2 - [ OFF ]" echo "Unable to get the minio password" fi pega_link_s3 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to get the S3 link" fi # # Clears the terminal clear ## Shows the name of the application directus_name ## Shows a message to check the information checking_as_info ## Information about directus URL echo -e "\e[33mDirectusDomain:\e[97m $url_directus\e[0m " echo "" ## Information about directus URL echo -e "\e[33mAdmin Email:\e[97m $email_directus\e[0m" echo "" ## Information about directus URL echo -e "\e[ 33mAdmin Password:\e[97m $password_directus\e[0m" echo "" ## Information about directus URL echo -e "\e[33mEmail SMTP:\e[97m $email_smtp_directus\e[0m" echo "" # # Information about directus URL echo -e "\e[33mSMTPPassword:\e[97m $password_smtp_directus\e[0m" echo "" ## Information about directus URL echo -e "\e[33mHost SMTP:\e[ 97m $host_smtp_directus\e[0m" echo "" ## Information about directus URL echo -e "\e[33mSMTP port:\e[97m $porta_smtp_directus\e[0m" echo "" ## Information about directus echo URL -e "\e[33mAccess Key Minio:\e[97m $S3_ACCESS_KEY\e[0m" echo "" ## Directus URL information echo -e "\e[33mSecret Key Minio:\e[97m $S3_SECRET_KEY\e[0m" echo "" ## Check if the port is 465, if yes, leave ssl true, if not, leave false if [ "$porta_smtp_directus" -eq 465 ]; then ssl_smtp_directus=true else ssl_smtp_directus=false fi ## Asks if the answers are correct read -p "As Are answers correct? (Y/N): " confirmation if [ "$confirmation" = "Y" ] || [ "$confirmation" = "y" ]; then ## Typed Y to confirm that the information is correct ## Clear the terminal clear ## Show Installing message installing_msg ## Exit the Loop break else ## Enter N to say that the information is not correct ## Clear the terminal clear ## Show the name of the tool direct_name ## Show a message to fill in information fill_as_info # # Returns to the beginning of the loop with the questions fi done ## Step Message echo -e "\e[97m• STARTING DIRECTUS INSTALLATION \e[33m[1/4]\e[0m" echo "" sleep 1 ## Nadaaaaa ## Step Message echo -e "\e[97m• CHECKING/INSTALLING POSTGRES AND REDIS \e[33m[2/4]\e[0m" echo "" sleep 1 ## I'm tired of explaining what this does kkkk verify_container_postgres if [ $? -eq 0 ]; then sleep 1 get_password_postgres > /dev/null 2>&1 create_banco_postgres_directus #> /dev/null 2>&1 else tool_postgres > /dev/null 2>&1 get_password_postgres > /dev/ null 2>&1 create_banco_postgres_directus #> /dev/null 2>&1 fi if [ $? -eq 0 ]; then echo "1/2 - [ OK ]" else echo "1/2 - [ OFF ]" fi ## Check redis container check_container_redis if [ $? -eq 0 ]; then echo "" else redis_tool > /dev/null 2>&1 fi if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" fi ## Step Message echo -e "\e[97m• INSTALLING DIRECTUS \e[33m[3/4]\e [0m" echo "" sleep 1 ## Generate Secret Key key_directus=$(openssl rand -hex 16) key_directus2=$(openssl rand -hex 16) ## Creating the stack cat > directus.yaml <## Clear terminal clear ## Shows the name of the tool directus_name ## Shows message to fill in information fill_as_info ## Returns to the beginning of the loop with the questions fi done ## Step Message echo -e "\e[97m• STARTING INSTALLING DIRECTUS \e[33m[1/4]\e[0m" echo "" sleep 1 ## Nadaaaaa ## Step Message echo -e "\e[97m• CHECKING/INSTALLING POSTGRES AND REDIS \e[33m [2/4]\e[0m" echo "" sleep 1 ## I'm tired of explaining what this does kkkk verify_container_postgres if [ $? -eq 0 ]; then sleep 1 get_password_postgres > /dev/null 2>&1 create_banco_postgres_directus #> /dev/null 2>&1 else tool_postgres > /dev/null 2>&1 get_password_postgres > /dev/null 2>&1 create_bank_postgres_directus #> /dev/null 2> &1 fi if [ $? -eq 0 ]; then echo "1/2 - [ OK ]" else echo "1/2 - [ OFF ]" fi ## Check redis container check_container_redis if [ $? -eq 0 ]; then echo "" else redis_tool > /dev/null 2>&1 fi if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" fi ## Step Message echo -e "\e[97m• INSTALLING DIRECTUS \e[33m[3/4]\e [0m" echo "" sleep 1 ## Generate Secret Key key_directus=$(openssl rand -hex 16) key_directus2=$(openssl rand -hex 16) ## Creating the stack cat > directus.yaml <## Clear terminal clear ## Shows the name of the tool directus_name ## Shows message to fill in information fill_as_info ## Returns to the beginning of the loop with the questions fi done ## Step Message echo -e "\e[97m• STARTING INSTALLING DIRECTUS \e[33m[1/4]\e[0m" echo "" sleep 1 ## Nadaaaaa ## Step Message echo -e "\e[97m• CHECKING/INSTALLING POSTGRES AND REDIS \e[33m [2/4]\e[0m" echo "" sleep 1 ## I'm tired of explaining what this does kkkk verify_container_postgres if [ $? -eq 0 ]; then sleep 1 get_password_postgres > /dev/null 2>&1 create_banco_postgres_directus #> /dev/null 2>&1 else tool_postgres > /dev/null 2>&1 get_password_postgres > /dev/null 2>&1 create_bank_postgres_directus #> /dev/null 2> &1 fi if [ $? -eq 0 ]; then echo "1/2 - [ OK ]" else echo "1/2 - [ OFF ]" fi ## Check redis container check_container_redis if [ $? -eq 0 ]; then echo "" else redis_tool > /dev/null 2>&1 fi if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" fi ## Step Message echo -e "\e[97m• INSTALLING DIRECTUS \e[33m[3/4]\e [0m" echo "" sleep 1 ## Generate Secret Key key_directus=$(openssl rand -hex 16) key_directus2=$(openssl rand -hex 16) ## Creating the stack cat > directus.yaml <
                              
                              /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to Upload Directus Stack" fi ## Step Message echo -e "\e[97m• CHECKING SERVICE \e[33m[4/4]\e[0m" echo "" sleep 1 ## Use the wait_directus service to check if the service is online wait_directus cd dados_vps cat > dados_directus <
                              
                              No special characters: \!#$ | If you are using gmail, use the app password" echo -en "\e[33mEnter the email's SMTP Password (ex: @Password123_): \e[0m" && read -r password_vaultwarden echo "" ## Ask the SMTP Host echo -e "\e[97mStep$yellow 4/5\e[0m" echo -en "\e[33mEnter the SMTP Host of the email (ex: smtp.hostinger.com): \e[0m" && read -r host_vaultwarden echo "" ## Ask for SMTP Port echo -e "\e[97mStep$yellow 5/5\e[0m" echo -en "\e[33mEnter the SMTP Port of the email (ex: 465): \e[0m " && read -r porta_vaultwarden echo "" if [ "$porta_vaultwarden" -eq 465 ] || [ "$porta_vaultwarden" -eq 25 ]; then ssl_vaultwarden=force_tls else ssl_vaultwarden=starttls fi ## Clears the terminal clear ## Shows the application name name_vaultwarden ## Shows message to check the information checking_as_info ## Information about URL echo -e "\e[33mDomain:\e[97m $url_vaultwarden\e[0m" echo "" ## Information about Email echo -e " \e[33mEmail SMTP:\e[97m $email_vaultwarden\e[0m" echo "" ## Password Information echo -e "\e[33mSMTP Password:\e[97m $password_vaultwarden\e[0m" echo "" # # Host Information echo -e "\e[33mHost SMTP:\e[97m $host_vaultwarden\e[0m" echo "" ## Port Information echo -e "\e[33mSMTP Port:\e[97m $porta_vaultwarden\ e[0m" echo "" ## Asks if the answers are correct read -p "Are the answers correct? (Y/N): " confirmation if [ "$confirmation" = "Y" ] || [ "$confirmation" = "y" ]; then ## Typed Y to confirm that the information is correct ## Clear the terminal clear ## Show Installing message installing_msg ## Exit Loop break else ## Entered N to say that the information is not correct ## Clear terminal clear ## Shows the name of the tool name_vaultwarden ## Shows message to fill in information fill_as_info # # Returns to the beginning of the loop with the questions fi done ## Step Message echo -e "\e[97m• STARTING VAULTWARDEN INSTALLATION \e[33m[1/3]\e[0m" echo "" sleep 1 ## Nothing nothing nothing... just to see the step message. ## Step Message echo -e "\e[97m• INSTALLING VAULTWARDEN \e[33m[2/3]\e[0m" echo "" sleep 1 ## Creating stack cat > vaultwarden.yaml <<-EOF version: "3.7" services: ## --------------------------- ORION --------------------------- ## vaultwarden: image: vaultwarden/server:latest networks: - $nome_rede_interna #ports: # - 1973 :80 volumes: - vaultwarden-data:/data environment: ## Dashboard domain - DOMAIN:https://$url_vaultwarden ## Allow new registrations - SIGNUPS_ALLOWED=true ## SMTP data - SMTP_FROM=$email_vaultwarden - SMTP_USERNAME=$email_vaultwarden - SMTP_PASSWORD=$password_vaultwarden - SMTP_HOST=$host_vaultwarden - SMTP_PORT=$porta_vaultwarden - SMTP_SECURITY=$ssl_va ultwarden ## Websocket configuration - WEBSOCKET_ENABLED=true deploy: mode: replicated replicas: 1 placement: constraints: - node.role == manager labels: - "traefik.enable=true" - "traefik.http.routers.vaultwarden.rule=Host( \`$url_vaultwarden\`)" - "traefik.http.routers.vaultwarden.service=vaultwarden" - "traefik.http.routers.vaultwarden.entrypoints=websecure" - "traefik.http.services.vaultwarden.loadbalancer.server. port=80" - "traefik.http.routers.vaultwarden.tls=true" - "traefik.http.routers.vaultwarden.tls.certresolver=letsencryptresolver" - "traefik.http.services.vaultwarden.loadbalancer.passhostheader=true" - "traefik.http.routers.vaultwarden.middlewares=compresstraefik" - "traefik.http.middlewares.compresstraefik.compress=true" - "traefik.docker.network=$internal_network_name" ## --------- ------------------ ORION --------------------------- ## volumes: vaultwarden-data: external: true name: vaultwarden-data networks: $internal_network_name: external: true name: $internal_network_name EOF if [ $? -eq 0 ]; then echo "1/2 - [ OK ]" else echo "1/2 - [ OFF ]" echo "Unable to create vaultwarden stack" fi docker stack deploy --prune --resolve-image always -c vaultwarden. yaml vaultwarden > /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to upload vaultwarden stack" fi ## Step Message echo -e "\e[97m• CHECKING SERVICE \e[33m[3/3]\e[0m" echo "" sleep 1 ## Use the wait_vaultwarden service to check if the service is online wait_vaultwarden cd data_vps cat > data_vaultwarden <network=$internal_network_name" ## --------------------------- ORION --------------- ------------ ## volumes: vaultwarden-data: external: true name: vaultwarden-data networks: $internal_network_name: external: true name: $internal_network_name EOF if [ $? -eq 0 ]; then echo "1/2 - [ OK ]" else echo "1/2 - [ OFF ]" echo "Unable to create vaultwarden stack" fi docker stack deploy --prune --resolve-image always -c vaultwarden. yaml vaultwarden > /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to upload stack vaultwarden" fi ## Step Message echo -e "\e[97m• CHECKING SERVICE \e[33m[3/3]\e[0m" echo "" sleep 1 ## Uses the wait_vaultwarden service to check if the service is online wait_vaultwarden cd data_vps cat > data_vaultwarden <network=$internal_network_name" ## --------------------------- ORION --------------- ------------ ## volumes: vaultwarden-data: external: true name: vaultwarden-data networks: $internal_network_name: external: true name: $internal_network_name EOF if [ $? -eq 0 ]; then echo "1/2 - [ OK ]" else echo "1/2 - [ OFF ]" echo "Unable to create vaultwarden stack" fi docker stack deploy --prune --resolve-image always -c vaultwarden. yaml vaultwarden > /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to upload stack vaultwarden" fi ## Step Message echo -e "\e[97m• CHECKING SERVICE \e[33m[3/3]\e[0m" echo "" sleep 1 ## Uses the wait_vaultwarden service to check if the service is online wait_vaultwarden cd data_vps cat > data_vaultwarden <
                              
                              /dev/null 2>&1 sudo mv /root/blablabla/SetupOrion/Extras/Grafana/monitor-orion /opt cd rm -r blablabla cd cd ## Creating file datasource cat > datasource.yml <
                              
                              prometheus.yml <
                              
                              monitor.yaml <
                              
                              /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to upload Monitor stack" fi echo "" sleep 10 ## Step Message echo -e "\e [97m• CHECKING SERVICE \e[33m[4/4]\e[0m" echo "" sleep 1 ## Uses the wait_monitor service to check if the service is online wait_monitor cd data_vps cat > data_monitor <
                              
                              Minimum 8 characters. Use UPPERCASE and lowercase letters, numbers and a special character @ or _" echo -en "\e[33mEnter the Password or User (ex: @Password123_): \e[0m" && read -r pass_nextcloud echo "" ## Clear the terminal clear ## Shows the name of the application nextcloud_name ## Shows a message to check the information checking_as_info ## Information about nextcloud URL echo -e "\e[33mNextCloud Domain:\e[97m $url_nextcloud\e[0m" echo "" ## Information about nextcloud URL echo -e "\e[33mNextCloudUser:\e[97m $user_nextcloud\e[0m" echo "" ## Information about nextcloud URL echo -e "\e[33mPassword NextCloud:\e[97m $pass_nextcloud\e[0m" echo "" ## Asks if the answers are correct read -p "Are the answers correct? (Y/N): " confirmation if [ "$confirmation" = "Y" ] || [ "$confirmation" = "y" ]; then ## Typed Y to confirm that the information is correct ## Clear the terminal clear ## Show Installing message installing_msg ## Exit the Loop break else ## Enter N to say that the information is not correct ## Clear the terminal clear ## Show the name of the tool mini_name ## Show a message to fill in information fill_as_info # # Returns to the beginning of the loop with the questions fi done ## Step Message echo -e "\e[97m• STARTING NEXTCLOUD INSTALLATION \e[33m[1/4]\e[0m" echo "" sleep 1 ## Nadaaaaa ## Step Message echo -e "\e[97m• CHECKING/INSTALLING POSTGRES AND REIDS \e[33m[2/4]\e[0m" echo "" sleep 1 ## I'm tired of explaining what this does kkkk verify_container_postgres if [ $? -eq 0 ]; then sleep 1 get_password_postgres > /dev/null 2>&1 create_banco_postgres_nextcloud #> /dev/null 2>&1 else tool_postgres > /dev/null 2>&1 get_password_postgres > /dev/ null 2>&1 create_banco_postgres_nextcloud #> /dev/null 2>&1 fi if [ $? -eq 0 ]; then echo "1/2 - [ OK ]" else echo "1/2 - [ OFF ]" fi verify_container_redis if [ $? -eq 0 ]; then sleep 1 else redis_tool > /dev/null 2>&1 fi if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" fi echo "" ## Step Message echo -e "\e[97m• INSTALLING NEXTCLOUD \e[33m[3/4 ]\e[0m" echo "" sleep 1 ## Creating the stack cat > nextcloud.yaml <
                              
                              /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to upload nextcloud stack" fi echo "" ## Step Message echo -e "\e[97m • CHECKING SERVICE \e[33m[4/4]\e[0m" echo "" sleep 1 ## Uses the wait_nextcloud service to check if the service is online wait_nextcloud cd data_vps cat > data_nextcloud <
                              
                              /dev/null 2>&1 if [ $? -eq 0 ]; then echo "1/2 - [ OK ]" else echo "1/2 - [ OFF ]" echo "Unable to restart portainer" fi docker service update --force $(docker service ls --filter name='portainer_portainer ' -q) > /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/2 - [ OK ]" else echo "2/2 - [ OFF ]" echo "Unable to restart portainer" fi sleep 2 clear } chatwoot.nulled() { echo "" echo "Please wait.. ." echo "" while :; do if docker ps -q --filter "name=postgres" | grep -q.; then CONTAINER_ID=$(docker ps -q --filter "name=postgres") docker exec -i "$CONTAINER_ID" psql -U postgres -d chatwoot -c \ "UPDATE public.installation_configs SET serialized_value = '\"--- !ruby/hash:ActiveSupport::HashWithIndifferentAccess\nvalue: enterprise\n\"' WHERE name = 'INSTALLATION_PRICING_PLAN'; \ UPDATE public.installation_configs SET serialized_value = '\"--- !ruby/hash:ActiveSupport::HashWithIndifferentAccess\nvalue : 200\n\"' WHERE name = 'INSTALLATION_PRICING_PLAN_QUANTITY';" if [$? -eq 0 ]; then echo "1/1 - [ OK ]" else echo "1/1 - [ OFF ]" echo "Unable to do this, change via pgadmin." fi sleep 2 break else sleep 5 fi done } chatwoot.uno.nulled() { echo "" echo "Please wait..." echo "" while :; do if docker ps -q --filter "name=postgres" | grep -q.; then CONTAINER_ID=$(docker ps -q --filter "name=postgres") docker exec -i "$CONTAINER_ID" psql -U postgres -d chatwoot_uno -c \ "UPDATE public.installation_configs SET serialized_value = '\"--- !ruby/hash:ActiveSupport::HashWithIndifferentAccess\nvalue: enterprise\n\"' WHERE name = 'INSTALLATION_PRICING_PLAN'; \ UPDATE public.installation_configs SET serialized_value = '\"--- !ruby/hash:ActiveSupport::HashWithIndifferentAccess\nvalue : 200\n\"' WHERE name = 'INSTALLATION_PRICING_PLAN_QUANTITY';" if [$? -eq 0 ]; then echo "1/1 - [ OK ]" else echo "1/1 - [ OFF ]" echo "Unable to do this, change via pgadmin." fi sleep 2 break else sleep 5 fi done } chatwoot.mail() { echo "" echo "Please wait while we exchange emails..." echo "" cd /var/lib/docker/volumes/chatwoot_public_orion/_data/app/views /devise/mailer/ # Rename files mv password_change.html.erb password_change.html.erb.old > /dev/null 2>&1 if [ $? -eq 0 ]; then echo "1/9 - [ OK ]" else echo "1/9 - [ OFF ]" echo "Unable to change email." fi mv confirmation_instructions.html.erb confirmation_instructions.html.erb.old > /dev/null 2>&1 if [ $? -eq 0 ]; then echo "2/9 - [ OK ]" else echo "2/9 - [ OFF ]" echo "Unable to change email." fi mv reset_password_instructions.html.erb reset_password_instructions.html.erb.old > /dev/null 2>&1 if [ $? -eq 0 ]; then echo "3/9 - [ OK ]" else echo "3/9 - [ OFF ]" echo "Unable to change email." fi mv unlock_instructions.html.erb unlock_instructions.html.erb.old > /dev/null 2>&1 if [ $? -eq 0 ]; then echo "4/9 - [ OK ]" else echo "4/9 - [ OFF ]" echo "Unable to change email." fi # Download the new files wget -O confirmation_instructions.html.erb https://github.com/oriondesign2015/SetupOrion/raw/main/Extras/Chatwoot/emails/confirmation_instructions.html.erb > /dev/null 2>&1 if [$? -eq 0 ]; then echo "5/9 - [ OK ]" else echo "5/9 - [ OFF ]" echo "Unable to download email." fi wget -O password_change.html.erb https://github.com/oriondesign2015/SetupOrion/raw/main/Extras/Chatroot/emails/password_change.html.erb > /dev/null 2>&1 if [ $? -eq 0 ]; then echo "6/9 - [ OK ]" else echo "6/9 - [ OFF ]" echo "Unable to download email." fi wget -O reset_password_instructions.html.erb https://github.com/oriondesign2015/SetupOrion/raw/main/Extras/Chatwoot/emails/reset_password_instructions.html.erb > /dev/null 2>&1 if [ $? -eq 0 ]; then echo "7/9 - [ OK ]" else echo "7/9 - [ OFF ]" echo "Unable to download email." fi wget -O unlock_instructions.html.erb https://github.com/oriondesign2015/SetupOrion/raw/main/Extras/Chatroot/emails/unlock_instructions.html.erb > /dev/null 2>&1 if [ $? -eq 0 ]; then echo "8/9 - [ OK ]" else echo "8/9 - [ OFF ]" echo "Unable to download email." fi cd cd # Deletes Chatwoot containers docker rm -f $(docker ps -a | grep 'chatwoot' | awk '{print $1}') > /dev/null 2>&1 if [ $? -eq 0 ]; then echo "9/9 - [ OK ]" else echo "9/9 - [ OFF ]" echo "Unable to delete containers." fi echo "" echo "Waiting for containers to go up..." wait_30_sec echo "" echo "Done!" sleep 2 } n8n.workflows(){ while true; do if docker ps -q --filter "name=n8n_quepasa_n8n_quepasa_editor" | grep -q.; then # Capture the container ID container_id=$(docker ps --filter "name=n8n_quepasa_n8n_quepasa_editor" --format "{{.ID}}") # Check if the container ID was captured correctly if [ -z "$container_id " ]; then echo "Error: Unable to find container ID." exit 1 fi # Execute the code in the container only if it is running docker exec "$container_id" /bin/sh -c ' # Creating temporary directory temp_dir=$(mktemp -d) # Entering the temporary directory cd "$temp_dir " # Downloading workflows wget "https://raw.githubusercontent.com/nocodeleaks/quepasa/main/extra/n8n%2Bchatwoot/ChatwootProfileUpdate.json" wget "https://raw.githubusercontent.com/oriondesign2015/SetupOrion/main/ Extras/Quepasa/workflows_n8n/ChatwootToQuepasa.json" wget "https://raw.githubusercontent.com/nocodeleaks/quepasa/main/extra/n8n%2Bchatwoot/ChatwootToQuepasaGreetings.json" wget "https://raw.githubusercontent.com/ oriondesign2015/SetupOrion/main/Extras/Quepasa/workflows_n8n/PostToChatwoot.json" wget "https://raw.githubusercontent.com/oriondesign2015/SetupOrion/main/Extras/Quepasa/workflows_n8n/QuepasaAutomatic.json" wget "https:// raw.githubusercontent.com/nocodeleaks/quepasa/main/extra/n8n%2Bchatwoot/QuepasaChatControl.json" wget "https://raw.githubusercontent.com/nocodeleaks/quepasa/main/extra/n8n%2Bchatwoot/QuepasaInboxControl.json" wget "https://raw.githubusercontent.com/oriondesign2015/SetupOrion/main/Extras/Quepasa/workflows_n8n/QuepasaQrcode.json" wget "https://raw.githubusercontent.com/nocodeleaks/quepasa/main/extra/n8n% 2Bchatwoot/QuepasaToChatwoot.json" wget "https://raw.githubusercontent.com/nocodeleaks/quepasa/main/extra/n8n%2Bchatwoot/GetChatwootContacts.json" wget "https://raw.githubusercontent.com/nocodeleaks/quepasa/ main/extra/n8n%2Bchatroot/PostToWebCallBack.json" # Uploading workflows n8n import:workflow --input="$temp_dir" --separate # Checking if the workflows were imported successfully if [ $? -eq 0 ]; then echo "Workflows imported successfully" else echo "Error importing workflows" exit 1 fi # Activating workflows n8n update:workflow --id 1008 --active=true && echo "Flow 1008 activated" || echo "Error activating flow 1008" n8n update:workflow --id 1009 --active=true && echo "Flow 1009 activated" || echo "Error activating flow 1009" n8n update:workflow --id 1010 --active=true && echo "Flow 1010 activated" || echo "Error activating flow 1010" n8n update:workflow --id 1011 --active=true && echo "Flow 1011 activated" || echo "Error when activating flow 1011" ' break else clear error_msg echo "" echo -e "Oops, it looks like you didn't install the option \e[32m[6] N8N${reset} ${white} from our installer.${reset}" echo "Install before trying to install this application." echo "" echo "Press CTRL C to exit the installer." sleep 5 exit fi done } portainer.reset() { cd clear portainer_name.reset echo "Please wait while I reset the portainer password..." echo "" docker service scale portainer_portainer=0 > /dev/null 2>&1 if [ $? -eq 0 ]; then echo "1/7 - [ OK ]" else echo "1/7 - [ OFF ]" echo "Oops, unable to drop portainer service" fi docker pull portainer/helper-reset-password > /dev/null 2>&1 if [ $? -eq 0 ]; else echo "2/7 - [ OFF ]" echo "Oops, it was not possible to supercharge the portainer password reset service" fi script -c "docker run --rm -v /var/lib/docker/volumes/portainer_data/ _data:/data portainer/helper-reset-password" output.txt > /dev/null 2>&1 if [ $? -eq 0 ]; then echo "3/7 - [ OK ]" else echo "3/7 - [ OFF ]" echo "Oops, it was not possible to reset the portainer password" fi cd docker stack deploy --prune --resolve-image always -c portainer.yaml portainer > /dev/null 2>&1 if [ $? - eq 0 ]; then echo "4/7 - [ OK ]" else echo "4/7 - [ OFF ]" echo "Oops, unable to upload portainer stack" fi USER=$(grep -oP 'user: \K[^,]*' output.txt) if [ $? -eq 0 ]; then echo "5/7 - [ OK ]" else echo "5/7 - [ OFF ]" echo "Oops, it was not possible get the portainer user" fi PASSWORD=$(grep -oP 'login: \K.*' output.txt) if [ $? -eq 0 ]; then echo "6/7 - [ OK ]" else echo "6/7 - [ OFF ]" echo "Oops, it was not possible to get the portainer's password" fi rm output.txt if [ $? -eq 0 ]; then echo "7/7 - [ OK ]" else echo "7/7 - [ OFF ]" echo "Oops, it was not possible to remove the output. txt file or it does not exist" fi echo "" sleep 3 clear portainer_name.reset echo -e "\e[32m[ PORTAINER ]\e[0m" echo "" echo -e "\e[97mUser:\e[33m $USER\e[0m" echo "" echo -e "\e[97mNew Password:\e[33m $PASSWORD\e[0m" echo "" ## Installer credits creditos_msg read -p "Do you want to return to the main menu (Y/N): " choice if [ "$choice" = "Y" ] || [ "$choice" = "y" ]; then return else cd cd clear exit 1 fi } ###################################### ############ ## Starting installer ## Show installer name installer_name ## Show installer rights installer_rights ##After pressing Y and confirm continues.. ## Options menu (backend) while true ; do nome_menu menu_instalador read -p "Enter the NUMBER of the desired option: " option case $opcao in 0) tool_testeemail ;; 1) tool_traefik_e_portainer ;; 2) if verify_docker_e_portainer_traefik; then tool_chatroot fi ;; 2.1) if verify_docker_e_portainer_traefik; then tool_chatroot_arm fi ;; 3) if verify_docker_e_portainer_traefik; then tool_evolution fi ;; 3.1) if verify_docker_e_portainer_traefik; then tool_evolution_arm fi ;; 4) if verify_docker_e_portainer_traefik; then minio_tool fi ;; 5) if verify_docker_e_portainer_traefik && verify_before_se_has_minio; then tool_typebot fi ;; 6) if verify_docker_e_portainer_traefik; then tool_n8n fi ;; 7) if verify_docker_e_portainer_traefik; then tool_flowise fi ;; 8) if verify_docker_e_portainer_traefik; then tool_pgAdmin_4 fi ;; 9) if verify_docker_e_portainer_traefik; then tool_nocobase fi ;; 10) if verify_docker_e_portainer_traefik; then tool_botpress fi ;; 11) if verify_docker_e_portainer_traefik; then tool_wordpress fi ;; 12) if verify_docker_e_portainer_traefik; then tool_baserow fi ;; 13) if verify_docker_e_portainer_traefik; then tool_mongodb fi ;; 14) if verify_docker_e_portainer_traefik; then tool_rabbitmq fi ;; 15) if verify_docker_e_portainer_traefik; then tool_uptimekuma fi ;; 16) if verify_docker_e_portainer_traefik; then tool_calcom fi ;; 17) if verify_docker_e_portainer_traefik; then tool_mautic fi ;; 18) if verify_docker_e_portainer_traefik; then tool_appsmith fi ;; 19) if verify_docker_e_portainer_traefik; then tool_qdrant fi ;; 20) if verify_docker_e_portainer_traefik; then tool_woofed fi ;; 21) if verify_docker_e_portainer_traefik; then tool_formbricks fi ;; 22) if verify_docker_e_portainer_traefik; then tool_nocodb fi ;; 23) if verify_docker_e_portainer_traefik; then tool_langfuse fi ;; 24) if verify_docker_e_portainer_traefik; then tool_metabase fi ;; 25) if verify_docker_e_portainer_traefik; then tool_odoo fi ;; 26) if verify_docker_e_portainer_traefik; then tool_chatroot_nestor fi ;; 27) if verify_docker_e_portainer_traefik && verify_before_se_tem_minio_e_rabbitmq_e_chatroot; then tool_unoapi fi ;; 28) if verify_docker_e_portainer_traefik; then tool_n8n_quepasa fi ;; 29) if verify_docker_e_portainer_traefik; then tool_quepasa fi ;; 30) if verify_docker_e_portainer_traefik; then tool_docuseal fi ;; 31) if verify_docker_e_portainer_traefik; then tool_monitor fi ;; 32) if verify_docker_e_portainer_traefik && verify_before_se_tem_minio_e_qdrant; then tool_dify fi ;; 33) if verify_docker_e_portainer_traefik; then tool_ollama fi ;; 34) if verify_docker_e_portainer_traefik; then tool_affine fi ;; 35) if verify_docker_e_portainer_traefik && verify_before_se_has_minio; then tool_directus fi ;; 36) if verify_docker_e_portainer_traefik; then tool_vaultwarden fi ;; 37) if verify_docker_e_portainer_traefik; then tool_nextcloud fi ;; 38) if verify_docker_e_portainer_traefik; then tool_ fi ;; 39) if verify_docker_e_portainer_traefik; then tool_remove_stack fi ;; 40) clearleaving_name echo "" break ;; 23a) tool_remove_stack ;; 24a) echo "Exiting..." break ;; n8n.workflows) n8n.workflows ;; portainer.restart) portainer.restart ;; portainer.reset) portainer.reset ;; chatwoot.nulled) chatwoot.nulled ;; chatwoot.uno.nulled) chatwoot.uno.nulled ;; chatwoot.mail) chatwoot.mail ;; *) ;; esac echo "" done
                              
                              
                              
                              
                              
